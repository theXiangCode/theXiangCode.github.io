<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spark SQL</title>
      <link href="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SparkSQL概述"><a href="#1-SparkSQL概述" class="headerlink" title="1. SparkSQL概述"></a>1. SparkSQL概述</h2><h3 id="1-1-SparkSQL概述"><a href="#1-1-SparkSQL概述" class="headerlink" title="1.1 SparkSQL概述"></a>1.1 SparkSQL概述</h3><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862363634.png" alt="1662862363634"></p><p>​Spark SQL是Spark用于结构化数据处理的Spark模块</p><h3 id="1-2-Hive-and-SparkSQL"><a href="#1-2-Hive-and-SparkSQL" class="headerlink" title="1.2 Hive and SparkSQL"></a>1.2 Hive and SparkSQL</h3><p>​SparkSQL的前身是Shark，给熟悉RDBMS但又不理解MapReduce的技术人员提供快速上手的工具。</p><p>​Hive是早期唯一运行在Hadoop上的SQL-on-Hadoop工具。但是MapReduce计算过程中大量的中间磁盘落地过程消耗了大量的I&#x2F;O，降低的运行效率，为了提高SQL-on-Hadoop的效率，大量的SQL-on-Hadoop工具开始产生，其中表现较为突出的是：</p><ul><li><p>Drill</p></li><li><p>Impala</p></li><li><p>Shark</p></li></ul><p>其中Shark是伯克利实验室Spark生态环境的组件之一，是基于Hive所开发的工具，它修改了下图所示的右下角的内存管理、物理计划、执行三个模块，并使之能运行在Spark引擎上。</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862569694.png" alt="1662862569694"></p><p>​Shark的出现，使得SQL-on-Hadoop的性能比Hive有了10-100倍的提高。</p><p>​但是，随着Spark的发展，对于野心勃勃的Spark团队来说，Shark对于Hive的太多依赖（如采用Hive的语法解析器、查询优化器等等），制约了Spark的One Stack Rule Them All的既定方针，制约了Spark各个组件的相互集成，所以提出了SparkSQL项目。SparkSQL抛弃原有Shark的代码，汲取了Shark的一些优点，如内存列存储（In-Memory Columnar Storage）、Hive兼容性等，重新开发了SparkSQL代码；由于摆脱了对Hive的依赖性，SparkSQL无论在数据兼容、性能优化、组件扩展方面都得到了极大的方便，真可谓“退一步，海阔天空”。</p><ul><li><p>数据兼容方面 SparkSQL不但兼容Hive，还可以从RDD、parquet文件、JSON文件中获取数据，未来版本甚至支持获取RDBMS数据以及cassandra等NOSQL数据；</p></li><li><p>性能优化方面 除了采取In-Memory Columnar Storage、byte-code generation等优化技术外、将会引进Cost Model对查询进行动态评估、获取最佳物理计划等等；</p></li><li><p>组件扩展方面 无论是SQL的语法解析器、分析器还是优化器都可以重新定义，进行扩展。</p></li></ul><p>2014年6月1日Shark项目和SparkSQL项目的主持人Reynold Xin宣布：停止对Shark的开发，团队将所有资源放SparkSQL项目上，至此，Shark的发展画上了句话，但也因此发展出两个支线：SparkSQL和Hive on Spark。</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862690111.png" alt="1662862690111"></p><p>​其中SparkSQL作为Spark生态的一员继续发展，而不再受限于Hive，只是兼容Hive；而Hive on Spark是一个Hive的发展计划，该计划将Spark作为Hive的底层引擎之一，也就是说，Hive将不再受限于一个引擎，可以采用Map-Reduce、Tez、Spark等引擎。</p><p>​对于开发人员来讲，SparkSQL可以简化RDD的开发，提高开发效率，且执行效率非常快，所以实际工作中，基本上采用的就是SparkSQL。Spark SQL为了简化RDD的开发，提高开发效率，提供了2个编程抽象，类似Spark Core中的RDD</p><ul><li><p>DataFrame</p></li><li><p>DataSet</p></li></ul><h3 id="1-3-SparkSQL特点"><a href="#1-3-SparkSQL特点" class="headerlink" title="1.3 SparkSQL特点"></a>1.3 SparkSQL特点</h3><h4 id="1-3-1-易整合"><a href="#1-3-1-易整合" class="headerlink" title="1.3.1 易整合"></a>1.3.1 易整合</h4><p>无缝整合了SQL查询和Spark编程</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862849206.png" alt="1662862849206"> </p><h4 id="1-3-2-统一的数据访问"><a href="#1-3-2-统一的数据访问" class="headerlink" title="1.3.2 统一的数据访问"></a>1.3.2 统一的数据访问</h4><p>使用相同的方式连接不同的数据源</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862889844.png" alt="1662862889844"></p><h4 id="1-3-3-兼容Hive"><a href="#1-3-3-兼容Hive" class="headerlink" title="1.3.3 兼容Hive"></a>1.3.3 兼容Hive</h4><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862928051.png" alt="1662862928051"></p><h4 id="1-3-4-标准数据连接"><a href="#1-3-4-标准数据连接" class="headerlink" title="1.3.4 标准数据连接"></a>1.3.4 标准数据连接</h4><p>通过JDBC或者ODBC来连接</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662862964775.png" alt="1662862964775"></p><h3 id="1-4-DataFrame是什么"><a href="#1-4-DataFrame是什么" class="headerlink" title="1.4 DataFrame是什么"></a>1.4 DataFrame是什么</h3><p>​在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。DataFrame与RDD的主要区别在于，前者带有schema元信息，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。</p><p>​同时，与Hive类似，DataFrame也支持嵌套数据类型（struct、array和map）。从 API 易用性的角度上看，DataFrame API提供的是一套高层的关系操作，比函数式的RDD API 要更加友好，门槛更低。</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863065683.png" alt="1662863065683"></p><p>​上图直观地体现了DataFrame和RDD的区别。</p><p>​左侧的RDD[Person]虽然以Person为类型参数，但Spark框架本身不了解Person类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得 Spark SQL 可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。</p><p>​DataFrame是为数据提供了Schema的视图。可以把它当做数据库中的一张表来对待</p><p>​DataFrame也是懒执行的，但性能上比RDD要高，主要原因：优化的执行计划，即查询计划通过Spark catalyst optimiser进行优化。比如下面一个例子:</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863134082.png" alt="1662863134082"></p><p>​为了说明查询优化，我们来看上图展示的人口数据分析的示例。图中构造了两个DataFrame，将它们join之后又做了一次filter操作。如果原封不动地执行这个执行计划，最终的执行效率是不高的。因为join是一个代价较大的操作，也可能会产生一个较大的数据集。如果我们能将filter下推到 join下方，先对DataFrame进行过滤，再join过滤后的较小的结果集，便可以有效缩短执行时间。而Spark SQL的查询优化器正是这样做的。简而言之，逻辑查询计划优化就是一个利用基于关系代数的等价变换，将高成本的操作替换为低成本操作的过程。</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863169213.png" alt="1662863169213"></p><h3 id="1-5-DataSet是什么"><a href="#1-5-DataSet是什么" class="headerlink" title="1.5 DataSet是什么"></a>1.5 DataSet是什么</h3><p>​DataSet是分布式数据集合。DataSet是Spark 1.6中添加的一个新抽象，是DataFrame的一个扩展。它提供了RDD的优势（强类型，使用强大的lambda函数的能力）以及Spark SQL优化执行引擎的优点。DataSet也可以使用功能性的转换（操作map，flatMap，filter等等）。</p><ul><li><p>DataSet是DataFrame API的一个扩展，是SparkSQL最新的数据抽象</p></li><li><p>用户友好的API风格，既具有类型安全检查也具有DataFrame的查询优化特性；</p></li><li><p>用样例类来对DataSet中定义数据的结构信息，样例类中每个属性的名称直接映射到DataSet中的字段名称；</p></li><li><p>DataSet是强类型的。比如可以有DataSet[Car]，DataSet[Person]。</p></li><li><p>DataFrame是DataSet的特列，DataFrame&#x3D;DataSet[Row] ，所以可以通过as方法将DataFrame转换为DataSet。Row是一个类型，跟Car、Person这些的类型一样，所有的表结构信息都用Row来表示。获取数据时需要指定顺序</p></li></ul><h2 id="2-SparkSQL核心编程"><a href="#2-SparkSQL核心编程" class="headerlink" title="2. SparkSQL核心编程"></a>2. SparkSQL核心编程</h2><p>​Spark Core中，如果想要执行应用程序，需要首先构建上下文环境对象SparkContext，Spark SQL其实可以理解为对Spark Core的一种封装，不仅仅在模型上进行了封装，上下文环境对象也进行了封装。</p><p>​在老的版本中，SparkSQL提供两种SQL查询起始点：一个叫SQLContext，用于Spark自己提供的SQL查询；一个叫HiveContext，用于连接Hive的查询。</p><p>​SparkSession是Spark最新的SQL查询起始点，实质上是SQLContext和HiveContext的组合，所以在SQLContex和HiveContext上可用的API在SparkSession上同样是可以使用的。SparkSession内部封装了SparkContext，所以计算实际上是由sparkContext完成的。当我们使用 spark-shell 的时候, spark框架会自动的创建一个名称叫做spark的SparkSession对象, 就像我们以前可以自动获取到一个sc来表示SparkContext对象一样</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863406311.png" alt="1662863406311"></p><h3 id="2-1-DataFrame"><a href="#2-1-DataFrame" class="headerlink" title="2.1 DataFrame"></a>2.1 DataFrame</h3><h4 id="2-1-1-创建DataFrame"><a href="#2-1-1-创建DataFrame" class="headerlink" title="2.1.1 创建DataFrame"></a>2.1.1 创建DataFrame</h4><p>​在Spark SQL中SparkSession是创建DataFrame和执行SQL的入口，创建DataFrame有三种方式：</p><ol><li>通过Spark的数据源进行创建；</li><li>从一个存在的RDD进行转换；</li><li>还可以从Hive Table进行查询返回。</li></ol><p><strong>从Spark数据源进行创建</strong></p><p>支持的文件格式：</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863811464.png" alt="1662863811464"></p><p>创建文件：</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863835657.png" alt="1662863835657"></p><p>读取文件创建DataFrame</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863867955.png" alt="1662863867955"></p><p>注意：如果从内存中获取数据，spark可以知道数据类型具体是什么。如果是数字，默认作为Int处理；但是从文件中读取的数字，不能确定是什么类型，所以用bigint接收，可以和Long类型转换，但是和Int不能进行转换</p><p>展示结果：show</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662863903656.png" alt="1662863903656"></p><p>另外两种创建方式会在后续进行介绍</p><h4 id="2-1-2-SQL语法"><a href="#2-1-2-SQL语法" class="headerlink" title="2.1.2 SQL语法"></a>2.1.2 SQL语法</h4><p>​SQL语法风格是指我们查询数据的时候使用SQL语句来查询，这种风格的查询必须要有临时视图或者全局视图来辅助</p><ol><li>读取文件创建DataFrame</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;data/user.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint， username: string]</span><br></pre></td></tr></table></figure><ol start="2"><li>对DataFrame创建一个临时表（视图）</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>通过SQL语句实现查询</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> sqlDF = spark.sql(<span class="string">&quot;SELECT * FROM people&quot;</span>)</span><br><span class="line">sqlDF: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint， name: string]</span><br></pre></td></tr></table></figure><ol start="4"><li>结果展示</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; sqlDF.show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">20</span>|zhangsan|</span><br><span class="line">| <span class="number">30</span>|     lisi|</span><br><span class="line">| <span class="number">40</span>|   wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure><ol start="5"><li>创建一个全局表格</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.createGlobalTempView(<span class="string">&quot;people&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>通过SQL语句实现查询全表</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.sql(<span class="string">&quot;SELECT * FROM global_temp.people&quot;</span>).show()</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">20</span>|zhangsan|</span><br><span class="line">| <span class="number">30</span>|     lisi|</span><br><span class="line">| <span class="number">40</span>|   wangwu|</span><br><span class="line">+---+--------+</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession().sql(<span class="string">&quot;SELECT * FROM global_temp.people&quot;</span>).show()</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">20</span>|zhangsan|</span><br><span class="line">| <span class="number">30</span>|     lisi|</span><br><span class="line">| <span class="number">40</span>|   wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure><h4 id="2-1-3-DSL-语法"><a href="#2-1-3-DSL-语法" class="headerlink" title="2.1.3 DSL 语法"></a>2.1.3 DSL 语法</h4><p>​DataFrame提供一个特定领域语言(domain-specific language,DSL)去管理结构化的数据。可以在 Scala, Java, Python 和 R 中使用 DSL，使用 DSL 语法风格不必去创建临时视图了</p><ol><li>创建一个DataFrame</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;data/user.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint， name: string]</span><br></pre></td></tr></table></figure><ol start="2"><li>查看DataFrame的Schema信息</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.printSchema</span><br><span class="line">root</span><br><span class="line"> |-- age: <span class="type">Long</span> (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- username: string (nullable = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>只查看”username”列数据，</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.select(<span class="string">&quot;username&quot;</span>).show()</span><br><span class="line">+--------+</span><br><span class="line">|username|</span><br><span class="line">+--------+</span><br><span class="line">|zhangsan|</span><br><span class="line">|     lisi|</span><br><span class="line">|   wangwu|</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><ol start="4"><li>查看”username”列数据以及”age+1”数据</li></ol><p>注意:涉及到运算的时候, 每列都必须使用$, 或者采用引号表达式：单引号+字段名</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.select($<span class="string">&quot;username&quot;</span>,$<span class="string">&quot;age&quot;</span> + <span class="number">1</span>).show</span><br><span class="line">scala&gt; df.select(&#x27;username, &#x27;age + <span class="number">1</span>).show()</span><br><span class="line">scala&gt; df.select(&#x27;username, &#x27;age + <span class="number">1</span> as <span class="string">&quot;newage&quot;</span>).show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------+---------+</span><br><span class="line">|username|(age + <span class="number">1</span>)|</span><br><span class="line">+--------+---------+</span><br><span class="line">|zhangsan|        <span class="number">21</span>|</span><br><span class="line">|     lisi|        <span class="number">31</span>|</span><br><span class="line">|  wangwu|         <span class="number">41</span>|</span><br><span class="line">+--------+---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>查看”age”大于”30”的数据</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.filter($<span class="string">&quot;age&quot;</span>&gt;<span class="number">30</span>).show</span><br><span class="line">+---+---------+</span><br><span class="line">|age| username|</span><br><span class="line">+---+---------+</span><br><span class="line">| <span class="number">40</span>|    wangwu|</span><br><span class="line">+---+---------+</span><br></pre></td></tr></table></figure><ol start="6"><li>按照”age”分组，查看数据条数</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.groupBy(<span class="string">&quot;age&quot;</span>).count.show</span><br><span class="line">+---+-----+</span><br><span class="line">|age|count|</span><br><span class="line">+---+-----+</span><br><span class="line">| <span class="number">20</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">30</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">40</span>|    <span class="number">1</span>|</span><br><span class="line">+---+-----+</span><br></pre></td></tr></table></figure><h4 id="2-1-4-RDD转换为DataFrame"><a href="#2-1-4-RDD转换为DataFrame" class="headerlink" title="2.1.4 RDD转换为DataFrame"></a>2.1.4 RDD转换为DataFrame</h4><p>​在IDEA中开发程序时，如果需要RDD与DF或者DS之间互相操作，那么需要引入 import spark.implicits._</p><p>​这里的spark不是Scala中的包名，而是创建的sparkSession对象的变量名称，所以必须先创建SparkSession对象再导入。这里的spark对象不能使用var声明，因为Scala只支持val修饰的对象的引入。</p><p>​spark-shell中无需导入，自动完成此操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> idRDD = sc.textFile(<span class="string">&quot;data/id.txt&quot;</span>)</span><br><span class="line">scala&gt; idRDD.toDF(<span class="string">&quot;id&quot;</span>).show</span><br><span class="line">+---+</span><br><span class="line">| id|</span><br><span class="line">+---+</span><br><span class="line">|  <span class="number">1</span>|</span><br><span class="line">|  <span class="number">2</span>|</span><br><span class="line">|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">4</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure><p>​<strong>实际开发中，一般通过样例类将RDD转换为DataFrame</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line">scala&gt; sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>), (<span class="string">&quot;lisi&quot;</span>,<span class="number">40</span>))).map(t=&gt;<span class="type">User</span>(t._1, t._2)).toDF.show</span><br><span class="line">+--------+---+</span><br><span class="line">|     name|age|</span><br><span class="line">+--------+---+</span><br><span class="line">|zhangsan| <span class="number">30</span>|</span><br><span class="line">|    lisi| <span class="number">40</span>|</span><br><span class="line">+--------+---+</span><br></pre></td></tr></table></figure><h4 id="2-1-5-DataFrame转换为RDD"><a href="#2-1-5-DataFrame转换为RDD" class="headerlink" title="2.1.5 DataFrame转换为RDD"></a>2.1.5 DataFrame转换为RDD</h4><p>​DataFrame其实就是对RDD的封装，所以可以直接获取内部的RDD</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>), (<span class="string">&quot;lisi&quot;</span>,<span class="number">40</span>))).map(t=&gt;<span class="type">User</span>(t._1, t._2)).toDF</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: int]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = df.rdd</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">46</span>] at rdd at &lt;console&gt;:<span class="number">25</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> array = rdd.collect</span><br><span class="line">array: <span class="type">Array</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">Array</span>([zhangsan,<span class="number">30</span>], [lisi,<span class="number">40</span>])</span><br></pre></td></tr></table></figure><p>​注意：此时得到的RDD存储类型为Row注意：此时得到的RDD存储类型为Row</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; array(<span class="number">0</span>)</span><br><span class="line">res28: org.apache.spark.sql.<span class="type">Row</span> = [zhangsan,<span class="number">30</span>]</span><br><span class="line">scala&gt; array(<span class="number">0</span>)(<span class="number">0</span>)</span><br><span class="line">res29: <span class="type">Any</span> = zhangsan</span><br><span class="line">scala&gt; array(<span class="number">0</span>).getAs[<span class="type">String</span>](<span class="string">&quot;name&quot;</span>)</span><br><span class="line">res30: <span class="type">String</span> = zhangsan</span><br></pre></td></tr></table></figure><h3 id="2-2-DataSet"><a href="#2-2-DataSet" class="headerlink" title="2.2 DataSet"></a>2.2 DataSet</h3><h4 id="2-2-1-创建DataSet"><a href="#2-2-1-创建DataSet" class="headerlink" title="2.2.1 创建DataSet"></a>2.2.1 创建DataSet</h4><ol><li>使用样例类序列来创建DataSet</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> caseClassDS = <span class="type">Seq</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">2</span>)).toDS()</span><br><span class="line"></span><br><span class="line">caseClassDS: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: <span class="type">Long</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; caseClassDS.show</span><br><span class="line">+---------+---+</span><br><span class="line">|     name|age|</span><br><span class="line">+---------+---+</span><br><span class="line">| zhangsan|  <span class="number">2</span>|</span><br><span class="line">+---------+---+</span><br></pre></td></tr></table></figure><ol start="2"><li>使用基本类型的序列创建DataSet</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> ds = <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Int</span>] = [value: int]</span><br><span class="line"></span><br><span class="line">scala&gt; ds.show</span><br><span class="line">+-----+</span><br><span class="line">|value|</span><br><span class="line">+-----+</span><br><span class="line">|    <span class="number">1</span>|</span><br><span class="line">|    <span class="number">2</span>|</span><br><span class="line">|    <span class="number">3</span>|</span><br><span class="line">|    <span class="number">4</span>|</span><br><span class="line">|    <span class="number">5</span>|</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure><p>​注意：在实际使用的时候，很少用到把序列转换成DataSet，更多的是通过RDD来得到DataSet</p><h4 id="2-2-2-RDD转换为DataSet"><a href="#2-2-2-RDD转换为DataSet" class="headerlink" title="2.2.2 RDD转换为DataSet"></a>2.2.2 RDD转换为DataSet</h4><p>​SparkSQL能够自动将包含有case类的RDD转换成DataSet，case类定义了table的结构，case类属性通过反射变成了表的列名。Case类可以包含诸如Seq或者Array等复杂的结构。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>), (<span class="string">&quot;lisi&quot;</span>,<span class="number">49</span>))).map(t=&gt;<span class="type">User</span>(t._1, t._2)).toDS</span><br><span class="line">res11: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">User</span>] = [name: string, age: int]</span><br></pre></td></tr></table></figure><h4 id="2-2-3-DataSet转换为RDD"><a href="#2-2-3-DataSet转换为RDD" class="headerlink" title="2.2.3 DataSet转换为RDD"></a>2.2.3 DataSet转换为RDD</h4><p>​DataSet其实也是对RDD的封装，所以可以直接获取内部的RDD</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>), (<span class="string">&quot;lisi&quot;</span>,<span class="number">49</span>))).map(t=&gt;<span class="type">User</span>(t._1, t._2)).toDS</span><br><span class="line">res11: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">User</span>] = [name: string, age: int]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = res11.rdd</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">User</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">51</span>] at rdd at &lt;console&gt;:<span class="number">25</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.collect</span><br><span class="line">res12: <span class="type">Array</span>[<span class="type">User</span>] = <span class="type">Array</span>(<span class="type">User</span>(zhangsan,<span class="number">30</span>), <span class="type">User</span>(lisi,<span class="number">49</span>))</span><br></pre></td></tr></table></figure><h3 id="2-3-DataFrame和DataSet的转换"><a href="#2-3-DataFrame和DataSet的转换" class="headerlink" title="2.3 DataFrame和DataSet的转换"></a>2.3 DataFrame和DataSet的转换</h3><p>​DataFrame其实是DataSet的特例，所以它们之间是可以互相转换的。</p><p> <strong>DataFrame转换为DataSet</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name:<span class="type">String</span>, age:<span class="type">Int</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>), (<span class="string">&quot;lisi&quot;</span>,<span class="number">49</span>))).toDF(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: int]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = df.as[<span class="type">User</span>]</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">User</span>] = [name: string, age: int]</span><br></pre></td></tr></table></figure><p> <strong>DataSet转换为DataFrame</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> ds = df.as[<span class="type">User</span>]</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">User</span>] = [name: string, age: int]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = ds.toDF</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: int]</span><br></pre></td></tr></table></figure><h3 id="2-4-RDD、DataFrame、DataSet三者的关系"><a href="#2-4-RDD、DataFrame、DataSet三者的关系" class="headerlink" title="2.4 RDD、DataFrame、DataSet三者的关系"></a>2.4 RDD、DataFrame、DataSet三者的关系</h3><p>​在SparkSQL中Spark为我们提供了两个新的抽象，分别是DataFrame和DataSet。他们和RDD有什么区别呢？首先从版本的产生上来看：</p><ul><li><p>Spark1.0 &#x3D;&gt; RDD </p></li><li><p>Spark1.3 &#x3D;&gt; DataFrame</p></li><li><p>Spark1.6 &#x3D;&gt; Dataset</p></li></ul><p>如果同样的数据都给到这三个数据结构，他们分别计算之后，都会给出相同的结果。不同是的他们的执行效率和执行方式。在后期的Spark版本中，DataSet有可能会逐步取代RDD和DataFrame成为唯一的API接口。</p><h4 id="2-4-1-三者的共性"><a href="#2-4-1-三者的共性" class="headerlink" title="2.4.1 三者的共性"></a>2.4.1 三者的共性</h4><ul><li><p>RDD、DataFrame、DataSet全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利;</p></li><li><p>三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach时，三者才会开始遍历运算;</p></li><li><p>三者有许多共同的函数，如filter，排序等;</p></li><li><p>在对DataFrame和Dataset进行操作许多操作都需要这个包:import spark.implicits._（在创建好SparkSession对象后尽量直接导入）</p></li><li><p>三者都会根据 Spark 的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出</p></li><li><p>三者都有partition的概念</p></li><li><p>DataFrame和DataSet均可使用模式匹配获取各个字段的值和类型</p></li></ul><h4 id="2-4-2-三者的区别"><a href="#2-4-2-三者的区别" class="headerlink" title="2.4.2 三者的区别"></a>2.4.2 三者的区别</h4><ol><li><p>RDD</p><ul><li><p>RDD一般和spark mllib同时使用</p></li><li><p>RDD不支持sparksql操作</p></li></ul></li><li><p>DataFrame</p><ul><li><p>与RDD和Dataset不同，DataFrame每一行的类型固定为Row，每一列的值没法直接访问，只有通过解析才能获取各个字段的值</p></li><li><p>DataFrame与DataSet一般不与 spark mllib 同时使用</p></li><li><p>DataFrame与DataSet均支持 SparkSQL 的操作，比如select，groupby之类，还能注册临时表&#x2F;视窗，进行 sql 语句操作</p></li><li><p>DataFrame与DataSet支持一些特别方便的保存方式，比如保存成csv，可以带上表头，这样每一列的字段名一目了然(后面专门讲解)</p></li></ul></li><li><p>DataSet</p><ul><li><p>Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同。 DataFrame其实就是DataSet的一个特例  type DataFrame &#x3D; Dataset[Row]</p></li><li><p>DataFrame也可以叫Dataset[Row],每一行的类型是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用上面提到的getAS方法或者共性中的第七条提到的模式匹配拿出特定字段。而Dataset中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息</p></li></ul></li></ol><h4 id="2-4-3-三者的互相转换"><a href="#2-4-3-三者的互相转换" class="headerlink" title="2.4.3 三者的互相转换"></a>2.4.3 三者的互相转换</h4><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662866376395.png" alt="1662866376395"></p><h3 id="2-5-IDEA开发SparkSQL"><a href="#2-5-IDEA开发SparkSQL" class="headerlink" title="2.5 IDEA开发SparkSQL"></a>2.5 IDEA开发SparkSQL</h3><p>实际开发中，大部分都是使用IDEA进行开发</p><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-sql_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SparkSQL01_Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建上下文环境配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;SparkSQL01_Demo&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SparkSession对象</span></span><br><span class="line">    <span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span>.builder().config(conf).getOrCreate()</span><br><span class="line">    <span class="comment">//RDD=&gt;DataFrame=&gt;DataSet转换需要引入隐式转换规则，否则无法转换</span></span><br><span class="line">    <span class="comment">//spark不是包名，是上下文环境对象名</span></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取json文件 创建DataFrame  &#123;&quot;username&quot;: &quot;lisi&quot;,&quot;age&quot;: 18&#125;</span></span><br><span class="line">    <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.json(<span class="string">&quot;input/test.json&quot;</span>)</span><br><span class="line">    <span class="comment">//df.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SQL风格语法</span></span><br><span class="line">    df.createOrReplaceTempView(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    <span class="comment">//spark.sql(&quot;select avg(age) from user&quot;).show</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DSL风格语法</span></span><br><span class="line">    <span class="comment">//df.select(&quot;username&quot;,&quot;age&quot;).show()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****RDD=&gt;DataFrame=&gt;DataSet*****</span></span><br><span class="line">    <span class="comment">//RDD</span></span><br><span class="line">    <span class="keyword">val</span> rdd1: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>)] = spark.sparkContext.makeRDD(<span class="type">List</span>((<span class="number">1</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>),(<span class="number">2</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>),(<span class="number">3</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="number">20</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DataFrame</span></span><br><span class="line">    <span class="keyword">val</span> df1: <span class="type">DataFrame</span> = rdd1.toDF(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    <span class="comment">//df1.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DateSet</span></span><br><span class="line">    <span class="keyword">val</span> ds1: <span class="type">Dataset</span>[<span class="type">User</span>] = df1.as[<span class="type">User</span>]</span><br><span class="line">    <span class="comment">//ds1.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****DataSet=&gt;DataFrame=&gt;RDD*****</span></span><br><span class="line">    <span class="comment">//DataFrame</span></span><br><span class="line">    <span class="keyword">val</span> df2: <span class="type">DataFrame</span> = ds1.toDF()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RDD  返回的RDD类型为Row，里面提供的getXXX方法可以获取字段值，类似jdbc处理结果集，但是索引从0开始</span></span><br><span class="line">    <span class="keyword">val</span> rdd2: <span class="type">RDD</span>[<span class="type">Row</span>] = df2.rdd</span><br><span class="line">    <span class="comment">//rdd2.foreach(a=&gt;println(a.getString(1)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****RDD=&gt;DataSet*****</span></span><br><span class="line">    rdd1.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (id,name,age)=&gt;<span class="type">User</span>(id,name,age)</span><br><span class="line">    &#125;.toDS()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****DataSet=&gt;=&gt;RDD*****</span></span><br><span class="line">    ds1.rdd</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">id:<span class="type">Int</span>,name:<span class="type">String</span>,age:<span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><h3 id="2-6-用户自定义函数"><a href="#2-6-用户自定义函数" class="headerlink" title="2.6 用户自定义函数"></a>2.6 用户自定义函数</h3><p>​用户可以通过spark.udf功能添加自定义函数，实现自定义功能。</p><h4 id="2-6-1-UDF"><a href="#2-6-1-UDF" class="headerlink" title="2.6.1 UDF"></a>2.6.1 UDF</h4><ol><li>创建DataFrame</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;data/user.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint， username: string]</span><br></pre></td></tr></table></figure><ol start="2"><li>注册UDF</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.udf.register(<span class="string">&quot;addName&quot;</span>,(x:<span class="type">String</span>)=&gt; <span class="string">&quot;Name:&quot;</span>+x)</span><br><span class="line">res9: org.apache.spark.sql.expressions.<span class="type">UserDefinedFunction</span> = <span class="type">UserDefinedFunction</span>(&lt;function1&gt;,<span class="type">StringType</span>,<span class="type">Some</span>(<span class="type">List</span>(<span class="type">StringType</span>)))</span><br></pre></td></tr></table></figure><ol start="3"><li>创建临时表</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>应用UDF</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.sql(<span class="string">&quot;Select addName(name),age from people&quot;</span>).show()</span><br></pre></td></tr></table></figure><h4 id="2-6-2-UDAF"><a href="#2-6-2-UDAF" class="headerlink" title="2.6.2 UDAF"></a>2.6.2 UDAF</h4><p>​强类型的Dataset和弱类型的DataFrame都提供了相关的聚合函数， 如 count()，countDistinct()，avg()，max()，min()。除此之外，用户可以设定自己的自定义聚合函数。通过继承UserDefinedAggregateFunction来实现用户自定义弱类型聚合函数。从Spark3.0版本后，UserDefinedAggregateFunction已经不推荐使用了。可以统一采用强类型聚合函数Aggregator</p><hr><p><strong>需求：计算平均工资</strong></p><p><strong>实现方式1-RDD</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;app&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="keyword">val</span> res: (<span class="type">Int</span>, <span class="type">Int</span>) = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>), (<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>), (<span class="string">&quot;wangw&quot;</span>, <span class="number">40</span>))).map &#123;</span><br><span class="line">  <span class="keyword">case</span> (name, age) =&gt; &#123;</span><br><span class="line">    (age, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.reduce &#123;</span><br><span class="line">  (t1, t2) =&gt; &#123;</span><br><span class="line">    (t1._1 + t2._1, t1._2 + t2._2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(res._1/res._2)</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure><p><strong>实现方式2-累加器</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAC</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">Int</span>,<span class="type">Int</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> count:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> sum ==<span class="number">0</span> &amp;&amp; count == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">Int</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> newMyAc = <span class="keyword">new</span> <span class="type">MyAC</span></span><br><span class="line">    newMyAc.sum = <span class="keyword">this</span>.sum</span><br><span class="line">    newMyAc.count = <span class="keyword">this</span>.count</span><br><span class="line">    newMyAc</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sum =<span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    sum += v</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">Int</span>, <span class="type">Int</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    other <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> o:<span class="type">MyAC</span>=&gt;&#123;</span><br><span class="line">        sum += o.sum</span><br><span class="line">        count += o.count</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> _=&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Int</span> = sum/count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现方式3-UDAF-弱类型</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义类继承UserDefinedAggregateFunction，并重写其中方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAveragUDAF</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 聚合函数输入参数的数据类型</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">Array</span>(<span class="type">StructField</span>(<span class="string">&quot;age&quot;</span>,<span class="type">IntegerType</span>)))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 聚合函数缓冲区中值的数据类型(age,count)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="type">StructType</span>(<span class="type">Array</span>(<span class="type">StructField</span>(<span class="string">&quot;sum&quot;</span>,<span class="type">LongType</span>),<span class="type">StructField</span>(<span class="string">&quot;count&quot;</span>,<span class="type">LongType</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数返回值的数据类型</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 稳定性：对于相同的输入是否一直返回相同的输出。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数缓冲区初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 存年龄的总和</span></span><br><span class="line">    buffer(<span class="number">0</span>) = <span class="number">0</span>L</span><br><span class="line">    <span class="comment">// 存年龄的个数</span></span><br><span class="line">    buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新缓冲区中的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>,input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!input.isNullAt(<span class="number">0</span>)) &#123;</span><br><span class="line">      buffer(<span class="number">0</span>) = buffer.getLong(<span class="number">0</span>) + input.getInt(<span class="number">0</span>)</span><br><span class="line">      buffer(<span class="number">1</span>) = buffer.getLong(<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并缓冲区</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>,buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    buffer1(<span class="number">0</span>) = buffer1.getLong(<span class="number">0</span>) + buffer2.getLong(<span class="number">0</span>)</span><br><span class="line">    buffer1(<span class="number">1</span>) = buffer1.getLong(<span class="number">1</span>) + buffer2.getLong(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算最终结果</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Double</span> = buffer.getLong(<span class="number">0</span>).toDouble / buffer.getLong(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建聚合函数</span></span><br><span class="line"><span class="keyword">var</span> myAverage = <span class="keyword">new</span> <span class="type">MyAveragUDAF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在spark中注册聚合函数</span></span><br><span class="line">spark.udf.register(<span class="string">&quot;avgAge&quot;</span>,myAverage)</span><br><span class="line"></span><br><span class="line">spark.sql(<span class="string">&quot;select avgAge(age) from user&quot;</span>).show()</span><br></pre></td></tr></table></figure><p><strong>实现类型4-UDAF-强类型</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入数据类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User01</span>(<span class="params">username:<span class="type">String</span>,age:<span class="type">Long</span></span>)</span></span><br><span class="line"><span class="comment">//缓存类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeBuffer</span>(<span class="params">var sum:<span class="type">Long</span>,var count:<span class="type">Long</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义类继承org.apache.spark.sql.expressions.Aggregator</span></span><br><span class="line"><span class="comment">  * 重写类中的方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAveragUDAF1</span> <span class="keyword">extends</span> <span class="title">Aggregator</span>[<span class="type">User01</span>,<span class="type">AgeBuffer</span>,<span class="type">Double</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">AgeBuffer</span> = &#123;</span><br><span class="line">    <span class="type">AgeBuffer</span>(<span class="number">0</span>L,<span class="number">0</span>L)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(b: <span class="type">AgeBuffer</span>, a: <span class="type">User01</span>): <span class="type">AgeBuffer</span> = &#123;</span><br><span class="line">    b.sum = b.sum + a.age</span><br><span class="line">    b.count = b.count + <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(b1: <span class="type">AgeBuffer</span>, b2: <span class="type">AgeBuffer</span>): <span class="type">AgeBuffer</span> = &#123;</span><br><span class="line">    b1.sum = b1.sum + b2.sum</span><br><span class="line">    b1.count = b1.count + b2.count</span><br><span class="line">    b1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">finish</span></span>(buff: <span class="type">AgeBuffer</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">    buff.sum.toDouble/buff.count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//DataSet默认额编解码器，用于序列化，固定写法</span></span><br><span class="line">  <span class="comment">//自定义类型就是product自带类型根据类型选择</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">AgeBuffer</span>] = &#123;</span><br><span class="line">    <span class="type">Encoders</span>.product</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">    <span class="type">Encoders</span>.scalaDouble</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装为DataSet</span></span><br><span class="line"><span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">User01</span>] = df.as[<span class="type">User01</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建聚合函数</span></span><br><span class="line"><span class="keyword">var</span> myAgeUdaf1 = <span class="keyword">new</span> <span class="type">MyAveragUDAF1</span></span><br><span class="line"><span class="comment">//将聚合函数转换为查询的列</span></span><br><span class="line"><span class="keyword">val</span> col: <span class="type">TypedColumn</span>[<span class="type">User01</span>, <span class="type">Double</span>] = myAgeUdaf1.toColumn</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line">ds.select(col).show()</span><br></pre></td></tr></table></figure><p><strong>Spark3.0版本可以采用强类型的Aggregate方式代替UserDefinedAggregateFunction</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 创建UDAF函数</span></span><br><span class="line"><span class="keyword">val</span> udaf = <span class="keyword">new</span> <span class="type">MyAvgAgeUDAF</span></span><br><span class="line"><span class="comment">// TODO 注册到SparkSQL中</span></span><br><span class="line">spark.udf.register(<span class="string">&quot;avgAge&quot;</span>, functions.udaf(udaf))</span><br><span class="line"><span class="comment">// TODO 在SQL中使用聚合函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户的自定义聚合函数</span></span><br><span class="line">spark.sql(<span class="string">&quot;select avgAge(age) from user&quot;</span>).show</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Buff</span>(<span class="params"> var sum:<span class="type">Long</span>, var cnt:<span class="type">Long</span> </span>)</span></span><br><span class="line"><span class="comment">// totalage, count</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAvgAgeUDAF</span> <span class="keyword">extends</span> <span class="title">Aggregator</span>[<span class="type">Long</span>, <span class="type">Buff</span>, <span class="type">Double</span>]</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">Buff</span> = <span class="type">Buff</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(b: <span class="type">Buff</span>, a: <span class="type">Long</span>): <span class="type">Buff</span> = &#123;</span><br><span class="line">        b.sum += a</span><br><span class="line">        b.cnt += <span class="number">1</span></span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(b1: <span class="type">Buff</span>, b2: <span class="type">Buff</span>): <span class="type">Buff</span> = &#123;</span><br><span class="line">        b1.sum += b2.sum</span><br><span class="line">        b1.cnt += b2.cnt</span><br><span class="line">        b1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">finish</span></span>(reduction: <span class="type">Buff</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">        reduction.sum.toDouble/reduction.cnt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Buff</span>] = <span class="type">Encoders</span>.product</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Double</span>] = <span class="type">Encoders</span>.scalaDouble</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-通用的加载和保存方式"><a href="#2-7-通用的加载和保存方式" class="headerlink" title="2.7 通用的加载和保存方式"></a>2.7 通用的加载和保存方式</h3><p>​SparkSQL提供了通用的保存数据和数据加载的方式。这里的通用指的是使用相同的API，根据不同的参数读取和保存不同格式的数据，SparkSQL默认读取和保存的文件格式为parquet</p><h4 id="2-7-1-通用的加载和保存方式"><a href="#2-7-1-通用的加载和保存方式" class="headerlink" title="2.7.1 通用的加载和保存方式"></a>2.7.1 通用的加载和保存方式</h4><p>​SparkSQL提供了通用的保存数据和数据加载的方式。这里的通用指的是使用相同的API，根据不同的参数读取和保存不同格式的数据，SparkSQL默认读取和保存的文件格式为parquet</p><p><strong>加载数据</strong></p><p>spark.read.load 是加载数据的通用方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.read.</span><br><span class="line"></span><br><span class="line">csv   format   jdbc   json   load   option   options   orc   parquet   schema   table   text   textFile</span><br></pre></td></tr></table></figure><p>如果读取不同格式的数据，可以对不同的数据格式进行设定</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.read.format(<span class="string">&quot;…&quot;</span>)[.option(<span class="string">&quot;…&quot;</span>)].load(<span class="string">&quot;…&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>format(“…”)：指定加载的数据类型，包括”csv”、”jdbc”、”json”、”orc”、”parquet”和”textFile”。</p></li><li><p>load(“…”)：在”csv”、”jdbc”、”json”、”orc”、”parquet”和”textFile”格式下需要传入加载数据的路径。</p></li><li><p>option(“…”)：在”jdbc”格式下需要传入JDBC相应参数，url、user、password和dbtable</p></li></ul><p>我们前面都是使用read API 先把文件加载到 DataFrame然后再查询，其实，我们也可以直接在文件上进行查询:  <strong>文件格式.`文件路径&#96;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;spark.sql(&quot;select * from json.`/opt/module/data/user.json`&quot;).show</span><br></pre></td></tr></table></figure><p><strong>保存数据</strong></p><p>df.write.save 是保存数据的通用方法</p><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662868131920.png" alt="1662868131920"></p><p>如果保存不同格式的数据，可以对不同的数据格式进行设定</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;df.write.format(<span class="string">&quot;…&quot;</span>)[.option(<span class="string">&quot;…&quot;</span>)].save(<span class="string">&quot;…&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>format(“…”)：指定保存的数据类型，包括”csv”、”jdbc”、”json”、”orc”、”parquet”和”textFile”。</p></li><li><p>save (“…”)：在”csv”、”orc”、”parquet”和”textFile”格式下需要传入保存数据的路径。</p></li><li><p>option(“…”)：在”jdbc”格式下需要传入JDBC相应参数，url、user、password和dbtable</p></li></ul><p>保存操作可以使用 SaveMode, 用来指明如何处理数据，使用mode()方法来设置。</p><p>有一点很重要: 这些 SaveMode 都是没有加锁的, 也不是原子操作。</p><p>SaveMode是一个枚举类，其中的常量包括：</p><table><thead><tr><th>Scala&#x2F;Java</th><th>Any Language</th><th>Meaning</th></tr></thead><tbody><tr><td>SaveMode.ErrorIfExists(default)</td><td>“error”(default)</td><td>如果文件已经存在则抛出异常</td></tr><tr><td>SaveMode.Append</td><td>“append”</td><td>如果文件已经存在则追加</td></tr><tr><td>SaveMode.Overwrite</td><td>“overwrite”</td><td>如果文件已经存在则覆盖</td></tr><tr><td>SaveMode.Ignore</td><td>“ignore”</td><td>如果文件已经存在则忽略</td></tr></tbody></table><p>例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.write.mode(<span class="string">&quot;append&quot;</span>).json(<span class="string">&quot;/opt/module/data/output&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-7-2-Parquet"><a href="#2-7-2-Parquet" class="headerlink" title="2.7.2 Parquet"></a>2.7.2 Parquet</h4><p>​Spark SQL的默认数据源为Parquet格式。Parquet是一种能够有效存储嵌套数据的列式存储格式。</p><p>​数据源为Parquet文件时，Spark SQL可以方便的执行所有的操作，不需要使用format。修改配置项spark.sql.sources.default，可修改默认数据源格式。</p><p><strong>加载数据</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.load(<span class="string">&quot;examples/src/main/resources/users.parquet&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br></pre></td></tr></table></figure><p><strong>保存数据</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> df = spark.read.json(<span class="string">&quot;/opt/module/data/input/people.json&quot;</span>)</span><br><span class="line"><span class="comment">//保存为parquet格式</span></span><br><span class="line">scala&gt; df.write.mode(<span class="string">&quot;append&quot;</span>).save(<span class="string">&quot;/opt/module/data/output&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-7-3-JSON"><a href="#2-7-3-JSON" class="headerlink" title="2.7.3 JSON"></a>2.7.3 JSON</h4><p>​Spark SQL 能够自动推测JSON数据集的结构，并将它加载为一个Dataset[Row]. 可以通过SparkSession.read.json()去加载JSON 文件。</p><p>​注意：Spark读取的JSON文件不是传统的JSON文件，每一行都应该是一个JSON串。格式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Michael&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Andy&quot;</span>， <span class="string">&quot;age&quot;</span>:<span class="number">30</span>&#125;</span><br><span class="line">[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Justin&quot;</span>， <span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Justin&quot;</span>， <span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;]</span><br></pre></td></tr></table></figure><ol><li>导入隐式转换</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br></pre></td></tr></table></figure><ol start="2"><li>加载JSON文件</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> path = <span class="string">&quot;/opt/module/spark-local/people.json&quot;</span></span><br><span class="line"><span class="keyword">val</span> peopleDF = spark.read.json(path)</span><br></pre></td></tr></table></figure><ol start="3"><li>创建临时表</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peopleDF.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>数据查询</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> teenagerNamesDF = spark.sql(<span class="string">&quot;SELECT name FROM people WHERE age BETWEEN 13 AND 19&quot;</span>)</span><br><span class="line">teenagerNamesDF.show()</span><br><span class="line">+------+</span><br><span class="line">|  name|</span><br><span class="line">+------+</span><br><span class="line">|<span class="type">Justin</span>|</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><h4 id="2-7-4-CSV"><a href="#2-7-4-CSV" class="headerlink" title="2.7.4 CSV"></a>2.7.4 CSV</h4><p>Spark SQL可以配置CSV文件的列表信息，读取CSV文件,CSV文件的第一行设置为数据列</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.read.format(<span class="string">&quot;csv&quot;</span>).option(<span class="string">&quot;sep&quot;</span>, <span class="string">&quot;;&quot;</span>).option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>).option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>).load(<span class="string">&quot;data/user.csv&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-7-5-MySQL"><a href="#2-7-5-MySQL" class="headerlink" title="2.7.5 MySQL"></a>2.7.5 MySQL</h4><p>​Spark SQL可以通过JDBC从关系型数据库中读取数据的方式创建DataFrame，通过对DataFrame一系列的计算后，还可以将数据再写回关系型数据库中。如果使用spark-shell操作，可在启动shell时指定相关的数据库驱动路径或者将相关的数据库驱动放到spark的类路径下。</p><p><strong>读取数据</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;SparkSQL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SparkSession对象</span></span><br><span class="line"><span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span>.builder().config(conf).getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1：通用的load方法读取</span></span><br><span class="line">spark.read.format(<span class="string">&quot;jdbc&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;jdbc:mysql://linux1:3306/spark-sql&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;driver&quot;</span>, <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123123&quot;</span>)</span><br><span class="line">  .option(<span class="string">&quot;dbtable&quot;</span>, <span class="string">&quot;user&quot;</span>)</span><br><span class="line">  .load().show</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2:通用的load方法读取 参数另一种形式</span></span><br><span class="line">spark.read.format(<span class="string">&quot;jdbc&quot;</span>)</span><br><span class="line">  .options(<span class="type">Map</span>(<span class="string">&quot;url&quot;</span>-&gt;<span class="string">&quot;jdbc:mysql://linux1:3306/spark-sql?user=root&amp;password=123123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dbtable&quot;</span>-&gt;<span class="string">&quot;user&quot;</span>,<span class="string">&quot;driver&quot;</span>-&gt;<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)).load().show</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3:使用jdbc方法读取</span></span><br><span class="line"><span class="keyword">val</span> props: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">props.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">props.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123123&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.jdbc(<span class="string">&quot;jdbc:mysql://linux1:3306/spark-sql&quot;</span>, <span class="string">&quot;user&quot;</span>, props)</span><br><span class="line">df.show</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">spark.stop()</span><br></pre></td></tr></table></figure><p><strong>写入数据</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">。。。</span><br><span class="line"><span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;SparkSQL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SparkSession对象</span></span><br><span class="line"><span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span>.builder().config(conf).getOrCreate()</span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">User2</span>] = spark.sparkContext.makeRDD(<span class="type">List</span>(<span class="type">User2</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>), <span class="type">User2</span>(<span class="string">&quot;zs&quot;</span>, <span class="number">30</span>)))</span><br><span class="line"><span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">User2</span>] = rdd.toDS</span><br><span class="line"><span class="comment">//方式1：通用的方式  format指定写出类型</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//方式2：通过jdbc方法</span></span><br><span class="line"><span class="keyword">val</span> props: <span class="type">Properties</span> = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">props.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">props.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123123&quot;</span>)</span><br><span class="line">ds.write.mode(<span class="type">SaveMode</span>.<span class="type">Append</span>).jdbc(<span class="string">&quot;jdbc:mysql://linux1:3306/spark-sql&quot;</span>, <span class="string">&quot;user&quot;</span>, props)</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">spark.stop()</span><br></pre></td></tr></table></figure><h4 id="2-7-6-Hive"><a href="#2-7-6-Hive" class="headerlink" title="2.7.6 Hive"></a>2.7.6 Hive</h4><p>​Apache Hive 是 Hadoop 上的 SQL 引擎，Spark SQL编译时可以包含 Hive 支持，也可以不包含。包含 Hive 支持的 Spark SQL 可以支持 Hive 表访问、UDF (用户自定义函数)以及 Hive 查询语言(HiveQL&#x2F;HQL)等。需要强调的一点是，如果要在 Spark SQL 中包含Hive 的库，并不需要事先安装 Hive。一般来说，最好还是在编译Spark SQL时引入Hive支持，这样就可以使用这些特性了。如果你下载的是二进制版本的 Spark，它应该已经在编译时添加了 Hive 支持。</p><p>​若要把 Spark SQL 连接到一个部署好的 Hive 上，你必须把 hive-site.xml 复制到 Spark的配置文件目录中($SPARK_HOME&#x2F;conf)。即使没有部署好 Hive，Spark SQL 也可以运行。 需要注意的是，如果你没有部署好Hive，Spark SQL 会在当前的工作目录中创建出自己的 Hive 元数据仓库，叫作 metastore_db。此外，如果你尝试使用 HiveQL 中的 CREATE TABLE (并非 CREATE EXTERNAL TABLE)语句来创建表，这些表会被放在你默认的文件系统中的 &#x2F;user&#x2F;hive&#x2F;warehouse 目录中(如果你的 classpath 中有配好的 hdfs-site.xml，默认的文件系统就是 HDFS，否则就是本地文件系统)。</p><p>​<strong>spark-shell默认是Hive支持的；代码中是默认不支持的，需要手动指定（加一个参数即可）。</strong></p><p><strong>内嵌的HIVE</strong></p><p>如果使用 Spark 内嵌的 Hive, 则什么都不用做, 直接使用即可.</p><p>Hive 的元数据存储在 derby 中, 默认仓库地址:$SPARK_HOME&#x2F;spark-warehouse</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.sql(<span class="string">&quot;show tables&quot;</span>).show</span><br><span class="line">。。。</span><br><span class="line">+--------+---------+-----------+</span><br><span class="line">|database|tableName|isTemporary|</span><br><span class="line">+--------+---------+-----------+</span><br><span class="line">+--------+---------+-----------+</span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;create table aa(id int)&quot;</span>)</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;show tables&quot;</span>).show</span><br><span class="line">+--------+---------+-----------+</span><br><span class="line">|database|tableName|isTemporary|</span><br><span class="line">+--------+---------+-----------+</span><br><span class="line">| <span class="keyword">default</span>|       aa|      <span class="literal">false</span>|</span><br><span class="line">+--------+---------+-----------+</span><br></pre></td></tr></table></figure><p>向表加载本地数据</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.sql(<span class="string">&quot;load data local inpath &#x27;input/ids.txt&#x27; into table aa&quot;</span>)</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select * from aa&quot;</span>).show</span><br><span class="line">+---+</span><br><span class="line">| id|</span><br><span class="line">+---+</span><br><span class="line">|  <span class="number">1</span>|</span><br><span class="line">|  <span class="number">2</span>|</span><br><span class="line">|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">4</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure><p>在实际使用中, 几乎没有任何人会使用内置的 Hive</p><p><strong>外部的HIVE</strong></p><p>如果想连接外部已经部署好的Hive，需要通过以下几个步骤：</p><ul><li><p>Spark要接管Hive需要把hive-site.xml拷贝到conf&#x2F;目录下</p></li><li><p>把Mysql的驱动copy到jars&#x2F;目录下</p></li><li><p>如果访问不到hdfs，则需要把core-site.xml和hdfs-site.xml拷贝到conf&#x2F;目录下</p></li><li><p>重启spark-shell</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.sql(<span class="string">&quot;show tables&quot;</span>).show</span><br><span class="line"><span class="number">20</span>/<span class="number">04</span>/<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">14</span> <span class="type">WARN</span> <span class="type">ObjectStore</span>: <span class="type">Failed</span> to get database global_temp, returning <span class="type">NoSuchObjectException</span></span><br><span class="line">+--------+--------------------+-----------+</span><br><span class="line">|database|           tableName|isTemporary|</span><br><span class="line">+--------+--------------------+-----------+</span><br><span class="line">| <span class="keyword">default</span>|                 emp|      <span class="literal">false</span>|</span><br><span class="line">| <span class="keyword">default</span>|hive_hbase_emp_table|      <span class="literal">false</span>|</span><br><span class="line">| <span class="keyword">default</span>| relevance_hbase_emp|      <span class="literal">false</span>|</span><br><span class="line">| <span class="keyword">default</span>|          staff_hive|      <span class="literal">false</span>|</span><br><span class="line">| <span class="keyword">default</span>|                 ttt|      <span class="literal">false</span>|</span><br><span class="line">| <span class="keyword">default</span>|   user_visit_action|      <span class="literal">false</span>|</span><br><span class="line">+--------+--------------------+-----------+</span><br></pre></td></tr></table></figure><p><strong>运行Spark SQL CLI</strong></p><p>Spark SQL CLI可以很方便的在本地运行Hive元数据服务以及从命令行执行查询任务。在Spark目录下执行如下命令启动Spark SQL CLI，直接执行SQL语句，类似一Hive窗口</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-sql</span><br></pre></td></tr></table></figure><p><strong>运行Spark beeline</strong></p><p>​Spark Thrift Server是Spark社区基于HiveServer2实现的一个Thrift服务。旨在无缝兼容HiveServer2。因为Spark Thrift Server的接口和协议都和HiveServer2完全一致，因此我们部署好Spark Thrift Server后，可以直接使用hive的beeline访问Spark Thrift Server执行相关语句。Spark Thrift Server的目的也只是取代HiveServer2，因此它依旧可以和Hive Metastore进行交互，获取到hive的元数据。</p><p>如果想连接Thrift Server，需要通过以下几个步骤：</p><ul><li><p>Spark要接管Hive需要把hive-site.xml拷贝到conf&#x2F;目录下</p></li><li><p>把Mysql的驱动copy到jars&#x2F;目录下</p></li><li><p>如果访问不到hdfs，则需要把core-site.xml和hdfs-site.xml拷贝到conf&#x2F;目录下</p></li><li><p>启动Thrift Server</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-thriftserver.sh</span><br></pre></td></tr></table></figure><ul><li>使用beeline连接Thrift Server</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/beeline -u jdbc:hive2:<span class="comment">//linux1:10000 -n root</span></span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/Spark/SparkSQL%E6%A6%82%E8%BF%B0/1662869199558.png" alt="1662869199558"></p><p><strong>代码操作Hive</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-hive_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将hive-site.xml文件拷贝到项目的resources目录中，代码实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SparkSession</span></span><br><span class="line"><span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span></span><br><span class="line">  .builder()</span><br><span class="line">  .enableHiveSupport()</span><br><span class="line">  .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">  .appName(<span class="string">&quot;sql&quot;</span>)</span><br><span class="line">  .getOrCreate()</span><br></pre></td></tr></table></figure><p>注意：在开发工具中创建数据库默认是在本地仓库，通过参数修改数据库仓库的地址: </p><p>config(“spark.sql.warehouse.dir”,<br>“hdfs:&#x2F;&#x2F;linux1:8020&#x2F;user&#x2F;hive&#x2F;warehouse”)</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark SQl </tag>
            
            <tag> DataFrame </tag>
            
            <tag> DateSet </tag>
            
            <tag> Hive on Spark </tag>
            
            <tag> 自定义UDAF </tag>
            
            <tag> Spark session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本知识点介绍</title>
      <link href="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java基础知识点整理</p><h3 id="1-Java八大基础数据类型"><a href="#1-Java八大基础数据类型" class="headerlink" title="1.Java八大基础数据类型"></a>1.Java八大基础数据类型</h3><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248985772.png" alt="1657248985772"></p><p>1、整型系列</p><p>（1）byte：字节类型</p><p>占内存：1个字节</p><p>存储范围：-128~127</p><p>（2）short：短整型类型</p><p>占内存：2个字节</p><p>存储范围：-32768~32767</p><p>（3）int：整型</p><p>占内存：4个字节</p><p>存储范围：-2的31次方 ~ 2的31次方-1</p><p>（4）long：整型</p><p>占内存：8个字节</p><p>存储范围：-2的63次方 ~ 2的63次方-1</p><blockquote><p>注意：如果要表示某个常量数字它是long类型，那么需要在数字后面加L</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//右边的整数必须在-128~127范围内</span></span><br><span class="line"><span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1234567</span>; <span class="comment">//右边的整数如果在int范围呢，编译和运行都可以通过</span></span><br><span class="line"><span class="type">long</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="number">12345678912L</span>;<span class="comment">//右边的整数如果超过int范围，必须加L，否则编译不通过</span></span><br></pre></td></tr></table></figure><p>2、浮点型系列（小数）</p><p>（1）float：单精度浮点型</p><p>占内存：4个字节</p><p>精度：科学记数法的小数点后6~7位</p><blockquote><p>注意：如果要表示某个常量数字是float类型，那么需要在数字后面加F或f</p></blockquote><p>（2）double：双精度浮点型</p><p>占内存：8个字节</p><p>精度：科学记数法的小数点后15~16位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">12.0F</span>;<span class="comment">//右边如果赋值小数，那么必须加F或f</span></span><br></pre></td></tr></table></figure><p>3、单字符类型</p><p>char：字符类型</p><p>占内存：2个字节</p><p>4、布尔类型</p><p>boolean：只能存储true或false</p><blockquote><p>虽然计算机底层使用0和1表示false和true，但是在代码中不能给boolean类型的变量赋值0和1，只能赋值false和true</p></blockquote><h3 id="2-为什么float-4个字节可表示数字确大于long8个字节？"><a href="#2-为什么float-4个字节可表示数字确大于long8个字节？" class="headerlink" title="2.为什么float 4个字节可表示数字确大于long8个字节？"></a>2.为什么float 4个字节可表示数字确大于long8个字节？</h3><p>因为float是使用的IEEE754标准，32位从前到后分为符号位、指数位、尾数位，使用科学计数法来表示。</p><ol><li>Sign（1位）：用来表示浮点数是正数还是负数，0表示正数，1表示负数。</li><li>Exponent（8位）：指数部分。即上文提到数字c，但是这里不是直接存储c，为了同时表示正负指数以及他们的大小顺序，这里实际存储的是c+127。</li><li>Mantissa（23位）：尾数部分。也就是上文中提到的数字b。</li></ol><p>指数部分可以表示到2的127次幂</p><h3 id="3-基本数据类型的转换"><a href="#3-基本数据类型的转换" class="headerlink" title="3.基本数据类型的转换"></a>3.基本数据类型的转换</h3><h4 id="1、自动类型转换（隐式类型转换）"><a href="#1、自动类型转换（隐式类型转换）" class="headerlink" title="1、自动类型转换（隐式类型转换）"></a>1、自动类型转换（隐式类型转换）</h4><p>自动转换可以把取值范围小的类型自动提升为取值范围大的</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657247692362.png" alt="1657247692362"></p><h4 id="2、强制类型转换（显示类型转换）"><a href="#2、强制类型转换（显示类型转换）" class="headerlink" title="2、强制类型转换（显示类型转换）"></a>2、强制类型转换（显示类型转换）</h4><p>强制类型转换就是需要把取值范围大的类型转换为取值范围小的类型。</p><p><strong>转换格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = （数据类型）被强转数据值；</span><br></pre></td></tr></table></figure><p>（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换，提示：有风险，可能会损失精度或溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">3.14</span>;<span class="comment">//强制类型转换，损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)d;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;<span class="comment">//溢出</span></span><br></pre></td></tr></table></figure><p>（2）boolean类型不参与</p><p>（3）当某个值想要提升数据类型时，也可以使用强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">shang</span> <span class="operator">=</span> (<span class="type">double</span>)i/j;</span><br></pre></td></tr></table></figure><p>提示：这个情况的强制类型转换是没有风险的。</p><h4 id="3、特殊的数据类型转换"><a href="#3、特殊的数据类型转换" class="headerlink" title="3、特殊的数据类型转换"></a>3、特殊的数据类型转换</h4><p>1、任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + <span class="number">1</span> + <span class="number">2</span>);<span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>2、但是String类型不能通过强制类型()转换，转为其他的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)str;<span class="comment">//错误的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//后面才能讲到，借助包装类的方法才能转</span></span><br></pre></td></tr></table></figure><h3 id="4-和–运算符"><a href="#4-和–运算符" class="headerlink" title="4.++和–运算符"></a>4.++和–运算符</h3><ul><li><p>和<code>其他变量放在一起使用</code>或者和<code>输出语句放在一起使用</code>，<code>前++</code>和<code>后++</code>就产生了不同。</p></li><li><p>变量<code>前++</code> ：变量先自身加1，然后再将加1后的结果进行其他使用。</p></li><li><p>变量<code>后++</code> ：变量先拿去使用，然后再自身加1。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 其他变量放在一起使用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//int y = ++x; // y的值是4，x的值是4，</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++; <span class="comment">// y的值是3，x的值是4</span></span><br><span class="line"></span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(y);</span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 和输出语句一起</span></span><br><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//System.out.println(++z);// 输出结果是6，z的值也是6</span></span><br><span class="line">System.out.println(z++);<span class="comment">// 输出结果是5，z的值是6</span></span><br><span class="line">System.out.println(z);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        a = a++;<span class="comment">//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的&quot;1&quot;赋值给a,a=1</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++ + ++i * i++;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从左往右加载</span></span><br><span class="line"><span class="comment">        (1)先算i++</span></span><br><span class="line"><span class="comment">        ①取i的值“1”放操作数栈</span></span><br><span class="line"><span class="comment">        ②i再自增 i=2</span></span><br><span class="line"><span class="comment">        （2）再算++i</span></span><br><span class="line"><span class="comment">        ①i先自增 i=3</span></span><br><span class="line"><span class="comment">        ②再取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">        （3）再算i++</span></span><br><span class="line"><span class="comment">        ①取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">        ②i再自增 i=4</span></span><br><span class="line"><span class="comment">        （4）先算乘法</span></span><br><span class="line"><span class="comment">        用操作数栈中3 * 3 = 9，并把9压会操作数栈</span></span><br><span class="line"><span class="comment">        （5）再算求和</span></span><br><span class="line"><span class="comment">        用操作数栈中的 1 + 9 = 10</span></span><br><span class="line"><span class="comment">        （6）最后算赋值</span></span><br><span class="line"><span class="comment">        j = 10</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li><strong>++在前，先自加，后使用；</strong></li><li><strong>++在后，先使用，后自加。</strong></li></ul><h3 id="5-Java的逻辑运算符（主要是之前没掌握-和-的区别）"><a href="#5-Java的逻辑运算符（主要是之前没掌握-和-的区别）" class="headerlink" title="5.Java的逻辑运算符（主要是之前没掌握|| 和| 的区别）"></a>5.Java的逻辑运算符（主要是之前没掌握|| 和| 的区别）</h3><h4 id="amp-amp-和-amp-区别，-和-区别"><a href="#amp-amp-和-amp-区别，-和-区别" class="headerlink" title="&amp;&amp;和&amp;区别，||和|区别"></a>&amp;&amp;和&amp;区别，||和|区别</h4><ul><li>**<code>&amp;&amp;</code>和<code>&amp;</code>**区别：<ul><li><code>&amp;&amp;</code>和<code>&amp;</code>结果一样，<code>&amp;&amp;</code>有短路效果，左边为false，右边不执行；<code>&amp;</code>左边无论是什么，右边都会执行。</li><li>&amp;也可以当作位运算符</li></ul></li><li>**<code>||</code>和<code>|</code>**区别：<ul><li><code>||</code>和<code>|</code>结果一样，<code>||</code>有短路效果，左边为true，右边不执行；<code>|</code>左边无论是什么，右边都会执行。</li><li>|也可以当位运算符</li></ul></li></ul><h3 id="6-Java语言的跨平台性原理"><a href="#6-Java语言的跨平台性原理" class="headerlink" title="6.Java语言的跨平台性原理"></a>6.Java语言的跨平台性原理</h3><ul><li>跨平台<strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为</strong>Java语言的跨平台特性**。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。</li><li><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境之一，也是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在<strong>JVM</strong> 之上。</li></ul><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248815395.png" alt="1657248815395"></p><p>如图所示，Java的虚拟机本身是不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p><ul><li>**JRE ** (Java Runtime Environment) ：是Java程序的运行时环境，包含<code>JVM</code> 和运行时所需要的<code>核心类库</code>。</li><li><strong>JDK</strong>  (Java Development Kit)：是Java程序开发工具包，包含<code>JRE</code> 和开发人员使用的工具。</li></ul><p>我们想要运行一个已有的Java程序，那么只需安装<code>JRE</code> 即可。</p><p>我们想要开发一个全新的Java程序，那么必须安装<code>JDK</code> ，其内部包含<code>JRE</code>。</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248854324.png" alt="1657248854324"></p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248865944.png" alt="1657248865944"></p><h3 id="7-打印arr数组输出的值是地址吗？"><a href="#7-打印arr数组输出的值是地址吗？" class="headerlink" title="7.打印arr数组输出的值是地址吗？"></a>7.打印arr数组输出的值是地址吗？</h3><p>它不是数组的地址。arr中存储的是数组的首地址，但是因为数组是引用数据类型，打印arr时，会自动调用arr数组对象的toString()方法，默认该方法实现的是对象类型名@该对象的hashCode()值的十六进制值。</p><h3 id="8-面向对象思想概述"><a href="#8-面向对象思想概述" class="headerlink" title="8.面向对象思想概述"></a>8.面向对象思想概述</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>Java语言是一种面向对象的程序设计语言，而面向对象思想（OOP）是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。<br>这里的<strong>对象</strong>泛指现实中一切事物，每种事物都具备自己的<strong>属性</strong>和<strong>行为</strong>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。<br>它区别于面向过程思想（POP），强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><h4 id="2、面向对象与面向过程的区别"><a href="#2、面向对象与面向过程的区别" class="headerlink" title="2、面向对象与面向过程的区别"></a>2、面向对象与面向过程的区别</h4><p>面向过程：POP: Process-Oriented Programming</p><p>​以函数（方法）为最小单位</p><p>​数据独立于函数之外</p><p>​以过程，步骤为主，考虑怎么做</p><p>面向对象：OOP: Object Oriented Programming</p><p>​以类&#x2F;对象为最小单位，类包括：数据+方法</p><p>​以对象（谁）为主，考虑谁来做，谁能做</p><p>面向对象仍然包含面向过程，只不过关注点变了，关注谁来做</p><p>程序员的角色：</p><p>面向过程：程序员是具体执行者</p><p>面向对象：程序员是指挥者</p><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。</p><p>例子：把大象装进冰箱</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657615405184.png" alt="1657615405184"></p><p>3、面向对象的基本特征</p><p>面向对象的语言中，包含了三大基本特征，即封装、继承和多态。</p><h3 id="9-权限修饰符"><a href="#9-权限修饰符" class="headerlink" title="9.权限修饰符"></a>9.权限修饰符</h3><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657615499914.png" alt="1657615499914"></p><h3 id="10-this、final、super关键字"><a href="#10-this、final、super关键字" class="headerlink" title="10.this、final、super关键字"></a>10.this、final、super关键字</h3><h4 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h4><p>this代表当前对象的引用（地址值），即对象自己的引用。</p><ul><li>this可以用于构造器中：表示正在创建的那个实例对象，即正在new谁，this就代表谁</li><li>this用于实例方法中：表示调用该方法的对象，即谁在调用，this就代表谁。</li></ul><h4 id="this使用格式"><a href="#this使用格式" class="headerlink" title="this使用格式"></a>this使用格式</h4><p>1、this.成员变量名</p><p>当方法的局部变量与当前对象的成员变量重名时，就可以在成员变量前面加this.，如果没有重名问题，就可以省略this.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员变量名；</span><br></pre></td></tr></table></figure><p>2、this.成员方法</p><p>调用当前对象自己的成员方法时，都可以加”this.”，也可以省略，实际开发中都省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【变量=】<span class="built_in">this</span>.成员方法(【实参列表】);</span><br></pre></td></tr></table></figure><p>3、this()或this(实参列表)</p><p>当需要调用本类的其他构造器时，就可以使用该形式。</p><p>要求：</p><p>必须在构造器的首行</p><p>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(【实参列表】)”，否则会发生递归调用死循环</p><h4 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h4><ul><li><p><strong>super</strong> ：代表父类的<strong>存储空间标识</strong>(可以理解为父亲的引用)。</p><ul><li>通过super找成员变量和成员方法时，直接从父类空间（包含父类的父类继承的）找</li><li>super()或super(实参列表)只能从直接父类找</li><li>通过super只能访问父类在子类中可见的（非private，跨包还不能是缺省的）</li></ul></li><li><p><strong>this</strong> ：代表<strong>当前对象的引用</strong>。</p><ul><li>通过this找成员变量和成员方法时，先从当前类中找，没有的会往上找父类的。</li><li>但是this()或this(实参列表)只会在本类中找</li></ul></li></ul><blockquote><p>注意：super和this都不能出现在静态方法和静态代码块中，因为super和this都是存在与<strong>对象</strong>中的</p></blockquote><h4 id="super的用法"><a href="#super的用法" class="headerlink" title="super的用法"></a>super的用法</h4><h5 id="1、super-成员变量"><a href="#1、super-成员变量" class="headerlink" title="1、super.成员变量"></a>1、super.成员变量</h5><p>在子类对象中访问父类空间的成员变量，即访问从父类继承的在子类中仍然可见的成员变量</p><h5 id="2、super-成员方法"><a href="#2、super-成员方法" class="headerlink" title="2、super.成员方法"></a>2、super.成员方法</h5><p>在子类对象中访问从父类继承的在子类中仍然可见的成员方法</p><h5 id="3、super-或super-实参列表"><a href="#3、super-或super-实参列表" class="headerlink" title="3、super()或super(实参列表)"></a>3、super()或super(实参列表)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>(...)    --    本类的构造方法</span><br><span class="line"><span class="built_in">super</span>(...)   --    父类的构造方法</span><br></pre></td></tr></table></figure><blockquote><p>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</p><p>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</p></blockquote><h4 id="final的用法"><a href="#final的用法" class="headerlink" title="final的用法"></a>final的用法</h4><p>final：最终的，不可更改的，它的用法有：</p><h5 id="1、修饰类"><a href="#1、修饰类" class="headerlink" title="1、修饰类"></a>1、修饰类</h5><p>表示这个类不能被继承，没有子类</p><h5 id="2、修饰方法"><a href="#2、修饰方法" class="headerlink" title="2、修饰方法"></a>2、修饰方法</h5><p>表示这个方法不能被子类重写</p><h5 id="3、声明常量"><a href="#3、声明常量" class="headerlink" title="3、声明常量"></a>3、声明常量</h5><p>某个变量如果使用final修饰，那么它的值就不能被修改，即常量</p><blockquote><p>final可以修饰成员变量（静态的类变量和非静态的实例变量）和局部变量</p><p>如果某个成员变量用final修饰后，没有set方法，并且必须有显式赋值语句，不能使用成员变量默认值</p><p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p></blockquote><h3 id="11-类的初始化和实例初始化"><a href="#11-类的初始化和实例初始化" class="headerlink" title="11.类的初始化和实例初始化"></a>11.类的初始化和实例初始化</h3><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>类被加载内存后，会在方法区创建一个Class对象（后面反射章节详细学习）来存储该类的所有信息。此时会为类的静态变量分配内存，然后为类变量进行初始化。那么，实际上，类初始化的过程时在调用一个<clinit>()方法，而这个方法是编译器自动生成的。编译器会将如下两部分的<strong>所有</strong>代码，<strong>按顺序</strong>合并到类初始化<clinit>()方法体中。</p><p>（1）静态类成员变量的显式赋值语句</p><p>（2）静态代码块中的语句</p><p>整个类初始化只会进行一次，如果子类初始化时，发现父类没有初始化，那么会先初始化父类。</p><p>结论：</p><p>每一个类都有一个类初始化方法<clinit>()方法，然后子类初始化时，如果发现父类加载和没有初始化，会先加载和初始化父类，然后再加载和初始化子类。一个类，只会初始化一次。</p><h4 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h4><p>实际上我们编写的代码在编译时，会自动处理代码，整理出一个<clinit>()的类初始化方法，还会整理出一个或多个的<init>(…)实例初始化方法。一个类有几个实例初始化方法，由这个类有几个构造器决定。</p><p>实例初始化方法的方法体，由四部分构成：</p><p>（1）super()或super(实参列表)    这里选择哪个，看原来构造器首行是哪句，没写，默认就是super()</p><p>（2）非静态实例变量的显示赋值语句</p><p>（3）非静态代码块</p><p>（4）对应构造器中的代码</p><p>特别说明：其中（2）和（3）是按顺序合并的，（1）一定在最前面（4）一定在最后面</p><p>执行特点：</p><ul><li>创建对象时，才会执行，</li><li>调用哪个构造器，就是指定它对应的实例初始化方法</li><li>创建子类对象时，父类对应的实例初始化会被先执行，执行父类哪个实例初始化方法，看用super()还是super(实参列表)</li></ul><p>结论：</p><p>类初始化肯定优先于实例初始化。</p><p>类初始化只做一次。</p><p>实例初始化是每次创建对象都要进行。</p><h4 id="构造器和非静态代码块"><a href="#构造器和非静态代码块" class="headerlink" title="构造器和非静态代码块"></a>构造器和非静态代码块</h4><p>从某种程度上来看，非静态代码块是对构造器的补充，非静态代码块总是在构造器执行之前执行。与构造器不同的是，非静态代码块是一段固定执行的代码，它不能接收任何参数。因此非静态代码块对同一个类的所有对象所进行的初始化处理完全相同。基于这个原因，不难发现非静态代码块的基本用法，如果有一段初始化处理代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化处理代码提取到非静态代码块中。</p><p>即如果每个构造器中有相同的初始化代码，且这些初始化代码无须接收参数，就可以把它们放在非静态代码块中定义。通过把多个构造器中相同代码提取到非静态代码块中定义，能更好地提高初始代码的复用，提高整个应用的可维护性。</p><h3 id="12、多态"><a href="#12、多态" class="headerlink" title="12、多态"></a>12、多态</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h4><p>多态是继封装、继承之后，面向对象的第三大特性。</p><p>生活中，比如求面积的功能，圆、矩形、三角形实现起来是不一样的。跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</p><h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h4><ul><li><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</li></ul><h4 id="3-前提【重点】"><a href="#3-前提【重点】" class="headerlink" title="3. 前提【重点】"></a>3. 前提【重点】</h4><ol><li>继承父类或者实现接口【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li>父类引用指向子类对象【格式体现】</li></ol><h4 id="4-多态的体现"><a href="#4-多态的体现" class="headerlink" title="4. 多态的体现"></a>4. 多态的体现</h4><p>多态体现的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类对象；</span><br><span class="line">变量名.方法名();<span class="comment">//这个方法是父类中声明，子类中重写的方法</span></span><br></pre></td></tr></table></figure><blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote><p>多态体现出来的现象：</p><p>编译时，看“父类”，只能调用父类声明的方法，不能调用子类扩展的方法；</p><p>运行时，看“子类”，一定是执行子类重写的方法体；</p><h4 id="5-多态的好处"><a href="#5-多态的好处" class="headerlink" title="5.多态的好处"></a>5.多态的好处</h4><h5 id="1、多态参数"><a href="#1、多态参数" class="headerlink" title="1、多态参数"></a>1、多态参数</h5><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：</p><p>定义父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>定义子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用showCatEat </span></span><br><span class="line">        showCatEat(c);</span><br><span class="line">        <span class="comment">// 调用showDogEat </span></span><br><span class="line">        showDogEat(d); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代</span></span><br><span class="line"><span class="comment">        而执行效果一致</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showAnimalEat(c);</span><br><span class="line">        showAnimalEat(d); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showCatEat</span> <span class="params">(Cat c)</span>&#123;</span><br><span class="line">        c.eat(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showDogEat</span> <span class="params">(Dog d)</span>&#123;</span><br><span class="line">        d.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showAnimalEat</span> <span class="params">(Animal a)</span>&#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</p><p>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</p><p>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</p><p>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p><h5 id="2、多态数组"><a href="#2、多态数组" class="headerlink" title="2、多态数组"></a>2、多态数组</h5><p>例如：家里养了两只猫，两条狗，想要统一管理他们的对象，可以使用多态数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Animal[] all = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">4</span>];<span class="comment">//可以存储各种Animal子类的对象</span></span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">all[i].eat();<span class="comment">//all[i]编译时是Animal类型，运行时看存储的是什么对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-父子类之间的转换"><a href="#6-父子类之间的转换" class="headerlink" title="6.父子类之间的转换"></a>6.父子类之间的转换</h4><p>多态的转型分为向上转型与向下转型两种：</p><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</li></ul><p>当父类引用指向一个子类对象时，便是向上转型。</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。</li></ul><p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure><h5 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h5><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p><h4 id="7-instanceof运算符"><a href="#7-instanceof运算符" class="headerlink" title="7.instanceof运算符"></a>7.instanceof运算符</h4><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。</p><p>格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量名/对象 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line"></span><br><span class="line">如果变量/对象属于该数据类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量/对象不属于该数据类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><h3 id="13-native关键字"><a href="#13-native关键字" class="headerlink" title="13.native关键字"></a>13.native关键字</h3><p>native：本地的，原生的<br>用法：</p><p>​只能修饰方法</p><p>​表示这个方法的方法体代码不是用Java语言实现的。</p><p>​但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p><p>JVM内存的管理：</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657624802173.png" alt="1657624802173"></p><p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p><p>虚拟机栈：Java语言实现的方法的局部变量</p><p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p><p>堆：new出来的对象</p><p>程序计数器：记录每一个线程目前执行到哪一句指令</p><h3 id="14-Object根父类"><a href="#14-Object根父类" class="headerlink" title="14.Object根父类"></a>14.Object根父类</h3><p>类 <code>java.lang.Object</code>是类层次结构的根类，即所有类的父类。每个类都使用 <code>Object</code> 作为超类。所有对象（包括数组）都实现这个类的方法。</p><p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="comment">/*extends Object*/</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的5个：</p><h4 id="1-public-String-toString-："><a href="#1-public-String-toString-：" class="headerlink" title="1.public String toString()："></a>1.public String toString()：</h4><p>①默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p><p>③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><h4 id="2-public-final-Class-lt-gt-getClass-：获取对象的运行时类型"><a href="#2-public-final-Class-lt-gt-getClass-：获取对象的运行时类型" class="headerlink" title="2.public final Class&lt;?&gt; getClass()：获取对象的运行时类型"></a>2.public final Class&lt;?&gt; getClass()：获取对象的运行时类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">System.out.println(obj.getClass());<span class="comment">//运行时类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-protected-void-finalize-："><a href="#3-protected-void-finalize-：" class="headerlink" title="3.protected void finalize()："></a>3.protected void finalize()：</h4><p>当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p><h4 id="4-public-int-hashCode-："><a href="#4-public-int-hashCode-：" class="headerlink" title="4.public int hashCode()："></a>4.public int hashCode()：</h4><p>返回每个对象的hash值。</p><p>规定：①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p><p>​②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p><p>主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p><h4 id="5-public-boolean-equals-Object-obj-："><a href="#5-public-boolean-equals-Object-obj-：" class="headerlink" title="5.public boolean equals(Object obj)："></a>5.public boolean equals(Object obj)：</h4><p>用于判断当前对象this与指定对象obj是否“相等”</p><p>①默认情况下，equals方法的实现等价于与“&#x3D;&#x3D;”，比较的是对象的地址值</p><p>②我们可以选择重写，重写有些要求：</p><p>A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p><p>​a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p><p>​b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p><p>​c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p><h3 id="15-为什么重写equals方法也要重写hashcode"><a href="#15-为什么重写equals方法也要重写hashcode" class="headerlink" title="15.为什么重写equals方法也要重写hashcode()"></a>15.为什么重写equals方法也要重写hashcode()</h3><p>hashcode()和equals()两个方法用来协同判断两个对象是否相等，但是重写equals时，不重写hashCode，就会导致在某些场景下，例如将两个相等的自定义<a href="https://cloud.tencent.com/product/cos?from=10680">对象存储</a>在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。</p><p>因为Set会调用hashCode方法，如果没有自定义hashCode，那么自定义的两个对象返回的code值肯定不相等，因此直接判断两个对象不相等。</p><p>调用顺序：首先使用hashcode方法，再调用equals。</p><h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16.接口"></a>16.接口</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong>，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p><p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><blockquote><p>引用数据类型：数组，类，接口。</p></blockquote><p>接口的声明格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 interface 接口名&#123;</span><br><span class="line">    <span class="comment">//接口的成员列表：</span></span><br><span class="line">    <span class="comment">// 静态常量</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">7900000</span>;<span class="comment">//这里单位是毫米/秒，7.9千米/秒，超过这个速度，就变成卫星</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">broken</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞行中遇到物体就坏了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK8之前，接口中只运行出现：</p><p>（1）公共的静态的常量：其中public static final可以省略</p><p>（2）公共的抽象的方法：其中public abstract可以省略</p><p>在JDK1.8时，接口中允许声明默认方法和静态方法：</p><p>（3）公共的默认的方法：其中public 可以省略，建议保留</p><blockquote><p>默认方法相当于允许给接口的抽象方法给出默认实现了，这样实现类（子类）既可以选择使用默认实现，还可以选择重写，更灵活了</p></blockquote><p>（4）公共的静态的方法：其中public 可以省略，建议保留</p><h4 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h4><p>为什么JDK1.8之后要允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。</p><p><strong>静态方法</strong>：因为之前的标准类库设计中，有很多Collection&#x2F;Colletions或者Path&#x2F;Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。</p><p><strong>默认方法</strong>：我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。</p><h3 id="17异常体系"><a href="#17异常体系" class="headerlink" title="17异常体系"></a>17异常体系</h3><p>异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658758135179.png" alt="1658758135179"></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。<ul><li>例如：StackOverflowError和OOM（OutOfMemoryError）。</li></ul></li><li><strong>Exception</strong>:表示异常，其它因编程错误或偶然的外在因素导致的一般性问题，程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。<ul><li>例如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界</li></ul></li></ul><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会被编译器检测到(不报错)。(如数组索引越界异常，类型转换异常)。程序员应该积极避免其出现的异常，而不是使用try..catch处理，因为这类异常很普遍，若都使用try..catch或throws处理可能会对程序的可读性和运行效率产生影响。</li></ul><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658758189730.png" alt="1658758189730"></p><h3 id="18-多线程"><a href="#18-多线程" class="headerlink" title="18.多线程"></a>18.多线程</h3><h4 id="18-1-java中多线程的创建和启动方式"><a href="#18-1-java中多线程的创建和启动方式" class="headerlink" title="18.1 java中多线程的创建和启动方式"></a>18.1 java中多线程的创建和启动方式</h4><h5 id="18-1-1-继承Thread类"><a href="#18-1-1-继承Thread类" class="headerlink" title="18.1.1 继承Thread类"></a>18.1.1 继承Thread类</h5><p>Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建自定义线程对象</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line"><span class="comment">//开启新线程</span></span><br><span class="line">mt.start();</span><br><span class="line"><span class="comment">//在主方法中执行for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="18-1-2-实现Runnable接口"><a href="#18-1-2-实现Runnable接口" class="headerlink" title="18.1.2 实现Runnable接口"></a>18.1.2 实现Runnable接口</h5><p>Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法</p><p>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li><li>调用线程对象的start()方法来启动线程。<br>代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);         </span><br><span class="line">&#125;       </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><p>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p><h5 id="18-1-3-使用匿名内部类对象来实现线程的创建和启动（常用方式）"><a href="#18-1-3-使用匿名内部类对象来实现线程的创建和启动（常用方式）" class="headerlink" title="18.1.3 使用匿名内部类对象来实现线程的创建和启动（常用方式）"></a>18.1.3 使用匿名内部类对象来实现线程的创建和启动（常用方式）</h5><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658912895136.png" alt="1658912895136"></p><p>上述两种都是使用匿名内部类启动线程。两种分别使用了不同的构造方法。</p><p>public Thread() :分配一个新的线程对象。<br>public Thread(String name) :分配一个指定名字的新的线程对象。<br>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。<br>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</p><h4 id="18-2-Thread常用方法"><a href="#18-2-Thread常用方法" class="headerlink" title="18.2 Thread常用方法"></a>18.2 Thread常用方法</h4><ul><li><p>public void run() :此线程要执行的任务在此处定义代码。</p></li><li><p>public String getName() :获取当前线程名称。</p></li><li><p>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</p></li><li><p>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </p></li><li><p>public final int getPriority() ：返回线程优先级 </p></li><li><p>public final void setPriority(int newPriority) ：改变线程的优先级</p><ul><li>每个线程都有一定的优先级，优先级高的线程将获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。Thread类提供了setPriority(int newPriority)和getPriority()方法类设置和获取线程的优先级，其中setPriority方法需要一个整数，并且范围在[1,10]之间，通常推荐设置Thread类的三个优先级常量：</li><li>MAX_PRIORITY（10）：最高优先级 </li><li>MIN _PRIORITY （1）：最低优先级</li><li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</li></ul></li><li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</p></li><li><p>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p></li><li><p>public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</p></li><li><p>void join() ：等待该线程终止。 </p><p>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </p><p>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </p></li><li><p>public final void stop()：强迫线程停止执行。 该方法具有固有的不安全性，已经标记为@Deprecated不建议再使用，那么我们就需要通过其他方式来停止线程了，其中一种方式是使用变量的值的变化来控制线程是否结束。</p></li></ul><h4 id="18-3-线程安全"><a href="#18-3-线程安全" class="headerlink" title="18.3 线程安全"></a>18.3 线程安全</h4><h5 id="18-3-1-同步代码块"><a href="#18-3-1-同步代码块" class="headerlink" title="18.3.1 同步代码块"></a>18.3.1 同步代码块</h5><ul><li><p>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步锁:<br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</li></ul><p>​锁对象 可以是任意类型。</p><p>​多个线程对象  要使用同一把锁。<br>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。<br>使用同步代码块解决代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">// 窗口永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//这里可以选择this作为锁，是因为对于这几个线程，Ticket的this是同一个 </span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">// 有票可以卖</span></span><br><span class="line">                    <span class="comment">// 出票操作</span></span><br><span class="line">                    <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Ticket</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Ticket</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">// 窗口永远开启</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Ticket.class) &#123;<span class="comment">//这里不能选用this作为锁，因为这几个线程的this不是同一个</span></span><br><span class="line"><span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票可以卖</span></span><br><span class="line">                <span class="comment">// 出票操作</span></span><br><span class="line">                <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="18-3-2-同步方法"><a href="#18-3-2-同步方法" class="headerlink" title="18.3.2 同步方法"></a>18.3.2 同步方法</h5><ul><li>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外<br>等着</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法的锁对象：</p><p>（1）静态方法：当前类的Class对象</p><p>（2）非静态方法：this</p><h5 id="18-3-3-锁机制"><a href="#18-3-3-锁机制" class="headerlink" title="18.3.3 锁机制"></a>18.3.3 锁机制</h5><h4 id="18-4等待唤醒机制"><a href="#18-4等待唤醒机制" class="headerlink" title="18.4等待唤醒机制"></a>18.4等待唤醒机制</h4><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait&#x2F;notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；</li><li>否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h4 id="18-5-线程的生命周期"><a href="#18-5-线程的生命周期" class="headerlink" title="18.5 线程的生命周期"></a>18.5 线程的生命周期</h4><p>线程有五个状态：新建、就绪、运行、阻塞、死亡。</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658929105650.png" alt="1658929105650"></p><p><strong>1.</strong> <strong>新建</strong></p><p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p><p><strong>2.</strong> <strong>就绪</strong></p><p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p><blockquote><p>注意：</p><p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p></blockquote><p><strong>3.</strong> <strong>运行</strong></p><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU，在任何时刻只有一个线程处于运行状态，如果计算机有多个处理器，将会有多个线程并行(Parallel)执行。</p><p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p><p><strong>4.</strong> <strong>阻塞</strong></p><p>当在运行过程中的线程遇到如下情况时，线程会进入阻塞状态：</p><ul><li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li><li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li><li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li><li>线程执行过程中，同步监视器调用了wait(time)</li><li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li><li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li></ul><p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p><ul><li>线程的sleep()时间到；</li><li>线程成功获得了同步监视器；</li><li>线程等到了通知(notify)；</li><li>线程wait的时间到了</li><li>加塞的线程结束了；</li><li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li></ul><p><strong>5.</strong> <strong>死亡</strong></p><p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p><ul><li>run()方法执行完成，线程正常结束</li><li>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</li><li>直接调用该线程的stop()来结束该线程（已过时，因为容易发生死锁）</li></ul><p>不过在java.lang.Thread.State的枚举类中这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先它没有区分：就绪和运行状态，因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。只能我们人为的进行想象和理解。</li><li>其次根据Thread.State的定义，阻塞状态是分为三种的：BLOCKED、WAITING、TIMED_WAITING。</li></ul><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658929292576.png" alt="1658929292576"></p><h3 id="19-thread和runnable的区别"><a href="#19-thread和runnable的区别" class="headerlink" title="19.thread和runnable的区别"></a>19.thread和runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li><li>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用<br>java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进<br>程。</li></ol><h3 id="20-wait和sleep的区别"><a href="#20-wait和sleep的区别" class="headerlink" title="20.wait和sleep的区别"></a>20.wait和sleep的区别</h3><p>（1）sleep()不释放锁，wait()释放锁（目前的理解，wait可以指定时间，一旦超过这个时间，那么这个锁对象释放，即直接变为runnable状态，不需要等到对象.notify()方法的调用，但是wait也可以不指定时间，一旦不指定时间，那么就需要等对象调用notify才能释放这个锁对象，其它线程才可以使用）</p><p>（2）sleep()指定休眠的时间，wait()可以指定时间也可以无限等待直到notify或notifyAll</p><p>（3）sleep()在Thread类中声明的静态方法，wait方法在Object类中声明</p><p>因为我们调用wait（）方法是由锁对象调用，而锁对象的类型是任意类型的对象。那么希望任意类型的对象都要有的方法，只能声明在Object类中。</p><h3 id="21-泛型"><a href="#21-泛型" class="headerlink" title="21.泛型"></a>21.泛型</h3><h4 id="21-1类型变量的上限"><a href="#21-1类型变量的上限" class="headerlink" title="21.1类型变量的上限"></a>21.1类型变量的上限</h4><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型变量  extends 上限&gt;</span><br></pre></td></tr></table></figure><p>如果有多个上限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型变量  extends 上限1 &amp; 上限2&gt;</span><br></pre></td></tr></table></figure><blockquote><p>如果多个上限中有类有接口，那么只能有一个类，而且必须写在最左边。接口的话，可以多个。</p><p>如果在声明&lt;类型变量&gt;时没有指定上限，默认上限是java.lang.Object。</p></blockquote><p>例如：我们要声明一个两个数求和的工具类，要求两个加数必须是Number数字类型，并且实现Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumTools</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span> &amp; Comparable&lt;T&gt;&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> T a;</span><br><span class="line"><span class="keyword">private</span> T b;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SumTools</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.a = a;</span><br><span class="line"><span class="built_in">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getSum</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> BigInteger)&#123;</span><br><span class="line"><span class="keyword">return</span> (T) ((BigInteger) a).add((BigInteger)b);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> BigDecimal)&#123;</span><br><span class="line"><span class="keyword">return</span> (T) ((BigDecimal) a).add((BigDecimal)b);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Short)&#123;</span><br><span class="line"><span class="keyword">return</span> (T)(Integer.valueOf((Short)a+(Short)b));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line"><span class="keyword">return</span> (T)(Integer.valueOf((Integer)a+(Integer)b));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line"><span class="keyword">return</span> (T)(Long.valueOf((Long)a+(Long)b));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Float)&#123;</span><br><span class="line"><span class="keyword">return</span> (T)(Float.valueOf((Float)a+(Float)b));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Double)&#123;</span><br><span class="line"><span class="keyword">return</span> (T)(Double.valueOf((Double)a+(Double)b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持该操作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SumTools&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">SumTools</span>&lt;Integer&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> s.getSum();</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SumTools&lt;String&gt; s = new SumTools&lt;String&gt;(&quot;1&quot;,&quot;2&quot;);//错误，因为String类型不是extends Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21-2泛型擦除"><a href="#21-2泛型擦除" class="headerlink" title="21.2泛型擦除"></a>21.2泛型擦除</h4><p>当使用参数化类型的类或接口时，如果没有指定泛型，那么会怎么样呢？</p><p>会发生泛型擦除，自动按照最左边的第一个上限处理。如果没有指定上限，上限即为Object。</p><h4 id="21-3泛型方法"><a href="#21-3泛型方法" class="headerlink" title="21.3泛型方法"></a>21.3泛型方法</h4><p>前面介绍了在定义类、接口时可以声明&lt;类型变量&gt;，在该类的方法和属性定义、接口的方法定义中，这些&lt;类型变量&gt;可被当成普通类型来用。但是，在另外一些情况下，</p><p>（1）如果我们定义类、接口时没有使用&lt;类型变量&gt;，但是某个方法定义时，想要自己定义&lt;类型变量&gt;；</p><p>（2）另外我们之前说类和接口上的类型形参是不能用于静态方法中，那么当某个静态方法想要定义&lt;类型变量&gt;。</p><p>那么，JDK1.5之后，还提供了泛型方法的支持。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 &lt;类型变量列表&gt; 返回值类型 方法名(【形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&lt;类型变量列表&gt;：可以是一个或多个类型变量，一般都是使用单个的大写字母表示。例如：<T>、&lt;K,V&gt;等。</li><li>&lt;类型变量&gt;同样也可以指定上限</li></ul><h4 id="21-4-类型通配符"><a href="#21-4-类型通配符" class="headerlink" title="21.4 类型通配符"></a>21.4 类型通配符</h4><p><strong>自己的话：就是当你声明了一个带有泛型的类，然后你定义另外一个方法的时候使用到了这个带有泛型的类作为形参，你并不知道这个方法中的形参类型是什么，因此需要使用到类型通配符  ？</strong></p><p>当我们声明一个方法时，某个形参的类型是一个参数化的泛型类或泛型接口类型，但是在声明方法时，又不确定该泛型实际类型，我们可以考虑使用类型通配符。</p><p>例如：</p><p>这个学生类是一个参数化的泛型类，代码如下（详细请看$12.2.1中的示例说明）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> T score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, T score)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T score)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 成绩：&quot;</span> + score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="21-4-1-lt-gt-任意类型"><a href="#21-4-1-lt-gt-任意类型" class="headerlink" title="21.4.1  &lt;?&gt;任意类型"></a>21.4.1  &lt;?&gt;任意类型</h5><p>例如：我们要声明一个学生管理类，这个管理类要包含一个方法，可以遍历学生数组。</p><p>学生管理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student&lt;?&gt;[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="21-4-2-lt-extends上限-gt"><a href="#21-4-2-lt-extends上限-gt" class="headerlink" title="21.4.2&lt;?extends上限&gt;"></a>21.4.2&lt;?extends上限&gt;</h5><p>例如：我们要声明一个学生管理类，这个管理类要包含一个方法，找出学生数组中成绩最高的学生对象。</p><p>要求学生的成绩的类型必须可比较大小，实现Comparable接口。</p><p>学生管理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Student&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; max(Student&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;[] arr)&#123;</span><br><span class="line">Student&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i].getScore().compareTo(max.getScore())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="21-4-3-lt-super下限-gt"><a href="#21-4-3-lt-super下限-gt" class="headerlink" title="21.4.3&lt;?super下限&gt;"></a>21.4.3&lt;?super下限&gt;</h5><p>现在要声明一个数组工具类，包含</p><p>（1）方法1：可以给任意对象数组进行从小到大排序，只要你指定定制比较器对象，而且这个定制比较器对象可以是当前数组元素类型自己或其父类的定制比较器对象</p><p>（2）方法2：可以将任意对象数组的元素拼接为一个字符串返回</p><p>数组工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrays</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">toString</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">str += <span class="string">&quot;[&quot;</span> + arr[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">str += arr[i] + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">str += arr[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c.compare(arr[j], arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：有如下JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(name, age);</span><br><span class="line"><span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;,score=&quot;</span> + score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Student[] all = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">89</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">99</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">25</span>, <span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">MyArrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(MyArrays.toString(all));</span><br><span class="line"></span><br><span class="line">MyArrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.getScore() - o2.getScore();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(MyArrays.toString(all));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="21-4-4-总结"><a href="#21-4-4-总结" class="headerlink" title="21.4.4 总结"></a>21.4.4 总结</h5><p><strong>下限就是需要你添加 该类型或者该类型的父类</strong></p><p><strong>上限就是需要你添加 该类型或者该类型的子类</strong></p><h3 id="22-集合的分类"><a href="#22-集合的分类" class="headerlink" title="22.集合的分类"></a>22.集合的分类</h3><p>集合主要分为两大类型，Collection和Map，Collection表示一组对象，Map表示一组键值对</p><ul><li>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 <ul><li>List：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li><li>Queue：队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。</li><li>Set：一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。 </li><li>SortedSet进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</li></ul></li><li>Map：将键映射到值(key,value)的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</li></ul><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658937189929.png" alt="1658937189929"></p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658937211603.png" alt="1658937211603"></p><h3 id="23-Iterator和Iterable的区别"><a href="#23-Iterator和Iterable的区别" class="headerlink" title="23.Iterator和Iterable的区别"></a>23.Iterator和Iterable的区别</h3><p>Iterable主要是对于Iterator做了一层封装，里面包含了Iterable，定义了一个forEach函数，用于实现其子类集合的增强for循环</p><p>Iterator是迭代器接口，实现此接口的实例可以对元素集合进行迭代遍历，而Iterable是为了只要实现该接口就可以使用foreach进行迭代<br>Iterable中封装了Iterator接口，只要实现了Iterable接口的类，就可以使用Iterator迭代器了。<br>集合Collection、List、Set都是Iterable的实现类，所以他们及其他们的子类都可以使用foreach进行迭代。<br>Iterator中和核心的方法next(),hasnext(),remove(),都是依赖当前位置，如果这些集合直接实现Iterator，则必须包括当前迭代位置的指针。当集合在方法间进行传递的时候，由于当前位置不可知，所以next()之后的值，也不可知。而当实现Iterable则不然，每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响<br><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658937169590.png" alt="1658937169590"></p><h3 id="24-List集合"><a href="#24-List集合" class="headerlink" title="24.List集合"></a>24.List集合</h3><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><p>ArrayList与Vector的区别？</p><p>它们的底层物理结构都是数组，我们称为动态数组。</p><ul><li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li><li>动态数组的扩容机制不同，ArrayList扩容为原来的1.5倍，Vector扩容增加为原来的2倍。</li><li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10，而JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。</li><li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</li></ul><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="D:/大数据开发笔记/1.JAVA/19_集合(Collection)/imgS/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><p>JDK1.6之后LinkedList实现了Deque接口。双端队列也可用作 LIFO（后进先出）堆栈。如果要使用堆栈结构的集合，可以考虑使用LinkedList，而不是Stack。</p><h4 id="24-1-vector源码分析"><a href="#24-1-vector源码分析" class="headerlink" title="24.1 vector源码分析"></a>24.1 vector源码分析</h4><ul><li><p>Object数组初始值10，elementCount元素数量，增量默认0，modCount版本</p></li><li><p>向Vector集合添加数据超过初始值10，扩容，2倍大小扩容</p></li><li><p>Vector里面add解决线程安全问题synchronized</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement增量为<span class="number">0</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>();</span><br><span class="line">       <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">       <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">       <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">       <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">//看是否需要扩容</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-2-ArrayList源码分析"><a href="#24-2-ArrayList源码分析" class="headerlink" title="24.2 ArrayList源码分析"></a>24.2 ArrayList源码分析</h4><p>1.6版本的时候是直接初始化一个10长度的Object数组，1.7版本及之后都是先初始化一个长度为0的Object数组，然后加入第一个元素之后就会初始化一个长度为10的Object数组，然后每一次扩容1.5倍。</p><ul><li><p>数据存储的结构是数组结构。元素增删慢，查找快</p></li><li><p>创建List集合，有三部分：Object数组，size，modCount</p></li><li><p>创建List集合之后，Object数组默认初始大小是0</p></li><li><p>当向集合添加数据，Object数组大小变成10</p></li><li><p>向数组添加数据超过了10，进行扩容，1.5倍大小扩容</p></li></ul><p>JDK1.6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">      <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line"><span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JDK1.7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>();</span><br><span class="line">       <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">           <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//看是否需要扩容处理</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>JDK1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//查看是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">    <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//需要移动的元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">      rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">      modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//需要移动的元素个数</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">      elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">     <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="24-3-LinkedList源码分析"><a href="#24-3-LinkedList源码分析" class="headerlink" title="24.3 LinkedList源码分析"></a>24.3 LinkedList源码分析</h4><ul><li>数据存储的结构链表（双向）</li><li>创建LinkedList对象，包含四部分：size元素数量，first，last，modCount</li><li>添加元素时候，第一次添加元素时候，作为首节点和尾节点</li><li>再次添加时候，在首节点下一个添加节点，可以指向上一个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;<span class="comment">//元素数据</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">          first = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">          prev.next = next;</span><br><span class="line">          <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">          x.prev = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">          next.prev = prev;</span><br><span class="line">          <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">          x.next = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">      x.item = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">//元素个数减少</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="comment">//修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="25-Set集合"><a href="#25-Set集合" class="headerlink" title="25.Set集合"></a>25.Set集合</h3><h4 id="25-1-HashSet"><a href="#25-1-HashSet" class="headerlink" title="25.1 HashSet"></a>25.1 HashSet</h4><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p><p><code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，然后HashMap的底层物理实现是一个Hash表。（什么是哈希表，下一节在HashMap小节在细讲，这里先不展开）</p><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。<strong>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet的元素要重写hashCode和equals方法。</strong></p><p>示例代码：定义一个Employee类，该类包含属性：name, birthday，其中 birthday 为 MyDate类的对象；MyDate为自定义类型，包含年、月、日属性。要求 name和birthday一样的视为同一个员工。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> MyDate birthday;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, MyDate birthday)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> MyDate <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> birthday;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(MyDate birthday)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">result = prime * result + ((birthday == <span class="literal">null</span>) ? <span class="number">0</span> : birthday.hashCode());</span><br><span class="line">result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) obj;</span><br><span class="line"><span class="keyword">if</span> (birthday == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.birthday != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!birthday.equals(other.birthday))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 生日：&quot;</span> + birthday;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.year = year;</span><br><span class="line"><span class="built_in">this</span>.month = month;</span><br><span class="line"><span class="built_in">this</span>.day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getYear</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMonth</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> month;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonth</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.month = month;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDay</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">result = prime * result + day;</span><br><span class="line">result = prime * result + month;</span><br><span class="line">result = prime * result + year;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">MyDate</span> <span class="variable">other</span> <span class="operator">=</span> (MyDate) obj;</span><br><span class="line"><span class="keyword">if</span> (day != other.day)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (month != other.month)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (year != other.year)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashSet</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">HashSet&lt;Employee&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1990</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line"><span class="comment">//重复元素无法添加，因为MyDate和Employee重写了hashCode和equals方法</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1990</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1992</span>,<span class="number">2</span>,<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Employee object : set) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="25-2-LinkedHashSet"><a href="#25-2-LinkedHashSet" class="headerlink" title="25.2 LinkedHashSet"></a>25.2 LinkedHashSet</h4><p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p><h4 id="25-3-TreeSet"><a href="#25-3-TreeSet" class="headerlink" title="25.3 TreeSet"></a>25.3 TreeSet</h4><p>底层结构：里面维护了一个TreeMap，都是基于红黑树实现的！</p><p>特点：<br>    1、不允许重复<br>    2、实现排序<br>        自然排序或定制排序</p><p>如何实现去重的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果使用的是自然排序，则通过调用实现的compareTo方法</span><br><span class="line">如果使用的是定制排序，则通过调用比较器的compare方法</span><br></pre></td></tr></table></figure><p>如何排序？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：自然排序</span><br><span class="line">让待添加的元素类型实现Comparable接口，并重写compareTo方法</span><br><span class="line"></span><br><span class="line">方式二：定制排序</span><br><span class="line">创建Set对象时，指定Comparator比较器接口，并实现compare方法</span><br></pre></td></tr></table></figure><h5 id="自然顺序"><a href="#自然顺序" class="headerlink" title="自然顺序"></a>自然顺序</h5><p>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值为0。</p><p>代码示例一：按照字符串Unicode编码值排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;zhangsan&quot;</span>);  <span class="comment">//String它实现了java.lang.Comparable接口</span></span><br><span class="line">set.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line"><span class="keyword">for</span> (String str : set) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h5><p>如果放到TreeSet中的元素的自然排序（Comparable）规则不符合当前排序需求时，或者元素的类型没有实现Comparable接口。那么在创建TreeSet时，可以单独指定一个Comparator的对象。使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</p><p>代码示例：学生类型未实现Comparable接口，单独指定Comparator比较器，按照学生的学号排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......这里省略了name属性的get/set</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;张三风&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line"><span class="keyword">for</span> (Student stu : set) &#123;</span><br><span class="line">System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-HashMap底层原理"><a href="#26-HashMap底层原理" class="headerlink" title="26.HashMap底层原理"></a>26.HashMap底层原理</h3><p>（1）创建HashMap对象时候，初始化几个值，</p><ul><li>主要：table代表数组默认null，负载因子默认0.75，边界值0<br>  （2）第一次向HashMap添加元素</li><li>根据添加数据key计算hash值</li><li>判断当前table数组是否为空，第一次肯定是空，数组进行初始化<br>   – 数组容量 16 ，临界值 12</li><li>根据数组初始长度和hash值得到数组某个位置，在位置添加元素（第一次加不存在重复问题）</li></ul><p>（3）容量不超过临界值12时候，再次添加数据</p><ul><li>根据添加数据key计算hash值</li><li>根据数组长度和hash值得到数组某个位置，在位置添加元素<br>– 判断数组这个位置上面是否存在元素，如果不存在，添加<br>   – 如果位置存在元素，<br>— 判断位置元素key是否一样，如果key相同，替换，如果key不一样，链表存储</li></ul><p>（4）容量超过临界值12，添加数据</p><ul><li>根据添加数据key计算hash值</li><li>根据数组长度和hash值得到数组某个位置，在位置添加元素<br>– 判断数组这个位置上面是否存在元素，如果不存在，添加<br>– 如果位置存在元素，<br> — 判断位置元素key是否一样，如果key相同，替换，如果key不一样，链表存储<br>   – 判断数组容量是否超过临界值，如果超过进行扩容<br>— 把数组大小2倍，临界值2倍<br>— 把数组元素重新编排</li></ul><p>（5）在jdk1.8优化</p><ul><li>如果数组容量64，链表节点8，把链表转换树形结构</li></ul><h4 id="26-1-Hash的物理结构"><a href="#26-1-Hash的物理结构" class="headerlink" title="26.1 Hash的物理结构"></a>26.1 Hash的物理结构</h4><p>HashMap和Hashtable是散列表，其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个元素被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到了某个table[index]桶中。使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p><h5 id="（1）-数组元素类型"><a href="#（1）-数组元素类型" class="headerlink" title="（1） 数组元素类型"></a>（1） 数组元素类型</h5><p>JDK1.7：</p><p>映射关系被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p><p>观察HashMap.Entry类型是个结点类型，即table[index]下的映射关系可能串起来一个链表。因此我们把table[index]称为“桶bucket”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Entry&lt;K,V&gt; next;</span><br><span class="line">            <span class="type">int</span> hash;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658979185354.png" alt="1658979185354"></p><p>DK1.8：</p><p>映射关系被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p><p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树（自平衡的二叉树）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red;<span class="comment">//是红结点还是黑结点</span></span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980871876.png" alt="1658980871876"></p><h5 id="（2）数组的长度始终是2的n次幂"><a href="#（2）数组的长度始终是2的n次幂" class="headerlink" title="（2）数组的长度始终是2的n次幂"></a>（2）数组的长度始终是2的n次幂</h5><p>table数组的默认初始化长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>如果你手动指定的table长度不是2的n次幂，会通过如下方法给你纠正为2的n次幂</p><p>JDK1.7：</p><p>HashMap处理容量方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">highestOneBit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组不够了，扩容了怎么办？扩容了还是2的n次幂，因为每次数组扩容为原来的2倍</p><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//扩容为原来的2倍</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//oldCap原来的容量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;<span class="comment">//newCap = oldCap &lt;&lt; 1  新容量=旧容量扩容为原来的2倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//......此处省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么要保持table数组一直是2的n次幂呢？</p><p>如果不是2的次幂，会浪费散列表的一些空间位置，因为计算某个元素存放位置的时候，使用的位运算操作，只能得到2的次幂内的索引。在下面会详细讲述</p><h5 id="（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？"><a href="#（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？" class="headerlink" title="（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？"></a>（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？</h5><p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p><p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算，不能保证均匀存放，可能会导致某些table[index]桶中的元素太多，而另一些太少，因此不合适。</p><p>②hash 值 &amp; (table.length-1)，因为table.length是2的幂次方，因此table.length-1是一个二进制低位全是1的数，所以&amp;操作完，也会得到一个[0,table.length-1]范围的值。</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980858318.png" alt="1658980858318"></p><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">//此处h就是hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  <span class="comment">// i = (n - 1) &amp; hash</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//....省略大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）hash是hashCode的再运算"><a href="#（4）hash是hashCode的再运算" class="headerlink" title="（4）hash是hashCode的再运算"></a>（4）hash是hashCode的再运算</h5><p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p><p>为什么要hashCode值的二进制的高位参与到index计算呢？</p><p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p><h5 id="（5）解决-index-冲突问题"><a href="#（5）解决-index-冲突问题" class="headerlink" title="（5）解决[index]冲突问题"></a>（5）解决[index]冲突问题</h5><p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p><p>JDK1.8之间使用：数组+链表的结构。</p><p>JDK1.8之后使用：数组+链表&#x2F;红黑树的结构。</p><p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980822947.png" alt="1658980822947"></p><h5 id="（6）为什么JDK1-8会出现红黑树和链表共存呢？"><a href="#（6）为什么JDK1-8会出现红黑树和链表共存呢？" class="headerlink" title="（6）为什么JDK1.8会出现红黑树和链表共存呢？"></a>（6）为什么JDK1.8会出现红黑树和链表共存呢？</h5><p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p><p>但是二叉树的结构又过于复杂，如果结点个数比较少的时候，那么选择链表反而更简单。</p><p>所以会出现红黑树和链表共存。</p><h5 id="（7）什么时候树化？什么时候反树化？"><a href="#（7）什么时候树化？什么时候反树化？" class="headerlink" title="（7）什么时候树化？什么时候反树化？"></a>（7）什么时候树化？什么时候反树化？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//反树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;<span class="comment">//最小树化容量</span></span><br></pre></td></tr></table></figure><ul><li>当某table[index]下的链表的结点个数达到8，并且table.length&gt;&#x3D;64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</li><li>当某table[index]下的红黑树结点个数少于6个，此时，<ul><li>如果继续删除table[index]下树结点，一直删除到2个以下时就会变回链表。</li><li>如果继续添加映射关系到当前map中，如果添加导致了map的table重新resize，那么只要table[index]下的树结点仍然&lt;&#x3D;6个，那么会变回链表</li></ul></li></ul><h4 id="26-2-JDK1-7的put方法源码解析"><a href="#26-2-JDK1-7的put方法源码解析" class="headerlink" title="26.2 JDK1.7的put方法源码解析"></a>26.2 JDK1.7的put方法源码解析</h4><p>（1）几个关键的常量和变量值的作用：</p><p>初始化容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">//16</span></span><br></pre></td></tr></table></figure><p>①默认负载因子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>②阈值：扩容的临界值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = table.length * loadFactor;</span><br></pre></td></tr></table></figure><p>③负载因子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>负载因子的值大小有什么关系？</p><p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p><p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">      <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性                                       initialCapacity);</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">      <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">      threshold = initialCapacity;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">        <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//添加新的映射关系</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line"><span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">        threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否需要库容</span></span><br><span class="line">        <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//存入table中</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;<span class="comment">//个数增加</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、put(key,value)</p><p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p><p>（2）特殊考虑：如果key为null，index直接是[0],hash也是0</p><p>（3）如果key不为null，在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p>（4）计算index &#x3D; table.length-1 &amp; hash;</p><p>（5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p><p>（6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p><p>（7）添加之前先判断if(size &gt;&#x3D; threshold  &amp;&amp;  table[index]!&#x3D;null)如果该条件为true，会扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(size &gt;= threshold  &amp;&amp;  table[index]!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">①会扩容</span><br><span class="line"></span><br><span class="line">②会重新计算key的hash</span><br><span class="line"></span><br><span class="line">③会重新计算index</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980807705.png" alt="1658980807705"><br>2、get(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index &#x3D; table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p><p>3、remove(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index &#x3D; table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p><h4 id="26-3-JDK1-8的put方法源码分析"><a href="#26-3-JDK1-8的put方法源码分析" class="headerlink" title="26.3 JDK1.8的put方法源码分析"></a>26.3 JDK1.8的put方法源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="type">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="type">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line"><span class="comment">//如果key是null，hash是0</span></span><br><span class="line"><span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line"><span class="comment">//即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line"><span class="type">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tab和table等价</span></span><br><span class="line"><span class="comment">//如果table是空的</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">tab = resize();</span></span><br><span class="line"><span class="comment">n = tab.length;*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">n = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line"><span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line"><span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; </span><br><span class="line">K k;</span><br><span class="line"><span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line"><span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">               e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">               <span class="comment">//单独处理树结点</span></span><br><span class="line">               <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">               <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line"><span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                   p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)&#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">&#125;</span><br><span class="line">               afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素个数增加</span></span><br><span class="line"><span class="comment">//size达到阈值</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">           resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">&#125;</span><br><span class="line">       afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line"><span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//newCap，新容量</span></span><br><span class="line"><span class="comment">//newThr：新阈值</span></span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line"><span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line"><span class="comment">//新容量：32,64，...</span></span><br><span class="line"><span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line"><span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line"><span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line"><span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line"><span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">       <span class="type">int</span> n, index; </span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line"><span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();<span class="comment">//先扩容</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                   hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">               hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1、添加过程</p><p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p><p>（2）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><blockquote><p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p></blockquote><p>（3）计算index &#x3D; table.length-1 &amp; hash;</p><p>（4）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p><p>（5）如果没有相同的，</p><p>①table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p><p>②table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p><p>③table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转为一棵红黑树</p><p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p><p>（6）添加完成后判断if(size &gt; threshold ){</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①会扩容</span><br><span class="line"></span><br><span class="line">②会重新计算key的hash</span><br><span class="line"></span><br><span class="line">③会重新计算index</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980775776.png" alt="1658980775776"></p><p>2、remove(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index &#x3D; table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p><p>（4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</p><h3 id="27-IO流"><a href="#27-IO流" class="headerlink" title="27 IO流"></a>27 IO流</h3><h4 id="27-1-分类"><a href="#27-1-分类" class="headerlink" title="27.1 分类"></a>27.1 分类</h4><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul><li>以InputStream,Reader结尾</li></ul></li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul><li>以OutputStream、Writer结尾</li></ul></li></ul><p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul><li>以InputStream和OutputStream结尾</li></ul></li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul><li>以Reader和Writer结尾</li></ul></li></ul><p>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。</p><ul><li><strong>节点流</strong>：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li><li><strong>处理流</strong>：是对一个已存在的流进行连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul><blockquote><p>这种设计是<strong>装饰模式</strong>（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一。在现实生活中你也有很多装饰者的例子，例如：人需要各种各样的衣着，不管你穿着怎样，但是，对于你个人本质来说是不变的，充其量只是在外面加上了一些装饰，有，“遮羞的”、“保暖的”、“好看的”、“防雨的”….</p></blockquote><p><strong>四大顶级抽象父类</strong></p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658990418003.png" alt="1658990418003"></p><h3 id="28-类加载"><a href="#28-类加载" class="headerlink" title="28.类加载"></a>28.类加载</h3><h4 id="28-1-类的加载过程"><a href="#28-1-类的加载过程" class="headerlink" title="28.1 类的加载过程"></a>28.1 类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p><p>类的加载又分为三个阶段：</p><p>（1）加载：load</p><p>就是指将类型的class字节码数据读入内存</p><p>（2）连接：link</p><p>①验证：校验合法性等</p><p>②准备：准备对应的内存（方法区），创建Class对象，为类变量赋默认值，为静态常量赋初始值。</p><p>③解析：把字节码中的符号引用替换为对应的直接地址引用</p><p>（3）初始化：initialize（类初始化）即执行<clinit>类初始化方法，大多数情况下，类的加载就完成了类的初始化，有些情况下，会延迟类的初始化。</p><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658994987896.png" alt="1658994987896"></p><h4 id="28-2类的初始化"><a href="#28-2类的初始化" class="headerlink" title="28.2类的初始化"></a>28.2类的初始化</h4><p><strong>1、哪些操作会导致类的初始化？</strong></p><p>（1）运行主方法所在的类，要先完成类初始化，再执行main方法</p><p>（2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化</p><p>（3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化</p><p>（4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类</p><p>（5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化</p><blockquote><p>类初始化执行的是<clinit>()，该方法由（1）类变量的显式赋值代码（2）静态代码块中的代码构成</p></blockquote><p><strong>2、哪些使用类的操作，但是不会导致类的初始化？</strong></p><p>（1）使用某个类的静态的常量（static  final）（常量应该是放到常量池之中）</p><p>（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</p><p>（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化</p><h4 id="28-3-类加载器"><a href="#28-3-类加载器" class="headerlink" title="28.3 类加载器"></a>28.3 类加载器</h4><p><strong>1、类加载器分为：</strong></p><p>（1）引导类加载器（Bootstrap Classloader）又称为根类加载器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它负责加载jre/rt.jar核心库</span><br><span class="line">它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null</span><br></pre></td></tr></table></figure><p>（2）扩展类加载器（Extension ClassLoader）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它负责加载jre/lib/ext扩展库</span><br><span class="line">它是ClassLoader的子类</span><br></pre></td></tr></table></figure><p>（3）应用程序类加载器（Application Classloader）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它负责加载项目的classpath路径下的类</span><br><span class="line"></span><br><span class="line">它是ClassLoader的子类</span><br></pre></td></tr></table></figure><p>（4）自定义类加载器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你的程序需要加载“特定”目录下的类，可以自定义类加载器；</span><br><span class="line">当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码</span><br><span class="line">后面会见到的自定义类加载器：tomcat中</span><br></pre></td></tr></table></figure><p><strong>2、Java系统类加载器的双亲委托模式</strong></p><p>简单描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下一级的类加载器，如果接到任务时，会先搜索是否加载过，如果没有，会先把任务往上传，如果都没有加载过，一直到根加载器，如果根加载器在它负责的路径下没有找到，会往回传，如果一路回传到最后一级都没有找到，那么会报ClassNotFoundException或NoClassDefError，如果在某一级找到了，就直接返回Class对象。</span><br></pre></td></tr></table></figure><p>应用程序类加载器  把  扩展类加载器视为父加载器，</p><p>扩展类加载器 把 引导类加载器视为父加载器。</p><p>不是继承关系，是组合的方式实现的。</p><h4 id="双亲委派模型工作工程："><a href="#双亲委派模型工作工程：" class="headerlink" title="双亲委派模型工作工程："></a>双亲委派模型工作工程：</h4><p>　　1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。  </p><p>　　2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。  </p><p>　　3.如果Bootstrap ClassLoader加载失败(在<JAVA_HOME>\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。  </p><p>　　4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。  </p><p>　　5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。  </p><p>　　6.如果均加载失败，就会抛出ClassNotFoundException异常。</p><p>例子：</p><p>　　当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理会先检查自己是否已经加载过，如果没有再往上。注意这个过程，直到到达Bootstrap classLoader之前，都是没有哪个加载器自己选择加载的。如果父加载器无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p><h3 id="29-获取Class对象的四种方式"><a href="#29-获取Class对象的四种方式" class="headerlink" title="29.获取Class对象的四种方式"></a>29.获取Class对象的四种方式</h3><p>（1）类型名.class</p><p>要求编译期间已知类型</p><p>（2）对象.getClass()</p><p>获取对象的运行时类型</p><p>（3）Class.forName(类型全名称)</p><p> 可以获取编译期间未知的类型</p><p>（4）ClassLoader的类加载器对象.loadClass(类型全名称)</p><p>可以用系统类加载对象或自定义加载器对象加载指定路径下的类型</p><h3 id="30-java1-8新特性"><a href="#30-java1-8新特性" class="headerlink" title="30.java1.8新特性"></a>30.java1.8新特性</h3><p>主要是增加了函数式编程的一些接口，比如lambda表达式以及StreamAPI，感觉就是模仿的scala，lambda模仿的就是函数最简化，streamAPI 就是模仿的一套算子连续不断的处理数据，从而节省了中途起名字的一些不必要的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 类型转换 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> this </tag>
            
            <tag> final </tag>
            
            <tag> super </tag>
            
            <tag> instanceof </tag>
            
            <tag> native </tag>
            
            <tag> Object </tag>
            
            <tag> protected </tag>
            
            <tag> 多线程 </tag>
            
            <tag> Thread </tag>
            
            <tag> Runable </tag>
            
            <tag> wait </tag>
            
            <tag> sleep </tag>
            
            <tag> Vector </tag>
            
            <tag> ArrayList </tag>
            
            <tag> 类型通配符 </tag>
            
            <tag> HashSet </tag>
            
            <tag> HashMap </tag>
            
            <tag> 类的加载 </tag>
            
            <tag> 双亲委派机制 </tag>
            
            <tag> JDK1.8新特性 </tag>
            
            <tag> lambda表达式 </tag>
            
            <tag> 反射 </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点介绍</title>
      <link href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络知识点整理"><a href="#计算机网络知识点整理" class="headerlink" title="计算机网络知识点整理"></a>计算机网络知识点整理</h1><h3 id="1-计算机网络体系结构？"><a href="#1-计算机网络体系结构？" class="headerlink" title="1.计算机网络体系结构？"></a>1.计算机网络体系结构？</h3><p>计算机网络体系结构，一般有三种：OSI七层模型、TCP&#x2F;IP模型、五层体系结构</p><p>  <img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656853006626.png" alt="1656853006626"></p><p>简单的来说，OSI是理论上的网络通信模型，TCP&#x2F;IP是实际上的网络通信模型，五层网络结构就是为了介绍网络原理而折中的网络通信模型</p><hr><p><strong>七层模型</strong></p><p>OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p><ul><li><p>应用层：</p><p>应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互的规则，常见的协议有：<strong>HTTP FTP  SMTP SNMP DNS</strong>.</p></li><li><p>表示层：</p><p>表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。</p></li><li><p>会话层：</p><p>虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，自动寻址的功能。于是会话层出现了：它的作用就是建立和管理应用程序之间的通信。</p></li><li><p>传输层：</p><p>当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。</p><p>简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。</p></li><li><p>网络层：</p><p>计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。</p><p>该层的主要任务就是：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。</p></li><li><p>数据链路层：</p><p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p><p>它的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。</p></li><li><p>物理层：</p><p>解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等。它主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。</p><p>它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p><hr><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656902115939.png" alt="1656902115939"></p></li></ul><h3 id="2-说一下每一层对应的网络协议有哪些？"><a href="#2-说一下每一层对应的网络协议有哪些？" class="headerlink" title="2.说一下每一层对应的网络协议有哪些？"></a>2.说一下每一层对应的网络协议有哪些？</h3><table><thead><tr><th>OSI七层网络模型</th><th>对应的网络协议</th></tr></thead><tbody><tr><td>应用层</td><td>FTP、HTTP、DNS 、SMTP、DHCP、Telent</td></tr><tr><td>表示层</td><td>TIFF、GIF、JPEG</td></tr><tr><td>会话层</td><td>PC、SQL、names、AppleTalk、NFS</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>IP、ICMP、ARP、RARP、RIP</td></tr><tr><td>数据链路层</td><td>FDDI、PPP、HDLC</td></tr><tr><td>物理层</td><td>IEEE802.1A 、IEEE802.2-IEEE8.2.11</td></tr></tbody></table><ul><li><p><strong>FDDI：</strong></p><p>光纤分布式数据接口（FDDI）是由美国国家标准化组织（ANSI）制定的<strong>在光缆上发送数字信号的一组协议</strong>。 FDDI使用双环令牌，传输速率可以达到100Mb&#x2F;s。 由于支持高宽带和远距离通信网络，FDDI通常用作骨干网。光纤分布式数据接口FDDI是一种以光纤作为传输介质的高速主干网，它可以用来互连单个计算机与局域网。</p></li><li><p><strong>PPP：</strong></p><p>PPP（Point-to-Point Protocol点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。</p></li><li><p><strong>HDLC：</strong></p><p>HDLC（High-Level Data Link Control，高级数据链路控制），是<a href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E5%B1%82/10624635">链路层</a>协议的一项国际标准，用以实现远程用户间资源共享以及信息交互。HDLC协议用以保证传送到下一层的数据在传输过程中能够准确地被接收，也就是差错释放中没有任何损失，并且序列正确。HDLC协议的另一个重要功能是流量控制，即一旦接收端收到数据，便能立即进行传输。</p></li></ul><h3 id="3-数据是如何在各层之间传输的？"><a href="#3-数据是如何在各层之间传输的？" class="headerlink" title="3.数据是如何在各层之间传输的？"></a>3.数据是如何在各层之间传输的？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656902800902.png" alt="1656902800902"></p><p>整体来说就是发送方首先要把需要发送的数据层层包装，自上层到下层层层包装，知道物理层比特流传输到接收方，然后接收方自下层层层解开包装，直到获取数据。</p><ol><li>首先某个进程（也就是应用层）准备好需要传输的数据，然后准备发送给接收方，如果接受方是域名那么还需要通过DNS解析成IP地址</li><li>把需要传输的数据交付到传输层（TCP&#x2F;UDP层），传输层对数据需要进行适当的分组操作，然后对于每一个分组数据加上首部字段形成一个报文段（或者叫做用户数据报），首部字段包括有源端口号、目的端口号以及一些其它的校验和等数据</li><li>把报文段交付到网际层（IP层），对分组数据加上首部形成IP数据报，首部包括源地址、目的地址以及校验和等数据</li><li>将数据交付到数据链路层（mac层），这一步需要把IP数据报封装成帧（添加首部【SOH】和尾部【EOT】），然后进行透明传输（也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节&#x2F;字符填充），在这一步首部字段包括源地址、目的地址（都是mac地址）以及尾部的字段CRC校验和</li><li>然后把数据交付到物理层，根据数据链路层提供的mac地址，通过特定的传输介质传送到下一个地址</li><li>如果源主机和最终的目的主机在同一个网段，那么就在这个网段找到自己的目的主机，将数据发送给目的主机，如果不再同一个网段，那么需要通过路由器转发数据，一直到找到目的主机所在的网段为止，这样就找到了目的主机</li><li>然后将数据交付到数据链路层，对于数据进行解封装，并且对于接收的数据进行差错检测，产生差错的数据都会被丢弃掉</li><li>传送到IP层，解帧校验</li><li>交付到传输层，在目的主机上，根据端口找到对应的应用，当使用的TCP协议时，提供一种面向连接的可靠的传输服务，可以说是建立了一个虚拟通道，源主机的数据通过该虚拟通道进行传输；若是使用的UDP协议时，提供一种面向的非连接的尽最大努力的不可靠的传输服务，数据传输快，但是无法保证数据100%传输</li><li>建立了传输连接后，应用开始接收数据，发送方数据和接收方都必须满足相同的标准应用层协议，如http、ftp、smtp等，通过标准协议应用即可正确的接收源主机发送过来的数据</li></ol><h3 id="4-从浏览器地址栏输入一个URL到显示主页的过程？"><a href="#4-从浏览器地址栏输入一个URL到显示主页的过程？" class="headerlink" title="4.从浏览器地址栏输入一个URL到显示主页的过程？"></a>4.从浏览器地址栏输入一个URL到显示主页的过程？</h3><p>这道题，大概的过程比较简单，但是有很多点可以细挖：DNS解析、TCP三次握手、HTTP报文格式、TCP四次挥手等等。</p><ol><li>DNS需要解析域名：将输入的URL解析成对应的IP地址</li><li>TCP连接：与服务器通过三次握手，建立TCP连接</li><li>向服务器发送HTTP请求</li><li>服务器处理请求，返回HTTP响应</li><li>浏览器解析并渲染页面</li><li>断开TCP连接：TCP四次挥手，连接结束</li></ol><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656919478648.png" alt="1656919478648"></p><p>各个过程中使用到的协议：</p><p>DNS：获取域名对应的IP地址</p><p>TCP：与服务器建立连接和断开连接</p><p>IP：使用TCP协议时需要使用IP协议，用于寻找到对应主机所在位置</p><p>OPSF：IP数据包再路由器之间，路由之间如何选择，需要使用OPSF协议</p><p>ARP：路由器与服务器通信的时候需要把IP地址转换为IP地址，因此需要使用到ARP协议</p><p>HTTP协议：TCP连接建立完成之后，需要使用HTTP协议传递HTTP报文</p><h3 id="5-说说DNS解析的过程？"><a href="#5-说说DNS解析的过程？" class="headerlink" title="5.说说DNS解析的过程？"></a>5.说说DNS解析的过程？</h3><p>DNS是域名解析系统，由于IP地址四个数据不容易记忆，因此人们便使用英文等容易记忆的网站来代替IP地址的记忆，但是在传输数据的过程中，实际还是IP地址，因此需要DNS域名解析系统将网站解析为IP地址。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656918479625.png" alt="1656918479625"></p><p>就拿<a href="http://www.baidu.com网站的IP地址查询过程如下：">www.baidu.com网站的IP地址查询过程如下：</a></p><ul><li>首先第一步会查询浏览器的缓存，看看能否查询到该域名对应的IP地址，找到就返回，找不到就进行下一步</li><li>然后将请求发往本地DNS服务器（存放在C盘某个目录下 C:WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts.sam），如果查到就直接返回，否则进行下一步</li></ul><p><img src="F:\带数据学习\大数据开发八股文\计算机网络\计算机网络知识点整理.assets\011bdcdebece49b0a8e428f81eba7551_tplv-k3u1fbpfcp-zoom-in-crop-mark_3780_0_0_0.awebp" alt="域名服务器层级"></p><ul><li>本地DNS服务器向根域名服务器发送请求，根域名服务器返回负责com的顶级域名服务器的IP地址的列表</li><li>本地DNS服务器再向其中一个负责com的顶级域名服务器发送一个请求，返回负责baidu.com的权限域名服务器的IP地址列表</li><li>本地DNS服务器再向其中一个权限域名服务器发送一个请求，请求返回网站所对应的IP地址。</li></ul><h3 id="6-详解TCP三次握手以及四次挥手？"><a href="#6-详解TCP三次握手以及四次挥手？" class="headerlink" title="6.详解TCP三次握手以及四次挥手？"></a>6.详解TCP三次握手以及四次挥手？</h3><h5 id="6-1详解三次握手？"><a href="#6-1详解三次握手？" class="headerlink" title="6.1详解三次握手？"></a>6.1详解三次握手？</h5><p>TCP是面向连接的服务，在传送数据之前必须要建立连接，而TCP连接是通过三次握手来建立的</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656986424748.png" alt="1656986424748"></p><p>三次握手过程：</p><ul><li>最开始的时候，客户端和服务器端都是处于close的状态（应该是服务器关机的时候是close），然后服务器端监听客户端的请求（服务器开机监听某个端口变为listen状态），变为listen状态</li><li>客户端发送连接请求，申请第一次握手（SYN&#x3D;1，seq&#x3D;x），发送完毕之后，客户端进入SYN_SENT状态</li><li>服务端确认连接，第二次握手（SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ACKnum&#x3D;x+1），发送完毕后，客户端进入SYN_RCV状态</li><li>客户端收到服务端的确认之后，再次向服务端确认，这就是第三次握手（ACK&#x3D;1，ACKnum&#x3D;y+1），发送完毕后，客户端进入established状态，当服务器端接收到这个包的时候，也会进入established状态</li></ul><p>注释：<br>第一段的意思是<br>SYN同步序号&#x3D;1：(A)要建立连接了！<br>seq序号&#x3D;x（随机）：因为还没有数据，所以写什么都无所谓</p><p>第二段的意思是<br>SYN同步序号&#x3D;1：我(B)同意你(A)建立连接！<br>ACK确认序号&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq序号&#x3D;y（随机）：因为还没有数据，所以写什么都无所谓<br>ack确认号&#x3D;x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据</p><p>第三段的意思是<br>SYN&#x3D;0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq&#x3D;x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack&#x3D;y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p><p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方</p><ol><li><p>序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记，发送方此次发送的数据，在整个数据中的位置</p></li><li><p>确认号：ack，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1</p></li><li><p>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等</p><p>URG：紧急指针（urgent pointer）有效。</p><p>ACK：确认序号有效。（为了与<strong>确认号ack</strong>区分开，我们用大写表示）</p><p>PSH：接收方应该尽快将这个报文交给应用层。</p><p>RST：重置连接。</p><p>SYN：发起一个新连接。</p><p>FIN：释放一个连接。</p></li></ol><h5 id="6-2三次握手为什么不能是两次或者是四次？"><a href="#6-2三次握手为什么不能是两次或者是四次？" class="headerlink" title="6.2三次握手为什么不能是两次或者是四次？"></a>6.2三次握手为什么不能是两次或者是四次？</h5><p><strong>为什么不是两次？</strong></p><ul><li>为了防止服务器端开启一些无用的连接增加服务器开销</li><li>防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li></ul><p>如果是两次握手，会产生上述两种问题。</p><ol><li><p>客户端首先给服务器端发送了SYN&#x3D;1的第一次握手，服务器端收到请求后，如果是两次握手，那么服务器就直接创建了这个TCP连接，然后返回SYN、ACK、Seq等内容的数据包给客户端，但是由于网络传输的原因丢失掉了，丢失之后客户端一直没有接收到服务器返回的数据包。</p><p>如果没有第三次握手来告诉服务器端，客户端已经收到了服务器端传送的数据，服务器端是不会知道客户端没有收到他传输的信息的，因此服务端会认为这个连接有效，会一直开着端口，等到客户端由于超时重传发出新的请求时，服务器端又会开启一个新的端口，这样就会造成很多无效端口的开启，导致资源的浪费。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657013308985.png" alt="1657013308985"></p></li><li><p>还有一种情况就是由于网络波动，客户端第一次发送的连接请求服务器端一直没有收到，然后超时重传机制，客户端发送第二次请求，但是第一次请求先于第二次请求到达服务器端，服务器端以为时客户端发出的有效请求，从而发生错误。</p></li></ol><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657018232670.png" alt="1657018232670"></p><p>所以我们需要第三次握手来确认这个过程：</p><p>通过第三次握手的数据来告诉服务器，客户端是否收到了服务器“第二次握手”时传过去的数据，以及这个连接的序号是否有效。若发送的数据时“收到且没有问题”，那么服务器就正常建立TCP连接，否则TCP连接失败，服务器关闭连接端口，由此减少服务器开销以及接收到失效请求发生的错误。</p><p><strong>为什么不是四次？</strong></p><p>三次挥手已经足够创建可靠的连接，没有必要再多一次握手导致花费更多的时间建立连接。</p><h5 id="6-3-三次握手中每一次没有收到报文会发生什么？"><a href="#6-3-三次握手中每一次没有收到报文会发生什么？" class="headerlink" title="6.3 三次握手中每一次没有收到报文会发生什么？"></a>6.3 三次握手中每一次没有收到报文会发生什么？</h5><ul><li><p>第一次握手，服务器端没有收到SYN报文</p><p>服务器端不会有任何的操作，而客户端由于没有收到服务器端传来的确认报文，等待一段时间之后就会重新发送SYN报文，如果仍然没有回应，会一直重复这个过程，一直到发送次数超过最大重传次数限制，就会返回连接建立失败</p></li><li><p>第二次握手，客户端没有收到服务端响应的报文</p><p>客户端会继续重传，一直到次数限制，而服务端会阻塞在accept()处，等待客户端发送ACK报文</p></li><li><p>第三次握手服务端没有收到客户端发送过来的ACK报文</p><p>服务器会采取类似客户端的超时重传机制，如果重试次数超过限制，那么accept()调用返回-1，服务器建立连接失败，而此时客户端认为自己已经建立连接成功，因此开始向服务器发送数据，但是服务器端的accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送过来的数据之后会发送RST报文（<strong>用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求</strong>）给客户端，告知客户端TCP连接失败</p></li></ul><h5 id="6-4第二次握手传回了-ACK，为什么还要传回-SYN？"><a href="#6-4第二次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="6.4第二次握手传回了 ACK，为什么还要传回 SYN？"></a>6.4第二次握手传回了 ACK，为什么还要传回 SYN？</h5><p>ACK是为了告诉客户端传来的数据已经接收无误。</p><p>而传回SYN是为了告诉客户端，服务端响应的确实是客户端发送的报文。</p><h5 id="6-5-第3次握手可以携带数据吗？"><a href="#6-5-第3次握手可以携带数据吗？" class="headerlink" title="6.5 第3次握手可以携带数据吗？"></a>6.5 第3次握手可以携带数据吗？</h5><p>第3次握手是可以携带数据的。</p><p>此时客户端已经处于ESTABLISHED状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p><p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在SYN报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成CPU和内存的消耗。</p><h5 id="6-6-说说半连接队列和-SYN-Flood-攻击的关系？"><a href="#6-6-说说半连接队列和-SYN-Flood-攻击的关系？" class="headerlink" title="6.6 说说半连接队列和 SYN Flood 攻击的关系？"></a>6.6 说说半连接队列和 SYN Flood 攻击的关系？</h5><p><strong>什么是半连接队列？</strong></p><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657020088935.png" alt="1657020088935"></p><p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p><ul><li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 <strong>ACK 和 SYN</strong>，状态由 <strong>LISTEN 变为 SYN_RCVD</strong>，此时这个连接就被推入了 <strong>SYN 队列</strong>，即半连接队列。</li><li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。</li></ul><p><strong>什么是SYN Flood ？</strong></p><p>SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造<strong>不存在的 IP 地址</strong>, 向服务器发送大量SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么SYN队列里的连接旧不会出对队，久⽽久之就会占满服务端的 <strong>SYN</strong> 接收队列（半连接队列），使得服务器不能为正常⽤户服务。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657020182492.png" alt="1657020182492"></p><p><strong>那有什么应对方案呢？</strong></p><p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p><p><strong>syn cookie</strong>：SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃</p><p><strong>SYN Proxy 防火墙</strong>：SYN Proxy则是管家式的防御，它站在攻击者和目标服务器之间，伪装成目标服务器对所有的SYN报文进行应答，包括攻击者在内。当三次握手正确的建立起来后，就伪装成客户端IP地址与后端的目标服务器建立三次握手，然后转发数据，需要注意的是，TCP三次握手在这里变成了6次握手，而且两个握手内的ACK号肯定不一致，需要做一个修正。</p><h5 id="6-7-说说TCP四次挥手的过程？"><a href="#6-7-说说TCP四次挥手的过程？" class="headerlink" title="6.7 说说TCP四次挥手的过程？"></a>6.7 说说TCP四次挥手的过程？</h5><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657021916995.png" alt="1657021916995"></p><p>TCP 四次挥手过程：</p><ul><li>数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起</li><li>客户端发送释放连接报文，<strong>第一次挥手</strong> (FIN&#x3D;1，seq&#x3D;u)，发送完毕后，客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li><li>服务端发送确认报文，<strong>第二次挥手</strong> (ACK&#x3D;1，ack&#x3D;u+1,seq &#x3D;v)，发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li><li>服务端发送释放连接报文，<strong>第三次挥手</strong> (FIN&#x3D;1，ACK1,seq&#x3D;w,ack&#x3D;u+1)，发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li><li>客户端发送确认报文，<strong>第四次挥手</strong> (ACK&#x3D;1，seq&#x3D;u+1,ack&#x3D;w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657022248999.png" alt="1657022248999"></p><h5 id="6-8TCP-挥手为什么需要四次呢？"><a href="#6-8TCP-挥手为什么需要四次呢？" class="headerlink" title="6.8TCP 挥手为什么需要四次呢？"></a>6.8TCP 挥手为什么需要四次呢？</h5><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p><h5 id="6-9TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？"><a href="#6-9TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？" class="headerlink" title="6.9TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？"></a>6.9TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h5><p><strong>为什么需要等待？</strong></p><ol><li><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</li><li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li></ol><p><strong>为什么等待的时间是2MSL？</strong></p><p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最长时间，超过这个时间报⽂将被丢弃。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657022839580.png" alt="1657022839580"></p><p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p><p>⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p><h5 id="6-10保活计时器有什么用？"><a href="#6-10保活计时器有什么用？" class="headerlink" title="6.10保活计时器有什么用？"></a>6.10保活计时器有什么用？</h5><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。</p><p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p><p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p><p><strong>6.11CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</strong></p><p><strong>CLOSE-WAIT状态有什么意义？</strong></p><hr><p>服务端收到客户端关闭连接的请求并确认之后，就会进入CLOSE-WAIT状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT状态就是为了保证服务端在关闭连接之前将待发送的数据处理完。</p><p> <strong>TIME-WAIT有什么意义？</strong></p><p>TIME-WAIT状态发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入TIME-WAIT状态。</p><p>它存在的意义主要是两个：</p><ul><li><p><strong>防⽌旧连接的数据包</strong></p><p>如果客户端收到服务端的FIN报文之后立即关闭连接，但是此时服务端对应的端口并没有关闭，如果客户端在相同端口建立新的连接，可能会导致新连接收到旧连接残留的数据包，导致不可预料的异常发生。</p></li><li><p><strong>保证连接正确关闭</strong></p><p>假设客户端最后一次发送的ACK包在传输的时候丢失了，由于TCP协议的超时重传机制，服务端将重发FIN报文，如果客户端没有维持TIME-WAIT状态而直接关闭的话，当收到服务端重新发送的FIN包时，客户端就会使用RST包来响应服务端，导致服务端以为有错误发生，然而实际关闭连接过程是正常的</p></li></ul><h3 id="7-说说-WebSocket-与-Socket-的区别？"><a href="#7-说说-WebSocket-与-Socket-的区别？" class="headerlink" title="7.说说 WebSocket 与 Socket 的区别？"></a>7.说说 WebSocket 与 Socket 的区别？</h3><ul><li>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。</li></ul><p>具体来说，Socket 是一套标准，它完成了对 TCP&#x2F;IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p><ul><li>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li><li>Socket 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li></ul><h3 id="8-说一下你了解的端口以及对应的服务？"><a href="#8-说一下你了解的端口以及对应的服务？" class="headerlink" title="8.说一下你了解的端口以及对应的服务？"></a>8.说一下你了解的端口以及对应的服务？</h3><table><thead><tr><th>端口</th><th>服务</th></tr></thead><tbody><tr><td>21</td><td>FTP（文件传输协议）</td></tr><tr><td>22</td><td>SSH</td></tr><tr><td>23</td><td>Telnet（远程登录服务）</td></tr><tr><td>53</td><td>DNS域名解析服务</td></tr><tr><td>80</td><td>HTTP超文本传输协议</td></tr><tr><td>443</td><td>HTTPS</td></tr><tr><td>1080</td><td>Sockets</td></tr><tr><td>3306</td><td>MySQL 默认端口号</td></tr><tr><td>25</td><td>SMTP（简单邮件传输协议）</td></tr><tr><td>6</td><td>TCP传输协议</td></tr><tr><td>17</td><td>UDP传输协议</td></tr><tr><td>89</td><td>OSPF 最短路径优先协议</td></tr></tbody></table><h3 id="9-HTTP常用状态码以及其含义？"><a href="#9-HTTP常用状态码以及其含义？" class="headerlink" title="9.HTTP常用状态码以及其含义？"></a>9.HTTP常用状态码以及其含义？</h3><p>大致分类如下：</p><ul><li>1XX：信息性状态码（信息。服务器收到请求，请继续执行请求）</li><li>2XX：成功状态码（成功。请求被成功接收并处理）</li><li>3XX：重定向状态码（重定向。需要进一步操作来完成请求）</li><li>4XX：客户端错误状态码（客户端错误。无法完成请求，或请求包含语法错误）</li><li>5XX：服务端错误状态码（服务器错误。服务器在处理请求的过程中发生错误）</li></ul><p>101：切换请求协议，服务器端根据客户端的请求来切换协议，切换到更高级的协议，如HTTP的新版本协议</p><p>200：请求成功</p><p>301：请求资源永久移动，返回新的URI，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址</p><p>302：请求资源临时移动，继续使用原有的URI，服务器从另外的地址响应资源，但是客户端还应该使用这个地址</p><p>400：客户端请求的语法错误，服务端无法理解</p><p>401：当前请求需要进行认证，对于需要登录的网页，服务器可能返回此响应</p><p>403：服务器禁止访问，拒绝此请求</p><p>404：服务器找不到请求的网页</p><p>500：服务器遇到错误，无法完成请求</p><p>505：服务器不支持请求中所用的 HTTP 协议版本</p><h3 id="10-HTTP有哪些请求方式？"><a href="#10-HTTP有哪些请求方式？" class="headerlink" title="10.HTTP有哪些请求方式？"></a>10.HTTP有哪些请求方式？</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p><ol><li>Get：请求指定的页面信息，并返回实体主体。</li><li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li><li>PUT：从客户端向服务器传送的数据取代指定的文档的内容（修改指定资源）。</li><li>DELETE：请求服务器删除指定的页面（删除指定URL的资源）。</li><li>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法</li><li>TRACE：主要用于回环测试</li><li>PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新 。</li></ol><h3 id="11-说一下GET和POST的区别？"><a href="#11-说一下GET和POST的区别？" class="headerlink" title="11.说一下GET和POST的区别？"></a>11.说一下GET和POST的区别？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656928083239.png" alt="1656928083239"></p><ol><li>从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET  请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET  请求把数据放 URL 上不太安全，而 POST 请求把数据放在请求体里想比较而言安全一些。</li><li>从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和 GET&#x2F;POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET  请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据</li><li>从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL  能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET  请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN  缓存起来了，大大减少了 Web 服务器的负担。</li></ol><h3 id="12-GET的长度限制是多少？"><a href="#12-GET的长度限制是多少？" class="headerlink" title="12.GET的长度限制是多少？"></a>12.GET的长度限制是多少？</h3><p>HTTP中的GET方法是通过URL传递数据的，但是URL本身其实并没有对数据的长度进行限制，真正限制GET长度的是浏览器。</p><p>例如IE浏览器对URL的最大限制是2000多个字符，大概2kb左右，像Chrome、Firefox等浏览器支持的URL字符数更多，其中FireFox中URL的最大长度限制是65536个字符，Chrome则是8182个字符。</p><p>这个长度限制也不是针对数据部分，而是针对整个URL。</p><h3 id="13-HTTP请求的过程与原理？"><a href="#13-HTTP请求的过程与原理？" class="headerlink" title="13.HTTP请求的过程与原理？"></a>13.HTTP请求的过程与原理？</h3><p>HTTP协议定义了浏览器如何向服务器请求文档，以及服务器如何把文档传给浏览器</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656931575904.png" alt="1656931575904"></p><ul><li>每个服务器都有一个进程，它不断监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求</li><li>监听到连接请求，就会建立TCP连接</li><li>浏览器向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应</li><li>最后，释放TCP连接</li></ul><p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议HTTP。</p><h3 id="14-HTTP的报文结构？"><a href="#14-HTTP的报文结构？" class="headerlink" title="14.HTTP的报文结构？"></a>14.HTTP的报文结构？</h3><p>HTTP报文有两种，HTTP请求报文和HTTP响应报文</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656931718378.png" alt="1656931718378"></p><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：</p><ul><li>方法字段：包括POST、GET等请方法。</li><li>URL 字段</li><li>HTTP 版本字段</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656931726039.png" alt="1656931726039"></p><p>HTTP 响应报文的第一行叫做<strong>状态行</strong>，后面的行是<strong>首部行</strong>，最后是<strong>实体主体</strong>。</p><ul><li><p><strong>状态行</strong>包含了三个字段：协议版本字段、状态码和相应的状态信息。</p></li><li><p><strong>实体部分</strong>是报文的主要部分，它包含了所请求的对象。</p></li><li><p><strong>首部行</strong></p><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。 </p><ul><li>常见的请求首部有 Accept ：可接收媒体资源的类型、Accept-Charset： 可接收的字符集、Host ：请求的主机名，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li><li>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</li><li>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</li></ul></li></ul><h3 id="15-URI和URL的区别？"><a href="#15-URI和URL的区别？" class="headerlink" title="15.URI和URL的区别？"></a>15.URI和URL的区别？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656933075929.png" alt="1656933075929"></p><p>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是Web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都是由一个URI进行标识的。</p><p>URL，统一资源定位符（Uniform Resource Location)，它是URI的一种子集，主要作用是提供资源的路径。</p><p>它们的主要区别在于，URL除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人。</p><p>最好的说明就是java的继承关系。url继承了uri，因为url继承了所有uri的内容，所以它比uri更加详细，但是uri是它的父级。</p><h3 id="16-HTTP-x2F-1-0、1-1、2-0、3-0的区别"><a href="#16-HTTP-x2F-1-0、1-1、2-0、3-0的区别" class="headerlink" title="16.HTTP&#x2F;1.0、1.1、2.0、3.0的区别."></a>16.HTTP&#x2F;1.0、1.1、2.0、3.0的区别.</h3><p>关键需要记住 <strong>HTTP&#x2F;1.0</strong> 默认是短连接，可以强制开启，HTTP&#x2F;1.1 默认长连接，HTTP&#x2F;2.0 采用<strong>多路复用</strong>。</p><p><strong>HTTP&#x2F;1.0:</strong></p><ul><li>默认使用<strong>短连接</strong>，每次请求都需要建立一个 TCP 连接。它可以设置<code>Connection: keep-alive</code> 这个字段，强制开启长连接。</li></ul><p> HTTP&#x2F;1.0浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求简单来讲，每次与服务器交互，都需要新开一个连接.</p><p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接,这种形式明显造成了性能上的缺陷</p><p><strong>HTTP&#x2F;1.1:</strong></p><ol><li><p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟,这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p></li><li><p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p></li><li><p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善功能，引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略</p></li><li><p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code></p></li></ol><p><strong>HTTP&#x2F;2.0:</strong></p><p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一些特性：</p><ol><li>多路复用：在一个连接里，客户端和浏览器都可以<strong>同时</strong>发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</li><li>二进制分帧：1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。</li><li>首部压缩：HTTP&#x2F;2对消息头采用压缩传输，能够节省消息头占用的网络的流量，而HTTP&#x2F;1.x每次请求都会携带大量的冗余头信息，浪费了很多带宽资源。HTTP&#x2F;2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;只有第一次请求需要把所有头部的键值对发送过去，后面的请求仅仅需要发送差异数据即可。</li><li>服务器推送：允许服务端推送资源给客户端，服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源，免得客户端再次创建连接发送请求到服务器端获取。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</li></ol><p><strong>HTTP&#x2F;3.0:</strong></p><p>HTTP3.0主要有两大变化，传输层基于UDP、使用QUIC来保证UDP的可靠性</p><h3 id="17-HTTP如何实现长连接？在什么时候会超时？"><a href="#17-HTTP如何实现长连接？在什么时候会超时？" class="headerlink" title="17.HTTP如何实现长连接？在什么时候会超时？"></a>17.HTTP如何实现长连接？在什么时候会超时？</h3><p>HTTP分为长连接和短连接本质上指的是TCP的长短连接，TCP连接是一个双向的通道，它可以保持一段时间内不关闭，因此TCP连接具有真正的长连接和短连接这一说法.</p><p>TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样可以减少资源消耗</p><p>在HTTP1.0阶段默认是短连接，可以通过设置头部的字段Connection字段为keep-alive，从HTTP1.1之后，连接默认都是长连接。</p><ul><li>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li><li>TCP的keep-alive也包含了三个参数，当TCP连接之后，一旦闲置了<strong>tcp_keepalive_time</strong>，那么服务器需要向客户端确认是否存活，因此需要向客户端发送帧测包，如果没有收到对方的ACK应答，那么就每隔tcp_keepalive_intvl时间再发一次，一直到发送了<strong>tcp_keepalive_probes</strong>次，就会丢弃该连接</li></ul><h3 id="18-HTTP和HTTPS的区别？"><a href="#18-HTTP和HTTPS的区别？" class="headerlink" title="18.HTTP和HTTPS的区别？"></a>18.HTTP和HTTPS的区别？</h3><ol><li>安全问题：HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题，HTTPS较为安全，在HTTP和TCP之间加入了SSL&#x2F;TLS安全协议，使得报文能够加密传输</li><li>连接的复杂性：HTTP连接相对简单，TCP三次握手之后就可以进行HTTP的报文传输，而HTTPS在TCP三次握手之后，还需要进行SSL&#x2F;TLS的握手过程，才可以进入加密报文传输</li><li>端口号不同：HTTP是80端口号，HTTPS是443</li><li>HTTPS需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><h3 id="19-为什么要用HTTPS？解决了哪些问题？"><a href="#19-为什么要用HTTPS？解决了哪些问题？" class="headerlink" title="19.为什么要用HTTPS？解决了哪些问题？"></a>19.为什么要用HTTPS？解决了哪些问题？</h3><p>因为HTTP 是明⽂传输，存在安全上的风险：</p><ul><li><strong>窃听⻛险</strong>，⽐如通信链路上可以获取通信内容，用户账号被盗。</li><li><strong>篡改⻛险</strong>，⽐如强制植⼊垃圾⼴告，视觉污染。</li><li><strong>冒充⻛险</strong>，⽐如冒充淘宝⽹站，用户金钱损失。</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943343057.png" alt="1656943343057"></p><p>所以引入了HTTPS，HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL&#x2F;TLS 协议，可以很好的解决了这些风险：</p><ul><li><strong>信息加密</strong>：交互信息⽆法被窃取。</li><li><strong>校验机制</strong>：⽆法篡改通信内容，篡改了就不能正常显示。</li><li><strong>身份证书</strong>：能证明淘宝是真淘宝。</li></ul><h3 id="20-HTTPS的工作流程？"><a href="#20-HTTPS的工作流程？" class="headerlink" title="20.HTTPS的工作流程？"></a>20.HTTPS的工作流程？</h3><ol><li>客户端发起 HTTPS 请求，连接到服务端的 443 端口。</li><li>服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</li><li>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</li><li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</li><li>客户端将公钥加密后的密钥发送到服务器。</li><li>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</li><li>服务器将加密后的密文返回到客户端。</li><li>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</li></ol><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943742361.png" alt="1656943742361"></p><h3 id="21-客户端怎么去校验证书的合法性？"><a href="#21-客户端怎么去校验证书的合法性？" class="headerlink" title="21.客户端怎么去校验证书的合法性？"></a>21.客户端怎么去校验证书的合法性？</h3><p>为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943844348.png" alt="1656943844348"></p><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li><li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li><p>⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；</p></li><li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate</p><p>Signature 内容，得到⼀个 Hash 值 H2 ；</p></li><li><p>最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p></li></ul><p>假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。</p><h3 id="22-如何理解-HTTP-协议是无状态的？"><a href="#22-如何理解-HTTP-协议是无状态的？" class="headerlink" title="22.如何理解 HTTP 协议是无状态的？"></a>22.如何理解 HTTP 协议是无状态的？</h3><p>这个<code>无状态</code>的的<code>状态</code>值的是什么？是客户端的状态，所以字面意思，就是HTTP协议中服务端不会保存客户端的任何信息。</p><p>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p><p><strong>那有什么办法记录状态呢</strong>？</p><p>主要有两个办法，Session和Cookie。</p><h3 id="23-说说Session-和-Cookie-有什么联系和区别"><a href="#23-说说Session-和-Cookie-有什么联系和区别" class="headerlink" title="23.说说Session 和 Cookie 有什么联系和区别?"></a>23.说说Session 和 Cookie 有什么联系和区别?</h3><p><strong>什么是Session 和 Cookie</strong></p><ul><li>Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务端可以根据这个Cookie判断用户的身份和状态。</li><li>Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656944261698.png" alt="1656944261698"></p><p><strong>Session 和 Cookie 到底有什么不同呢？</strong></p><ul><li>存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。</li><li>存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。</li></ul><p><strong>Session 和 Cookie有什么关联呢？</strong></p><p>可以使用Cookie记录Session的标识。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656945589033.png" alt="1656945589033"></p><ul><li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。</li><li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><p><strong>客户端无法使用Cookie怎么办？</strong></p><ul><li>拼接到URL里：直接把SessionID作为URL的请求参数</li><li>放到请求头里：把SessionID放到请求的Header里，比较常用。</li></ul><h3 id="24-说说-TCP-报文首部的格式？"><a href="#24-说说-TCP-报文首部的格式？" class="headerlink" title="24.说说 TCP 报文首部的格式？"></a>24.说说 TCP 报文首部的格式？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657024288352.png" alt="1657024288352"></p><ul><li><strong>16 位端口号</strong>：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li><li><strong>32 位序号</strong>：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号</li><li><strong>32 位确认号</strong>：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1，即期望对面发送的序号</li><li><strong>4 位首部长度</strong>：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节</li><li><strong>6 位标志位</strong>：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PST（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li><li><strong>16 位窗口大小</strong>：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li><li><strong>16 位校验和</strong>：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li><li><strong>16 位紧急指针</strong>：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li></ul><h3 id="25-TCP-是如何保证可靠性的？"><a href="#25-TCP-是如何保证可靠性的？" class="headerlink" title="25.TCP 是如何保证可靠性的？"></a>25.TCP 是如何保证可靠性的？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025308270.png" alt="1657025308270"></p><ol><li><p><strong>连接管理</strong>：TCP使用三次握手和四次挥手保证可靠地建立连接和释放连接</p></li><li><p><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025342064.png" alt="1657025342064"></p></li><li><p><strong>序列号&#x2F;确认应答</strong>：TCP 给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。就像老师上课，会问一句，这一章听懂了吗？没听懂再讲一遍。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025375370.png" alt="1657025375370"></p></li><li><p><strong>流量控制：</strong>TCP  连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025416818.png" alt="1657025416818"></p></li><li><p><strong>最大消息长度</strong>：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p></li></ol><p>​<img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025452055.png" alt="1657025452055"></p><ol start="6"><li><p><strong>超时重传：</strong>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025505337.png" alt="1657025505337"></p><ol start="7"><li><p><strong>拥塞控制：</strong>如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657026424971.png" alt="1657026424971"></p></li></ol></li></ol><h5 id="25-1-说说-TCP-的流量控制？"><a href="#25-1-说说-TCP-的流量控制？" class="headerlink" title="25.1 说说 TCP 的流量控制？"></a>25.1 说说 TCP 的流量控制？</h5><p>TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是<strong>流量控制</strong></p><p>TCP 通过<strong>滑动窗口</strong>来控制流量，我们看下简要流程：</p><ul><li><p>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657027472769.png" alt="1657027472769"></p></li><li><p>假如当前发送方给接收方发送了 200 个字节，那么，发送方的<code>SND.NXT</code>会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。</p></li><li><p>接受方收到后，放到缓冲队列里面，REV.WND &#x3D;400-200&#x3D;200 字节，所以 win&#x3D;200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</p></li><li><p>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND &#x3D; 400-200-100&#x3D;100 字节，即 win&#x3D;100 返回发送方。</p></li><li><p>发送方继续发送 100 字节过来，这时候，接收窗口 win 变为 0。</p></li><li><p>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</p></li></ul><h5 id="25-2详细说说-TCP-的滑动窗口"><a href="#25-2详细说说-TCP-的滑动窗口" class="headerlink" title="25.2详细说说 TCP 的滑动窗口?"></a>25.2详细说说 TCP 的滑动窗口?</h5><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p><p>“用一个比喻，我们在微信上聊天，你打完一句话，我回复一句之后，你才能打下一句。假如我没有及时回复呢？你是把话憋着不说吗？然后傻傻等到我回复之后再接着发下一句？”</p><p>为了解决这个问题，TCP 引入了<strong>窗口</strong>，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p><p>TCP 头部有个字段叫 win，也即那个 <strong>16 位的窗口大小</strong>，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p><p>“通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是 win。”</p><p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p><ul><li>已发送且已收到 ACK 确认</li><li>已发送但未收到 ACK 确认</li><li>未发送但可以发送</li><li>未发送也不可以发送</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657029289716.png" alt="1657029289716"></p><ul><li>深蓝色框里就是发送窗口。</li><li>SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 10个，即发送窗口大小是 10。</li><li>SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li><li>SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li></ul><p>接收方的滑动窗口包含三大部分，如下：</p><ul><li>已成功接收并确认</li><li>未收到数据但可以接收</li><li>未收到数据并不可以接收的数据</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657029386995.png" alt="1657029386995"></p><ul><li>蓝色框内，就是接收窗口。</li><li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li><li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li></ul><h3 id="26-了解Nagle-算法和延迟确认吗？"><a href="#26-了解Nagle-算法和延迟确认吗？" class="headerlink" title="26.了解Nagle 算法和延迟确认吗？"></a>26.了解Nagle 算法和延迟确认吗？</h3><p><strong>Nagle 算法和延迟确认是干什么的？</strong></p><p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657029521819.png" alt="1657029521819"></p><p>这就好像快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费。</p><p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p><ul><li>Nagle 算法</li><li>延迟确认</li></ul><p><strong>Nagle 算法</strong></p><hr><p>Nagle 算法：<strong>任意时刻，最多只能有一个未被确认的小段</strong>。所谓 “小段”，指的是小于 MSS 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。</p><p>Nagle 算法的策略：</p><ul><li>没有已发送未确认报⽂时，⽴刻发送数据。</li><li>存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据。</li></ul><p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。</p><p><strong>延迟确认</strong></p><hr><p>事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。</p><p>为了解决 ACK 传输效率低问题，所以就衍⽣出了 <strong>TCP</strong> 延迟确认。</p><p>TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅</li><li>当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送</li><li>如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK</li></ul><p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p><h3 id="27-说说TCP-的拥塞控制？"><a href="#27-说说TCP-的拥塞控制？" class="headerlink" title="27.说说TCP 的拥塞控制？"></a>27.说说TCP 的拥塞控制？</h3><p><strong>什么是拥塞控制？不是有了流量控制吗？</strong></p><p>前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。</p><p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p><p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤….</p><p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p><p>于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p><p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，调节所要发送数据的量。</p><p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong></p><p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p><p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p><p>拥塞窗⼝ cwnd 变化的规则：</p><ul><li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li><li>但⽹络中出现了拥塞， cwnd 就减少；</li></ul><p><strong>拥塞控制有哪些常用算法？</strong></p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657030810370.png" alt="1657030810370"></p><hr><p><strong>慢启动算法</strong></p><p>它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p><p>举个例子：</p><ul><li>连接建⽴完成后，⼀开始初始化 cwnd &#x3D; 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li><li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发4 个，所以这⼀次能够发送 8 个。</li></ul><p>发包的个数是指数性的增⻓。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657031515801.png" alt="1657031515801"></p><p>为了防止 cwnd 增长过大引起网络拥塞，还需设置一个<strong>慢启动阀值 ssthresh</strong>（slow start threshold）状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 <strong>cwnd &gt;ssthresh</strong> 时，进入了<strong>拥塞避免</strong>算法。</p><hr><p><strong>拥塞避免算法</strong></p><p>一般来说，慢启动阀值 ssthresh 是 65535 字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p><ul><li>每收到一个 ACK 时，cwnd &#x3D; cwnd + 1&#x2F;cwnd</li><li>当每过一个 RTT（往返时间） 时，cwnd &#x3D; cwnd + 1</li></ul><p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p><p>接着上面慢启动的例子，假定 ssthresh 为 8 ： ：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9个 MSS ⼤⼩的数据，变成了线性增⻓</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657031788159.png" alt="1657031788159"></p><hr><p><strong>拥塞发生</strong></p><p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p><ul><li>RTO 超时重传</li><li>快速重传</li></ul><p>如果是发生了 <strong>RTO（Retransmission Timeout） 超时重传</strong>，就会使用拥塞发生算法</p><ul><li>慢启动阀值 sshthresh &#x3D;  cwnd &#x2F;2</li><li>cwnd 重置为 1</li><li>进入新的慢启动过程</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657031957004.png" alt="1657031957004"></p><p>其实还有更好的处理方式，就是<strong>快速重传</strong>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 <strong>RTO 超时</strong>再重传。</p><p>发⽣快速重传的拥塞发⽣算法：</p><ul><li>拥塞窗口大小 cwnd &#x3D; cwnd&#x2F;2</li><li>慢启动阀值 ssthresh &#x3D; cwnd</li><li>进入快速恢复算法</li></ul><hr><p><strong>快速恢复</strong></p><p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：</p><ul><li>cwnd &#x3D; cwnd &#x2F;2</li><li>sshthresh &#x3D; cwnd</li></ul><p>然后，进⼊快速恢复算法如下：</p><ul><li>cwnd &#x3D; sshthresh  + 3</li><li>重传重复的那几个 ACK（即丢失的那几个数据包）</li><li>如果再收到重复的 ACK，那么 cwnd &#x3D; cwnd +1</li><li>如果收到新数据的 ACK 后, cwnd &#x3D; sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657032229484.png" alt="1657032229484"></p><h3 id="28-说说-TCP-的重传机制？"><a href="#28-说说-TCP-的重传机制？" class="headerlink" title="28.说说 TCP 的重传机制？"></a>28.说说 TCP 的重传机制？</h3><p>重传包括<strong>超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种</strong>。</p><p>超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。</p><p><strong>超时时间应该设置为多少呢？</strong></p><p>先来看下什么叫 <strong>RTT（Round-Trip Time，往返时间）</strong>。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033574911.png" alt="1657033574911"></p><p>RTT 就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。</p><p>超时重传时间，就是 RTO（Retransmission Timeout)。那么，<strong>RTO 到底设置多大呢？</strong></p><ul><li>如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。</li><li>如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。</li></ul><p>一般来说，RTO 略微大于 RTT，效果是最佳的。</p><p>其实，RTO 有个标准方法的计算公式，也叫 <strong>Jacobson &#x2F; Karels 算法</strong>。</p><ol><li>首先计算 SRTT（即计算平滑的 RTT）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均</span><br></pre></td></tr></table></figure><ol><li>其次，计算 RTTVAR (round-trip time variation)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距</span><br></pre></td></tr></table></figure><ol><li>最后，得出最终的 RTO</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  </span><br></pre></td></tr></table></figure><p>在 Linux 下，<strong>α &#x3D; 0.125</strong>，<strong>β &#x3D; 0.25</strong>， <strong>μ &#x3D; 1</strong>，<strong>∂ &#x3D; 4</strong>。别问这些参数是怎么来的，它们是大量实践，调出的最优参数。</p><p>超时重传不是十分完美的重传方案，它有这些缺点：</p><ul><li>当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。</li><li>当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li></ul><p><strong>快速重传</strong></p><p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它不以时间为驱动，⽽是以数据驱动重传。</p><p>它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。</p><p>可以用它来解决超时重发的时间等待问题，快速重传流程如下：</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033685703.png" alt="1657033685703"></p><p>在上图，发送⽅发出了 1，2，3，4，5 份数据：</p><ul><li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li>发送端收到了三个 <strong>Ack &#x3D; 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><p>快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。</p><p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p><p>根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。</p><p>为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。</p><p><strong>带选择确认的重传（SACK）</strong></p><p>为了解决应该重传多少个包的问题? TCP 提供了<strong>带选择确认的重传</strong>（即 SACK，Selective Acknowledgment）。</p><p><strong>SACK 机制</strong>就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033741917.png" alt="1657033741917"></p><p>如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。</p><p><strong>重复 SACK（D-SACK）</strong></p><p>D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。</p><p>DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p><p>例如ACK丢包导致的数据包重复：</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033787704.png" alt="1657033787704"></p><ul><li>接收⽅发给发送⽅的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~</li></ul><p>3499）</p><ul><li>于是接收⽅发现数据是重复收到的，于是回了⼀个 <strong>SACK &#x3D; 3000~3500</strong>，告诉「发送⽅」 3000~3500的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个SACK 就代表着 D-SACK 。这样发送⽅就知道了，数据没有丢，是接收⽅的 ACK 确认报⽂丢了。</li></ul><h3 id="29-说说TCP-的粘包和拆包？"><a href="#29-说说TCP-的粘包和拆包？" class="headerlink" title="29.说说TCP 的粘包和拆包？"></a>29.说说TCP 的粘包和拆包？</h3><p><strong>什么是TCP粘包和拆包？</strong></p><p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被 TCP 拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的 TCP 粘包和拆包问题。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657034152293.png" alt="1657034152293"></p><p><strong>为什么会产生粘包和拆包呢?</strong></p><ul><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li></ul><p><strong>如何解决粘包和拆包呢?</strong></p><ul><li>发送端将每个数据包封装为固定长度</li><li>在数据尾部增加特殊字符进行分割</li><li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li></ul><h3 id="30-说说-TCP-和-UDP-的区别？"><a href="#30-说说-TCP-和-UDP-的区别？" class="headerlink" title="30.说说 TCP 和 UDP 的区别？"></a>30.说说 TCP 和 UDP 的区别？</h3><p>最根本区别：<strong>TCP 是面向连接，而 UDP 是无连接</strong>。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657034396605.png" alt="1657034396605"></p><p><strong>说说TCP和UDP的应用场景？</strong></p><p><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、收发邮件、远程登录。</p><p><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</p><h3 id="31-为什么QQ采用UDP协议？"><a href="#31-为什么QQ采用UDP协议？" class="headerlink" title="31.为什么QQ采用UDP协议？"></a>31.为什么QQ采用UDP协议？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657034519504.png" alt="1657034519504"></p><ul><li>首先，QQ并不是完全基于UDP实现。比如在使用QQ进行文件传输等活动的时候，就会使用TCP作为可靠传输的保证。</li><li>使用UDP进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP是一个全双工协议，需要建立连接，所以网络开销也会相对大。</li><li>如果使用QQ语音和QQ视频的话，UDP的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li><li>由于QQ的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务</li></ul><p>简单总结一下：UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。</p><h3 id="32-UDP协议为什么不可靠？"><a href="#32-UDP协议为什么不可靠？" class="headerlink" title="32.UDP协议为什么不可靠？"></a>32.UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><h3 id="33-DNS为什么要用UDP"><a href="#33-DNS为什么要用UDP" class="headerlink" title="33.DNS为什么要用UDP?"></a>33.DNS为什么要用UDP?</h3><p>更准确地说，DNS既使用TCP又使用UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而TCP允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的TCP。</p><p>当客户端想DNS服务器查询域名（域名解析）的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节，用UDP传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><h3 id="34-IP-协议的定义和作用？"><a href="#34-IP-协议的定义和作用？" class="headerlink" title="34.IP 协议的定义和作用？"></a>34.IP 协议的定义和作用？</h3><p><strong>IP协议是什么？</strong></p><p>IP协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在<strong>网际层</strong>，主要目的就是为了提高网络的可扩展性。</p><p>通过<strong>网际协议IP</strong>，可以把参与互联的，性能各异的网络<strong>看作一个统一的网络</strong>。</p><p>和传输层TCP相比，IP协议是一种无连接&#x2F;不可靠、尽力而为的数据包传输服务，和TCP协议一起构成了TCP&#x2F;IP协议的核心。</p><p><strong>IP协议有哪些作用？</strong></p><p>IP协议主要有以下几个作用：</p><ul><li><strong>寻址和路由</strong>：在IP数据报中携带源IP地址和目的IP地址来表示该数据包的源主机和目标主机。IP数据报在传输过程中，每个中间节点（IP网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP协议根据路由选择协议提供的路由信息对IP数据报进行转发，直至目标主机。</li><li><strong>分段和重组</strong>：IP数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP协议通过给每个IP数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的IP数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的IP数据报。</li></ul><p><strong>传输层协议和网络层协议有什么区别？</strong></p><p>网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。</p><h3 id="35-IP-地址有哪些分类？"><a href="#35-IP-地址有哪些分类？" class="headerlink" title="35.IP 地址有哪些分类？"></a>35.IP 地址有哪些分类？</h3><p>一个IP地址在这个互联网范围内是唯一的，一般可以这么认为，IP 地址 &#x3D; {&lt;网络号&gt;，&lt;主机号&gt;}</p><ol><li><strong>网络号</strong>：它标志主机所连接的网络地址表示属于互联网的哪一个网络。</li><li><strong>主机号</strong>：它标志主机地址表示其属于该网络中的哪一台主机</li></ol><p>IP 地址分为 A，B，C，D，E 五大类：</p><ul><li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。</li><li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。</li><li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。</li><li>D 类地址 (224~239)：以 1110 开头，保留为多播地址。</li><li>E 类地址 (240~255)：以 1111开头，保留位为将来使用</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657072903791.png" alt="1657072903791"></p><h3 id="36-域名和-IP-的关系？一个-IP-可以对应多个域名吗？"><a href="#36-域名和-IP-的关系？一个-IP-可以对应多个域名吗？" class="headerlink" title="36.域名和 IP 的关系？一个 IP 可以对应多个域名吗？"></a>36.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</h3><ul><li>IP地址在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号</li><li>域名在同一个网络中也是唯一的，就像是一个人的名字、绰号</li></ul><p>假如你有多个不用的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是惟一的。但同时你的绰号也可能和别人重复，假如你不在，有人叫你的绰号，其它人可能就答应了。</p><p>一个域名可以对应多个IP，但这种情况DNS做负载均衡的，在用户访问过程中，一个域名只能对应一个IP。</p><p>而一个IP却可以对应多个域名，是一对多的关系。</p><h3 id="37-IPV4-地址不够如何解决？"><a href="#37-IPV4-地址不够如何解决？" class="headerlink" title="37.IPV4 地址不够如何解决？"></a>37.IPV4 地址不够如何解决？</h3><p>我们知道，IP地址有32位，可以标记2的32次方个地址，听起来很多，但是全球的网络设备数量已经远远超过这个数字，所以IPV4地址已经不够用了，那怎么解决呢？</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657073285959.png" alt="1657073285959"></p><ul><li><p>DHCP：动态主机配置协议，动态分配IP地址，只给接入网络的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，该协议使得空闲的IP地址可以得到充分利用。</p></li><li><p>CIDR：无类别域间路由。CIDR消除了传统的A类、B类、C类地址以及划分子网的概念，因而更加有效地分配IPv4的地址空间，但无法从根本上解决地址耗尽的问题。CIDR使用 CIDR 前缀的值指定地址中作为网络 ID 的位数，  这个前缀可以位于地址空间的任何位置，让管理者能够以更灵活的方式定义子网，以简便的形式指定地址中网络 ID 部分和主机 ID 部分。</p><p>CIDR 标记使用一个斜线<code>/</code>分隔符，后面跟一个十进制数值表示地址中网络部分所占的位数。例如，205.123.196.183&#x2F;25 中的 25 表示地址中 25 位用于网络 ID，相应的掩码为 255.255.255.128。  </p></li><li><p>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的IP地址，从而一定程度上缓解了IP资源枯竭的问题，然而主机在局域网中使用的IP地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT方法可以将该主机IP地址转换为全球IP地址。该协议能够有效解决IP地址不足的问题。</p></li><li><p>IPv6：作为接替IPv4的下一代互联网协议，其可以实现2的128次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个IP地址也够用，该协议能够从根本上解决IPv4地址不够用的问题。</p></li></ul><h3 id="38-说下-ARP-协议的工作过程？"><a href="#38-说下-ARP-协议的工作过程？" class="headerlink" title="38.说下 ARP 协议的工作过程？"></a>38.说下 ARP 协议的工作过程？</h3><p>ARP 协议，<strong>Address Resolution Protocol</strong>，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657073516743.png" alt="1657073516743"></p><ul><li>首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</li><li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</li><li>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。</li><li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li></ul><p><strong>跨网段通信</strong></p><hr><p>不同网段的主机通信时，主机会封装网关（通常是路由器）的mac地址，然后主机将数据发送给路由器，后续路由进行路由转发，通过ARP解析目标地址的mac地址，然后将数据包送达目的地。具体过程分析如下：</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657075972489.png" alt="1657075972489"></p><ol><li>主机A有数据发往主机B，数据封装的时候发现没有主机B的mac地址，需要查询本机ARP列表，发现自身不存在，于是计算目标地址发现和自身不属于同一个网段，因此需要使用默认网关，但是自身也不存在默认网关的mac地址，因此需要查询网关的mac地址；、</li><li>主机先把数据放到缓存中，发送ARP查询报文：封装自己的mac地址为源地址，目标mac地址写全F的广播地址，请求网关的mac地址，然后以广播的方式发送出去；</li><li>路由器收到广播的数据包之后，首先把A主机的mac地址添加到自己的mac地址表中，路由发现是请求自己的mac地址，然后会回复一个ARP应答包，封装自己的IP地址为源地址，自己的mac地址为源mac地址，发送一个单播应答</li><li>主机收到应答之后，把网关的mac地址对应网关的IP地址保存下来，并把数据包封装上网关的mac地址进行发送；</li><li>路由器收到数据包之后，检查目的IP地址，查目的IP地址，发现不是给自己的，决定要进行路由，然后查询路由表，需要发往192.168.4.0网段中的192.168.4.2地址。路由准备从相应接口上发出去，然后查询mac地址表，发现没有主机B的映射。路由器发送ARP请求查询主机B的mac地址（原理同2、3步，主机B收到请求后首先会添加网关的mac地址，然后单播回复ARP请求）</li><li>路由器收到主机B的mac地址后，将其添加到路由mac地址表中，然后将缓存中的数据2层帧头去掉，封装自己的mac地址为源mac，主机B的mac地址为目的mac（源和目的IP地址不变），加上二层帧头及校验，发送给主机B；</li><li>主机B收到数据之后，进行处理，发送过程结束</li><li>如果主机B收到数据后进行回复，主机B会进行地址判断，不在同一网段，然后决定将数据发送给网关，主机B查询mac地址表获得网关mac地址，将数据封装后发送（ARP地址解析的过程不再需要了，mac地址表条目有一定的有效时间），网关收到数据后直接查询mac表，将二层帧mac地址更改为A的mac发送出去。如此，主机A收到主机B的回复；</li></ol><h3 id="39-私有IP和公有IP以及NAT网络地址转化协议"><a href="#39-私有IP和公有IP以及NAT网络地址转化协议" class="headerlink" title="39.私有IP和公有IP以及NAT网络地址转化协议"></a>39.私有IP和公有IP以及NAT网络地址转化协议</h3><p>IP地址可以分为私有IP和公有IP，出现这种规划的原因在于IPv4可以表示的IP太少，但是电脑太多导致IP不够用，只有公有IP可以直接连接上网络，对于一些公司、学校、政府都是集中使用私有IP来进行管理，大家在一个局域网使用私有IP，共同使用一个公有IP，这样可以有效解决IP地址不足的问题，而私有地址和公有地址的转换就是使用的NAT网络地址转换协议</p><p>早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些企业内部的网络设定，于是就有了私有IP (Private IP) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段，那就是：</p><ul><li>Class A：10.0.0.0    - 10.255.255.255</li><li>Class B：172.16.0.0  - 172.31.255.255</li><li>Class C：192.168.0.0 - 192.168.255.255</li></ul><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657075298841.png" alt="1657075298841"></p><h3 id="40-为什么既有IP地址，又有MAC-地址？"><a href="#40-为什么既有IP地址，又有MAC-地址？" class="headerlink" title="40.为什么既有IP地址，又有MAC 地址？"></a>40.为什么既有IP地址，又有MAC 地址？</h3><p><strong>MAC地址和IP地址都有什么作用？</strong></p><ul><li>MAC地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li><li>IP地址是网络层和以上各层使用的地址，是一种逻辑地址。IP地址用来区别网络上的计算机。</li></ul><p><strong>为什么有了MAC地址还需要IP地址？</strong></p><p>如果我们只使用MAC地址进行寻址的话，我们需要路由器记住每个MAC地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的MAC地址。而我们知道MAC地址的长度为48位，也就是最多共有2的48次方个MAC地址，这就意味着每个路由器需要256T的内存，显然是不现实的。</p><p>和MAC地址不同，IP地址是和地域相关的，在一个子网中的设备，我们给其分配的IP地址前缀都是一样的，这样路由器就能根据IP地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p><p><strong>为什么有了IP地址还需要MAC地址？</strong></p><ul><li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配IP地址，在设备还没有IP地址的时候，或者在分配IP的过程中。我们需要MAC地址来区分不同的设备。</li><li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li></ul><p><a href="https://www.zhihu.com/question/21546408%EF%BC%88%E4%B8%80%E7%AF%87%E8%BF%98%E4%B8%8D%E9%94%99%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89">https://www.zhihu.com/question/21546408（一篇还不错的介绍）</a></p><h3 id="41-ICMP、IGMP"><a href="#41-ICMP、IGMP" class="headerlink" title="41.ICMP、IGMP"></a>41.ICMP、IGMP</h3><p><strong>ICMP</strong></p><hr><p>ICMP（Internet Control Message Protocol） ，网际控制报文协议。</p><p>ICMP工作在TCP&#x2F;IP体系中的网络层，是IP协议的一个补充，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。ICMP报文通常被IP层或更高层协议(TCP或UDP)使用。<strong>ICMP报文是在IP数据报内部传输的</strong>。IP协议是不可靠协议，不能保证 IP数据报能够成功的到达目的主机，无法进行差错控制，当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657089869782.png" alt="1657089869782"></p><ul><li>类型：一个<strong>8位</strong>类型字段，表示 ICMP 数据包类型；</li><li>代码：一个<strong>8位</strong>代码域，表示指定类型中的一个功能，如果一个类型中只有一种功能，代码域置为 0；</li><li>检验和：数据包中 ICMP 部分上的一个<strong>16位</strong>检验和；</li><li>ICMP数据部分：包含了所有接受到的数据报的<strong>IP报头</strong>，还包含IP数据报中<strong>前8个字节</strong>的数据。</li></ul><p>8位类型和8位代码字段一起决定了ICMP报文的类型。</p><p>16位的检验和字段：包括数据在内的整个ICMP数据包的检验和，其计算方法和IP头部检验和的计算方法一样的。</p><p>ICMP报文具体分<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>(对ICMP差错报文有时需要做特殊处理，因此要对其进行区分。如：对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文，否则会出现死循环)。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657090051507.png" alt="1657090051507"></p><ul><li><strong>终点不可达：</strong>IP路由器无法将IP数据报发送给目的地址时，会给发送端主机返回一个终点不可达ICMP消息。例如我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回Type&#x3D;3、Code&#x3D;3的ICMP报文，它要告诉我们：“嘿，别连接了，我不在家的！”，常见的不可到达类型还有网络不可到达（Code&#x3D;0）、主机不可到达（Code&#x3D;1）、协议不可到达（Code&#x3D;2）等。</li><li><strong>时间超过：</strong>超时报文的代码域有两种取值：Code&#x3D;0表示传输超时，Code&#x3D;1表示重组分段超时。 IP 数据包中有一个字段TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减1，当路由器收到生存时间TTL为零的数据报时，除丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送时间超过报文。</li><li><strong>参数问题：</strong>当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文。</li><li><strong>改变路由（重定向）：</strong>如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个ICMP 重定向消息给这个主机，<strong>这个消息包含了最合适的路由信息和源数据</strong>。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个ICMP 重定向消息给发送端主机一个更合适的发送路由。</li><li><strong>回送消息：</strong>用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。我们日常使用最多的ping，就是响应请求（Type&#x3D;8）和应答（Type&#x3D;0），一台主机向一个节点发送一个Type&#x3D;8的ICMP报文，如果途中没有异常（例如被路由器丢弃、目标不回应ICMP或传输失败），则目标返回Type&#x3D;0的ICMP报文，说明这台主机存在。</li><li><strong>时间戳消息</strong>：时间戳请求报文（Type&#x3D;13）和时间戳应答报文（Type&#x3D;14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接收方收到请求后填充接收时间戳后以Type&#x3D;14的报文格式返回，发送方计算这个时间差。一些系统不响应这种报文。</li></ul><p>以下几种情况都不会导致产生ICMP差错报文：</p><ul><li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）；</li><li>目的地址是广播地址或多播地址的IP数据报；</li><li>作为链路层广播的数据报；</li><li>不是IP分片的第一片；</li><li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址。</li></ul><p><strong>IGMP</strong></p><hr><p>IGMP也是IP协议的一个补充，位于TCP&#x2F;IP体系中的网络层。</p><ol><li><p><strong>单播：</strong>单播是说，对特定的主机进行数据传送。例如给某一个主机发送IP数据包。这时候，数据链路层给出的数据头里面是非常具体的目的地址，对于以太网来 说，就是网卡的MAC地址。现在的具有路由功能的主机应该可以将单播数据定向转发，而目的主机的网络接口则可以过滤掉和自己MAC地址不一致的数据。</p></li><li><p><strong>广播：</strong>广播是主机针对某一个网络上的所有主机发送数据包。这个网络可能是网络，可能是子网，还可能是所有的子网。如果是网络，例如A类网址的广播就是 netid.255.255.255，如果是子网，则是netid.netid.subnetid.255；如果是所有的子网（B类IP）则是则是 netid.netid.255.255。广播所用的MAC地址FF-FF-FF-FF-FF-FF。网络内所有的主机都会收到这个广播数据，网卡只要把 MAC地址为FF-FF-FF-FF-FF-FF的数据交给内核就可以了。一般说来ARP，或者路由协议RIP应该是以广播的形式播发的。</p></li><li><p><strong>多播：</strong>可以说广播是多播的特例，多播就是给一组特定的主机（多播组）发送数据，这样，数据的播发范围会小一些(实际上播发的范围一点也没有变小)，多播的MAC地址是最高字节的低位为一，例 如01-00-00-00-00-00。<strong>多播组的地址是D类IP，规定是224.0.0.0-239.255.255.255。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</span><br><span class="line">224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；</span><br><span class="line">224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</span><br><span class="line">239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。</span><br></pre></td></tr></table></figure><p>虽然多播比较特殊，但是究其原理，多播的数据还是要通过数据链路层进行MAC地址绑定然后进行发送。所以一个以太网卡在绑定了一个多播IP地址之后，必 定还要绑定一个多播的MAC地址，才能使得其可以像单播那样工作。这个多播的IP和多播MAC地址有一个对应的算法。可以看到 这个对应不是一一对应的，主机还是要对多播数据进行过滤。</p><p>PS:广播和多播的性质是一样的，路由器会把数据放到局域网里面，然后网卡对这些数据进行过滤，只拿到自己打算要的数据，比如自己感兴趣的多 播数据，自己感兴趣的组播数据。当一个主机运行了一个处理某一个多播IP的进程的时候，这个进程会给网卡绑定一个虚拟的多播mac地址，并做出来一个多播 ip。这样，网卡就会让带有这个多播mac地址的数据进来，从而实现通信，而那些没有监听这些数据的主机就会把这些数据过滤掉。</p></li></ol><p><strong>组播IP地址和MAC地址的关系</strong></p><p>以太网组播地址范围是从01-00-5E-00-00-00到01-00-5E-7F-FF-FF。组播MAC地址的高24bit位是以01-00-5E开头，低23bit为组播IP地址的低23bit。<br> 由于IP组播地址的高4bit是1110，标识了组播组，而低28bit中只有23bit被映像到组播MAC地址上，这样IP组播地址中就会有5bit没有使用，从而出现了32个IP组播地址映像到同一MAC地址上的结果。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657091703878.png" alt="1657091703878"></p><p>IGMP，就是Internet Group Management Protocol的意思。该协议用来在IP主机和与其直接相邻的组播路由器之间建立、维护<strong>组播组成员</strong>关系，但不包括组播路由器之间的组成员关系信息的传播与维护，这部分工作由各组播路由协议完成。所有参与组播的主机必须实现IGMP。</p><p><strong>1.加入一个多播组</strong></p><p>多播的基础就是一个进程的概念（使用的术语进程是指操作系统执行的一个程序），该进程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的—它随时因进程加入和离开多播组而变化。</p><p>这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何API所必需的部分。使用限定词“接口”是因为多播组中的成员是与接口相关联的。一个进程可以在多个接口上加入同一多播组。</p><p><strong>2.IGMP报告和查询</strong></p><p>多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p><ol><li>当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</li><li>进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</li><li>多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。</li><li>主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。</li></ol><p>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p><p>下图显示了两个IGMP报文，一个是主机发送的报告，另一个是路由器发送的查询。该路由器正在要求那个接口上的每个主机说明它加入的每个多播组。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657091845051.png" alt="1657091845051"></p><p><strong>3.离开报文（仅限IGMPv2和v3）</strong></p><p>该报文由主机发出。当主机离开组播组时发送此报文，向组播路由器报告离开了特定的组播组。离开报文的目标IP为224.0.0.2（所有组播路由器），IGMP报头内的组播IP为特定离开组的IP。</p><p><strong>实现细节</strong></p><p>为改善IGMP协议的效率，有许多实现的细节要考虑。首先，当一个主机首次发送IGMP报告（当第一个进程加入一个多播组）时，并不保证该报告被可靠接收（因为使用的是IP交付服务）。下一个报告将在间隔一段时间后发送。这个时间间隔由主机在0 ~ 1 0秒的范围内随机选择。</p><p>其次，当一个主机收到一个从路由器发出的查询后，并不立即响应，而是经过一定的时间间隔后才发出一些响应（采用“响应”的复数形式是因为该主机必须对它参加的每个组均发送一个响应）。既然参加同一多播组的多个主机均能发送一个报告，可将它们的发送间隔设置为随机时延。在一个物理网络中的所有主机将收到同组其他主机发送的所有报告，报告中的目的地址是那个组地址。这意味着如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组，而只关心该组是否还至少拥有一个主机。的确，一个多播路由器甚至不关心哪个主机属于一个多播组。它仅仅想知道在给定的接口上的多播组中是否还至少有一个主机。</p><p>在没有任何多播路由器的单个物理网络中，仅有的IGMP通信量就是在主机加入一个新的多播组时，支持IP多播的主机所发出的报告。</p><h3 id="42-Ping的原理"><a href="#42-Ping的原理" class="headerlink" title="42.Ping的原理"></a>42.Ping的原理</h3><p>ping，<strong>Packet Internet Groper</strong>，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP&#x2F;IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079949682.png" alt="1657079949682"></p><p>一般来说，ping 可以用来检测网络通不通。它是基于<code>ICMP</code>协议工作的。假设<strong>机器 A</strong> ping <strong>机器 B</strong>，工作过程如下：</p><ol><li>ping 通知系统，新建一个固定格式的 ICMP 请求数据包</li><li>ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层</li><li>IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包</li><li>先获取目标机器 B 的 MAC 地址。</li><li>数据链路层构建一个数据帧，目的地址是 IP 层传过来的 <strong>MAC 地址</strong>，源地址是本机的 <strong>MAC 地址</strong></li><li>机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。</li><li>根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间</li><li>最终显示结果有这几项：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值</li></ol><h3 id="43-SSH和telnet的区别？"><a href="#43-SSH和telnet的区别？" class="headerlink" title="43.SSH和telnet的区别？"></a>43.SSH和telnet的区别？</h3><p><strong>telnet</strong></p><hr><ul><li>Telnet取名自Telecommunications和Networks的联合缩写，这是一种在UNIX平台上最为人所熟知的网络协议。</li><li>Telnet使用端口23，它是专门为局域网设计的。</li><li>Telnet不是一种安全通信协议，因为它并不使用任何安全机制，通过网络&#x2F;互联网传输明文格式的数据，包括密码，所以谁都能嗅探数据包。</li><li>Telnet中没有使用任何验证策略及数据加密方法，因而带来了巨大的安全威胁，这就是为什么telnet不再用于通过公共网络访问网络设备和服务器。</li></ul><p><strong>SSH</strong></p><hr><ul><li>Telnet取名自Telecommunications和Networks的联合缩写，这是一种在UNIX平台上最为人所熟知的网络协议。</li><li>Telnet使用端口23，它是专门为局域网设计的。</li><li>Telnet不是一种安全通信协议，因为它并不使用任何安全机制，通过网络&#x2F;互联网传输明文格式的数据，包括密码，所以谁都能嗅探数据包。</li><li>Telnet中没有使用任何验证策略及数据加密方法，因而带来了巨大的安全威胁，这就是为什么telnet不再用于通过公共网络访问网络设备和服务器。</li></ul><p><strong>区别</strong></p><hr><ul><li>（1) SSH 和 Telnet 应用领域基本重合。</li><li>（2) SSH 比 Telnet 更加安全。</li><li>（3) 在发送数据时，SSH会对数据加密，而Telnet不会（它会直接发送明文，包括密码）。</li><li>（4) SSH使用公钥授权，而Telnet不使用任何授权。</li><li>（5) 在带宽上，SSH 会比Telnet多一点点开销。</li><li>（6) SSH 几乎在所有场合代替了Telnet。</li></ul><h3 id="44-UDP是如何实现可靠传输的？"><a href="#44-UDP是如何实现可靠传输的？" class="headerlink" title="44.UDP是如何实现可靠传输的？"></a>44.UDP是如何实现可靠传输的？</h3><p>UDP将可靠传输的实现放到了应用层，然后类似于TCP，实现确认机制，重传机制<br>UDP不属于连接型协议，因而具有消耗资源小，处理速度快等优点，所以通常音频、视频通话在传送时使用UDP比较多，因为它们即使丢失一两个数据包也不会对结果产生太大影响<br>UDP传输层无法保证数据的可靠传输，只能通过应用层来实现了；实现的方式可以参考TCP可靠传输的方式，只是实现不在传输层，转移到了应用层<br>目前有如下开源程序利用UDP实现了可靠的数据传输；分别有RUDP, RTP, UDT</p><p>UDT的主要目的是支持高速广域网上的海量数据传输，所以除了在UDP之上实现类似TCP的协议和算法之外，UDT还对TCP的拥塞算法做了一些细节上的调整，包括Negative-ACK(NAK)、ACK to ACK(ACK2)、基于对数的动态AIMD等。不过UDT的重传效率较低，无效报文，实际效果并不理想。</p><h3 id="45-SSL-x2F-TLS-协议"><a href="#45-SSL-x2F-TLS-协议" class="headerlink" title="45.SSL&#x2F;TLS 协议"></a>45.SSL&#x2F;TLS 协议</h3><h3 id="46-路由选择协议介绍"><a href="#46-路由选择协议介绍" class="headerlink" title="46.路由选择协议介绍"></a>46.路由选择协议介绍</h3><h1 id="网络安全知识点整理"><a href="#网络安全知识点整理" class="headerlink" title="网络安全知识点整理"></a>网络安全知识点整理</h1><h3 id="1-说说有哪些安全攻击？"><a href="#1-说说有哪些安全攻击？" class="headerlink" title="1.说说有哪些安全攻击？"></a>1.说说有哪些安全攻击？</h3><p>网络安全攻击主要分为两种类型，<strong>被动攻击</strong>和<strong>主动攻击</strong>：</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657077818854.png" alt="1657077818854"></p><p><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。</p><p>主动攻击</p><p>：直接对现有的数据和服务造成影响，常见的主动攻击类型有： </p><ul><li><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</li><li><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</li><li><strong>拒绝服务Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</li></ul><h3 id="2-DNS劫持了解吗？"><a href="#2-DNS劫持了解吗？" class="headerlink" title="2.DNS劫持了解吗？"></a>2.DNS劫持了解吗？</h3><p>DNS劫持即域名劫持，是通过将原域名对应的IP地址进行替换，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657077861431.png" alt="1657077861431"></p><p>域名劫持往往只能在特定的网络范围内进行，范围外的DNS服务器能够返回正常的IP地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它主持，并将新的域名信息保存在所指定的DNS服务器中，从而使用户无法对原域名来进行解析以访问目标地址。</p><p><strong>DNS劫持的步骤是什么样的？</strong></p><p>获取要劫持的域名信息：攻击者会首先访问域名查询要劫持的站点的域名信息。</p><p>控制域名响应的E-Mail账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的E-mail账号所对应的密码，更高级的攻击者甚至能够直接对E-Mail进行信息窃取。</p><p>修改注册信息：当攻击者破解了E-Mail后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS服务器信息等。</p><p>使用E-Mail收发确认函：在修改完注册信息后，攻击者E-Mail在真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成DNS劫持。</p><p><strong>怎么应对DNS劫持？</strong></p><ul><li>直接通过IP地址访问网站，避开DNS劫持</li><li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让DNS指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选DNS服务器的地址固定为8.8.8.8（Google DNS）。</li></ul><h3 id="3-对称加密与非对称加密有什么区别？"><a href="#3-对称加密与非对称加密有什么区别？" class="headerlink" title="3.对称加密与非对称加密有什么区别？"></a>3.对称加密与非对称加密有什么区别？</h3><p><strong>对称加密</strong>：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078035772.png" alt="1657078035772"></p><p><strong>非对称加密</strong>：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078050380.png" alt="1657078050380"></p><h3 id="4-RSA和AES区别？"><a href="#4-RSA和AES区别？" class="headerlink" title="4.RSA和AES区别？"></a>4.RSA和AES区别？</h3><p><strong>RSA</strong></p><p>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，由于需要大数的乘幂求模等运算，其运算速度较慢，不合适大量数据文件加密。</p><p><strong>AES</strong></p><p>采用对称加密的方式，其秘钥长度最长只有256个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p><h3 id="5-什么是XSS攻击，如何避免？"><a href="#5-什么是XSS攻击，如何避免？" class="headerlink" title="5.什么是XSS攻击，如何避免？"></a>5.什么是XSS攻击，如何避免？</h3><p>XSS 攻击是比较常见，XSS，叫<strong>跨站脚本攻击（Cross-Site Scripting）</strong>，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览网页的时候，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。</p><p>XSS 攻击一般分三种类型：<strong>存储型 、反射型 、DOM 型 XSS</strong></p><p><strong>XSS 是如何攻击的呢？</strong></p><p>简单说，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p><p>拿反射型举个例子吧，流程图如下：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，访问正常网站服务器</li><li>网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，请求恶意服务器，发送用户数据</li><li>攻击者就可以窃取用户的数据，以此冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078333259.png" alt="1657078333259"></p><h3 id="6-什么是-DoS、DDoS、DRDoS-攻击？"><a href="#6-什么是-DoS、DDoS、DRDoS-攻击？" class="headerlink" title="6.什么是 DoS、DDoS、DRDoS 攻击？"></a>6.什么是 DoS、DDoS、DRDoS 攻击？</h3><ul><li><p><strong>DOS</strong>: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起拒绝 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有<strong>计算机网络宽带攻击</strong>、<strong>连通性攻击</strong>。</p></li><li><p><strong>DDoS</strong>: (Distributed Denial of Service)，翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器，并利用这些机器对受害者同时实施攻击。</p><p>主要形式有流量攻击和资源耗尽攻击，常见的 DDoS攻击有： <strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong> 等。</p></li><li><p><strong>DRDoS</strong>: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。</p></li></ul><p><strong>如何防范DDoS?</strong></p><p>针对DDoS中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p><p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的SYN攻击包。我们也可以安装专业的抗DDoS防火墙，从而对抗SYN Flood等流量型攻击</p><h3 id="7-什么是-CSRF-攻击？如何避免？"><a href="#7-什么是-CSRF-攻击？如何避免？" class="headerlink" title="7.什么是 CSRF 攻击？如何避免？"></a>7.什么是 CSRF 攻击？如何避免？</h3><p><strong>什么是 CSRF 攻击？</strong></p><p>CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><p><strong>CSRF 是如何攻击的呢？</strong></p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078683791.png" alt="1657078683791"></p><p>用户登陆银行，没有退出，浏览器包含了 用户 在银行的身份认证信息。</p><p>攻击者将伪造的转账请求，包含在在帖子</p><p>用户在银行网站保持登陆的情况下，浏览帖子</p><p>将伪造的转账请求连同身份认证信息，发送到银行网站</p><p>银行网站看到身份认证信息，以为就是 用户的合法操作，最后造成用户资金损失。</p><p><strong>怎么应对 CSRF 攻击呢？</strong></p><ul><li><strong>检查 Referer 字段</strong>：HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</li><li><strong>添加校验 token</strong>：以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li><li><strong>敏感操作多重校验</strong>：对一些敏感的操作，除了需要校验用户的认证信息，还可以通过邮箱确认、验证码确认这样的方式多重校验。</li></ul><h3 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8.数字签名"></a>8.数字签名</h3><p>先说数字签名的基本原理。数字签名过程跟加密通信有着一定的对称性，这种对称有着一种逻辑上的美。</p><p>加密通信是用公钥进行加密，而用私钥进行解密。而数字签名刚好相反，是采用私钥加密，公钥解密。对于加密通信，公钥加密过程就是通过加密算法把信息加密成密文，私钥解密过程就是通过解密算法解密密文。而对于数字签名，私钥加密过程是通过签名算法来生成数字签名的过程，而公钥解密过程是通过验证算法来确定数字签名是不是有私钥持有者签署的。可以看到，加密算法，解密算法，签名算法，验证算法，对称性是很明显的。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079095355.png" alt="1657079095355"></p><p>数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息，输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是“签名 key”，公钥是“验证 key”。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079169348.png" alt="1657079169348"></p><p><strong>实例：</strong></p><p>Alice 要签署一个文件，于是她就拿出自己的私钥，执行签名算法，得到数字签名。那么其他人如何去验证这个数字签名的确出自 Alice 呢？首先，Alice 要把自己的公钥放到一个大家都可以访问到的服务器上，这样其他人都可以获得 Alice 的公钥，大家把文件，数字签名以及公钥下载到自己的计算机上，调用验证算法，就可以判断这个文件是不是 Alice 签署的了。不管是签名算法还是验证算法都是全球公开的，每个人都可以在自己的计算机上安装软件来执行这两个算法。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079290506.png" alt="1657079290506"></p><p>这就是一个 Alice 签署文件，其他人验证签名的完整过程了。这个过程中有一点要注意，就是签名本身是不会加密文件本身的。在底层，签名过程其实是加密了文件的哈希值，总之签名的目的不在于加密文件信息，而在于生成数字签名。</p><p><strong>数字签名的作用</strong></p><p>数字签名有三大作用，第一个是认证，第二个是防止抵赖，第三个是保证文件完整性，也就是没有被篡改过。</p><p>先看第一个认证，意思就是确认签署人身份，这个跟纸笔签名的作用是一致的。再看第二个防止抵赖，同样是纸笔签名也拥有的特性，一份合同签署了，就要承担责任，白纸黑字，不能耍赖。第三个作用是保证文件没有被篡改过，这个作用纸笔签名很难保证，比如签名只签署了最后一页，那么如果有人想悄悄换掉了前几页的内容，签名本身是阻止不了的。但是数字签名就可以，因为数字签名是由两个输入运算得出的，一个是私钥，另一个就是文件，所以如果在验证过程中，发现文件有改动，验证会失败。这个很类似于现实世界签合同的时候，有时候需要故意用签名或者图章覆盖有文字的区域，或者在写信的时候，给信封加上蜡封，这些措施也都是为了防篡改。</p><p>这就是数字签名的三大作用，主要用在各种防伪造场合，在世界上很多国家，数字签名都是有法律效力的。另外要注意，数字签名属于电子签名的一种，但并不是所有的电子签名都是数字签名，这两个概念要区分一下。</p><h3 id="9-数字证书"><a href="#9-数字证书" class="headerlink" title="9.数字证书"></a>9.数字证书</h3><p>为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。</p><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943844348.png" alt="1656943844348"></p><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li><li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li><p>⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；</p></li><li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate</p><p>Signature 内容，得到⼀个 Hash 值 H2 ；</p></li><li><p>最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p></li></ul><p>假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI七层模式 </tag>
            
            <tag> TCP/IP模式 </tag>
            
            <tag> 五层体系接收 </tag>
            
            <tag> HTTP </tag>
            
            <tag> FTP </tag>
            
            <tag> SMTP </tag>
            
            <tag> DNS </tag>
            
            <tag> URL </tag>
            
            <tag> 根域名服务器 </tag>
            
            <tag> org域名服务器 </tag>
            
            <tag> edu域名服务器 </tag>
            
            <tag> ack </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
            <tag> Socket </tag>
            
            <tag> 洪范攻击 </tag>
            
            <tag> HTTP状态码 </tag>
            
            <tag> GET和POST </tag>
            
            <tag> Session </tag>
            
            <tag> Cookie </tag>
            
            <tag> TCP </tag>
            
            <tag> IP </tag>
            
            <tag> URI </tag>
            
            <tag> 拥塞控制 </tag>
            
            <tag> 重传机制 </tag>
            
            <tag> TCP和UDP </tag>
            
            <tag> ICMP </tag>
            
            <tag> IGMP </tag>
            
            <tag> XSS </tag>
            
            <tag> Ping </tag>
            
            <tag> 数字签名 </tag>
            
            <tag> SSL </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark内核</title>
      <link href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/"/>
      <url>/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Spark内核概述"><a href="#1-Spark内核概述" class="headerlink" title="1. Spark内核概述"></a>1. Spark内核概述</h2><h3 id="1-1-Spark核心组件"><a href="#1-1-Spark核心组件" class="headerlink" title="1.1 Spark核心组件"></a>1.1 Spark核心组件</h3><p><strong>Driver</strong></p><p>​Spark驱动器节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：</p><ol><li><p>将用户程序转化为作业（Job）；</p></li><li><p>在Executor之间调度任务（Task）；</p></li><li><p>跟踪Executor的执行情况；</p></li><li><p>通过UI展示查询运行情况；</p></li></ol><p><strong>Executor</strong></p><p>​Spark Executor对象是负责在Spark作业中运行具体任务，任务彼此之间相互独立。Spark 应用启动时，ExecutorBackend节点被同时启动，并且始终伴随着整个Spark应用的生命周期而存在。如果有ExecutorBackend节点发生了故障或崩溃，Spark应用也可以继续执行，会将出错节点上的任务调度到其他Executor节点上继续运行。</p><p>Executor有两个核心功能：</p><ol><li><p>负责运行组成Spark应用的任务，并将结果返回给驱动器（Driver）；</p></li><li><p>它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p></li></ol><h3 id="1-2-Spark通用运行流程概述"><a href="#1-2-Spark通用运行流程概述" class="headerlink" title="1.2 Spark通用运行流程概述"></a>1.2 Spark通用运行流程概述</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662781886696.png" alt="1662781886696"></p><p>​上图为Spark通用运行流程图，体现了基本的Spark应用程序在部署中的基本提交流程。</p><p>这个流程是按照如下的核心步骤进行工作的：</p><ol><li><p>任务提交后，都会先启动Driver程序；</p></li><li><p>随后Driver向集群管理器注册应用程序；</p></li><li><p>之后集群管理器根据此任务的配置文件分配Executor并启动；</p></li><li><p>Driver开始执行main函数，Spark查询为懒执行，当执行到Action算子时开始反向推算，根据宽依赖进行Stage的划分，随后每一个Stage对应一个Taskset，Taskset中有多个Task，查找可用资源Executor进行调度；</p></li><li><p>根据本地化原则，Task会被分发到指定的Executor去执行，在任务执行的过程中，Executor也会不断与Driver进行通信，报告任务运行情况。</p></li></ol><p>​上述图中还存在一个问题，上述执行逻辑中，是资源满足之后才会执行main函数，其实main中需要准备一些配置等信息，才会去申请资源等信息，所以存在一些问题</p><h2 id="2-Spark部署模式"><a href="#2-Spark部署模式" class="headerlink" title="2. Spark部署模式"></a>2. Spark部署模式</h2><h3 id="2-1-YARN-Cluster模式"><a href="#2-1-YARN-Cluster模式" class="headerlink" title="2.1 YARN Cluster模式"></a>2.1 YARN Cluster模式</h3><h4 id="2-1-Cluster模式"><a href="#2-1-Cluster模式" class="headerlink" title="2.1 Cluster模式"></a>2.1 Cluster模式</h4><ol><li><p>执行脚本提交任务，实际是启动一个SparkSubmit的JVM进程；</p></li><li><p>SparkSubmit类中的main方法反射调用YarnClusterApplication的main方法；</p></li><li><p>YarnClusterApplication创建Yarn客户端，然后向Yarn服务器发送执行指令：bin&#x2F;java ApplicationMaster；</p></li><li><p>Yarn框架收到指令后会在指定的NM中启动ApplicationMaster；</p></li><li><p>ApplicationMaster启动Driver线程，执行用户的作业；</p></li><li><p>AM向RM注册，申请资源；</p></li><li><p>获取资源后AM向NM发送指令：bin&#x2F;java YarnCoarseGrainedExecutorBackend；</p></li><li><p>CoarseGrainedExecutorBackend进程会接收消息，跟Driver通信，注册已经启动的Executor；然后启动计算对象Executor等待接收任务</p></li><li><p>Driver线程继续执行完成作业的调度和任务的执行。</p></li><li><p>Driver分配任务并监控任务的执行。</p></li></ol><p><strong>注意：SparkSubmit、ApplicationMaster和CoarseGrainedExecutorBackend是独立的进程；Driver是独立的线程；Executor和YarnClusterApplication是对象。</strong></p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662782335938.png" alt="1662782335938"></p><h4 id="2-2-Client模式"><a href="#2-2-Client模式" class="headerlink" title="2.2 Client模式"></a>2.2 Client模式</h4><p>​该模式尽量不要使用，他和Cluster的区别在于Driver端存在的位置，Client模式会把Driver放到本机中去执行，Cluster会再某一个NodeManager之中选择创建ApplicationMaster，然后再APPMaster之中创建一个线程，就是Driver，但是client的电脑性能较低，集群中的executor都需要与Dirver进行交互，这样有极大的可能造成雪崩。因此我们一般使用Cluster模式。</p><p>​</p><ol><li><p>执行脚本提交任务，实际是启动一个SparkSubmit的JVM进程；</p></li><li><p>SparkSubmit类中的main方法反射调用用户代码的main方法；</p></li><li><p>启动Driver线程，执行用户的作业，并创建ScheduleBackend；</p></li><li><p>YarnClientSchedulerBackend向RM发送指令：bin&#x2F;java ExecutorLauncher；</p></li><li><p>Yarn框架收到指令后会在指定的NM中启动ExecutorLauncher（实际上还是调用ApplicationMaster的main方法）；</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ExecutorLauncher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">ApplicationMaster</span>.main(args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>AM向RM注册，申请资源；</p></li><li><p>获取资源后AM向NM发送指令：bin&#x2F;java CoarseGrainedExecutorBackend；</p></li><li><p>CoarseGrainedExecutorBackend进程会接收消息，跟Driver通信，注册已经启动的Executor；然后启动计算对象Executor等待接收任务</p></li><li><p>Driver分配任务并监控任务的执行。</p></li></ol><p><strong>注意：SparkSubmit、ApplicationMaster和YarnCoarseGrainedExecutorBackend是独立的进程；Executor和Driver是对象。</strong></p><h3 id="2-2-Standalone-模式"><a href="#2-2-Standalone-模式" class="headerlink" title="2.2 Standalone 模式"></a>2.2 Standalone 模式</h3><h4 id="2-2-1-Standalone-Cluster模式"><a href="#2-2-1-Standalone-Cluster模式" class="headerlink" title="2.2.1 Standalone  Cluster模式"></a>2.2.1 Standalone  Cluster模式</h4><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662782536754.png" alt="1662782536754"></p><p>​在Standalone Cluster模式下，任务提交后，Master会找到一个Worker启动Driver。Driver启动后向Master注册应用程序，Master根据submit脚本的资源需求找到内部资源至少可以启动一个Executor的所有Worker，然后在这些Worker之间分配Executor，Worker上的Executor启动后会向Driver反向注册，所有的Executor注册完成后，Driver开始执行main函数，之后执行到Action算子时，开始划分Stage，每个Stage生成对应的taskSet，之后将Task分发到各个Executor上执行。</p><h4 id="2-2-2-Standalone-Client模式"><a href="#2-2-2-Standalone-Client模式" class="headerlink" title="2.2.2 Standalone  Client模式"></a>2.2.2 Standalone  Client模式</h4><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662782564006.png" alt="1662782564006"></p><p>​在Standalone Client模式下，Driver在任务提交的本地机器上运行。Driver启动后向Master注册应用程序，Master根据submit脚本的资源需求找到内部资源至少可以启动一个Executor的所有Worker，然后在这些Worker之间分配Executor，Worker上的Executor启动后会向Driver反向注册，所有的Executor注册完成后，Driver开始执行main函数，之后执行到Action算子时，开始划分Stage，每个Stage生成对应的TaskSet，之后将Task分发到各个Executor上执行。</p><h2 id="3-Spark通信架构"><a href="#3-Spark通信架构" class="headerlink" title="3. Spark通信架构"></a>3. Spark通信架构</h2><h3 id="3-1-Spark通信架构概述"><a href="#3-1-Spark通信架构概述" class="headerlink" title="3.1 Spark通信架构概述"></a>3.1 Spark通信架构概述</h3><p>Spark中通信框架的发展：</p><ul><li><p>Spark早期版本中采用Akka作为内部通信部件。</p></li><li><p>Spark1.3中引入Netty通信框架，为了解决Shuffle的大数据传输问题使用</p></li><li><p>Spark1.6中Akka和Netty可以配置使用。Netty完全实现了Akka在Spark中的功能。</p></li><li><p>Spark2系列中，Spark抛弃Akka，使用Netty。</p></li></ul><p>Spark2.x版本使用Netty通讯框架作为内部通讯组件。Spark 基于Netty新的RPC框架借鉴了Akka的中的设计，它是基于Actor模型，如下图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662793541559.png" alt="1662793541559"></p><p>Spark通讯框架中各个组件（Client&#x2F;Master&#x2F;Worker）可以认为是一个个独立的实体，各个实体之间通过消息来进行通信。具体各个组件之间的关系图如下</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662793573641.png" alt="1662793573641"></p><h3 id="3-2-Spark通信架构解析"><a href="#3-2-Spark通信架构解析" class="headerlink" title="3.2 Spark通信架构解析"></a>3.2 Spark通信架构解析</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662794291110.png" alt="1662794291110"></p><ul><li><p>RpcEndpoint：RPC通信终端。Spark针对每个节点（Client&#x2F;Master&#x2F;Worker）都称之为一个RPC终端，且都实现RpcEndpoint接口，内部根据不同端点的需求，设计不同的消息和不同的业务处理，如果需要发送（询问）则调用Dispatcher。在Spark中，所有的终端都存在生命周期：</p><ul><li><p>Constructor</p></li><li><p>onStart</p></li><li><p>receive*</p></li><li><p>onStop</p></li></ul></li><li><p>RpcEnv：RPC上下文环境，每个RPC终端运行时依赖的上下文环境称为RpcEnv；在把当前Spark版本中使用的NettyRpcEnv</p></li><li><p>Dispatcher：消息调度（分发）器，针对于RPC终端需要发送远程消息或者从远程RPC接收到的消息，分发至对应的指令收件箱（发件箱）。如果指令接收方是自己则存入收件箱，如果指令接收方不是自己，则放入发件箱；</p></li><li><p>Inbox：指令消息收件箱。一个本地RpcEndpoint对应一个收件箱，Dispatcher在每次向Inbox存入消息时，都将对应EndpointData加入内部ReceiverQueue中，另外Dispatcher创建时会启动一个单独线程进行轮询ReceiverQueue，进行收件箱消息消费；</p></li><li><p>RpcEndpointRef：RpcEndpointRef是对远程RpcEndpoint的一个引用。当我们需要向一个具体的RpcEndpoint发送消息时，一般我们需要获取到该RpcEndpoint的引用，然后通过该应用发送消息。</p></li><li><p>OutBox：指令消息发件箱。对于当前RpcEndpoint来说，一个目标RpcEndpoint对应一个发件箱，如果向多个目标RpcEndpoint发送信息，则有多个OutBox。当消息放入Outbox后，紧接着通过TransportClient将消息发送出去。消息放入发件箱以及发送过程是在同一个线程中进行；</p></li><li><p>RpcAddress：表示远程的RpcEndpointRef的地址，Host + Port。</p></li><li><p>TransportClient：Netty通信客户端，一个OutBox对应一个TransportClient，TransportClient不断轮询OutBox，根据OutBox消息的receiver信息，请求对应的远程TransportServer；</p></li><li><p>TransportServer：Netty通信服务端，一个RpcEndpoint对应一个TransportServer，接受远程消息后调用Dispatcher分发消息至对应收发件箱；</p></li></ul><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662792867862.png" alt="1662792867862"></p><h2 id="4-Spark任务调度机制"><a href="#4-Spark任务调度机制" class="headerlink" title="4. Spark任务调度机制"></a>4. Spark任务调度机制</h2><p>​在生产环境下，Spark集群的部署方式一般为YARN-Cluster模式，之后的内核分析内容中我们默认集群的部署方式为YARN-Cluster模式。在上一章中我们讲解了Spark YARN-Cluster模式下的任务提交流程，但是我们并没有具体说明Driver的工作流程， Driver线程主要是初始化SparkContext对象，准备运行所需的上下文，然后一方面保持与ApplicationMaster的RPC连接，通过ApplicationMaster申请资源，另一方面根据用户业务逻辑开始调度任务，将任务下发到已有的空闲Executor上。</p><p>​当ResourceManager向ApplicationMaster返回Container资源时，ApplicationMaster就尝试在对应的Container上启动Executor进程，Executor进程起来后，会向Driver反向注册，注册成功后保持与Driver的心跳，同时等待Driver分发任务，当分发的任务执行完毕后，将任务状态上报给Driver。</p><h3 id="4-1-Spark调度概述"><a href="#4-1-Spark调度概述" class="headerlink" title="4.1 Spark调度概述"></a>4.1 Spark调度概述</h3><p>当Driver起来后，Driver则会根据用户程序逻辑准备任务，并根据Executor资源情况逐步分发任务。在详细阐述任务调度前，首先说明下Spark里的几个概念。一个Spark应用程序包括Job、Stage以及Task三个概念：</p><ol><li><p>Job是以Action方法为界，遇到一个Action方法则触发一个Job；</p></li><li><p>Stage是Job的子集，以RDD宽依赖(即Shuffle)为界，遇到Shuffle做一次划分；</p></li><li><p>Task是Stage的子集，以并行度(分区数)来衡量，分区数是多少，则有多少个task。</p></li></ol><p>Spark的任务调度总体来说分两路进行，一路是Stage级的调度，一路是Task级的调度，总体调度流程如下图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796146622.png" alt="1662796146622"></p><p>Spark RDD通过其Transactions操作，形成了RDD血缘（依赖）关系图，即DAG，最后通过Action的调用，触发Job并调度执行，执行过程中会创建两个调度器：DAGScheduler和TaskScheduler。</p><ul><li><p>DAGScheduler负责Stage级的调度，主要是将job切分成若干Stages，并将每个Stage打包成TaskSet交给TaskScheduler调度。</p></li><li><p>TaskScheduler负责Task级的调度，将DAGScheduler给过来的TaskSet按照指定的调度策略分发到Executor上执行，调度过程中SchedulerBackend负责提供可用资源，其中SchedulerBackend有多种实现，分别对接不同的资源管理系统。</p></li></ul><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796171132.png" alt="1662796171132"></p><p>​Driver初始化SparkContext过程中，会分别初始化DAGScheduler、TaskScheduler、SchedulerBackend以及HeartbeatReceiver，并启动SchedulerBackend以及HeartbeatReceiver。SchedulerBackend通过ApplicationMaster申请资源，并不断从TaskScheduler中拿到合适的Task分发到Executor执行。HeartbeatReceiver负责接收Executor的心跳信息，监控Executor的存活状况，并通知到TaskScheduler。</p><h3 id="4-2-Stage调度"><a href="#4-2-Stage调度" class="headerlink" title="4.2 Stage调度"></a>4.2 Stage调度</h3><p>​Spark的任务调度是从DAG切割开始，主要是由DAGScheduler来完成。当遇到一个Action操作后就会触发一个Job的计算，并交给DAGScheduler来提交，下图是涉及到Job提交的相关方法调用流程图。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796215480.png" alt="1662796215480"></p><ol><li><p>Job由最终的RDD和Action方法封装而成；</p></li><li><p>SparkContext将Job交给DAGScheduler提交，它会根据RDD的血缘关系构成的DAG进行切分，将一个Job划分为若干Stages，具体划分策略是，由最终的RDD不断通过依赖回溯判断父依赖是否是宽依赖，即以Shuffle为界，划分Stage，窄依赖的RDD之间被划分到同一个Stage中，可以进行pipeline式的计算。划分的Stages分两类，一类叫做ResultStage，为DAG最下游的Stage，由Action方法决定，另一类叫做ShuffleMapStage，为下游Stage准备数据，下面看一个简单的例子WordCount。</p></li></ol><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796229819.png" alt="1662796229819"></p><p>​Job由saveAsTextFile触发，该Job由RDD-3和saveAsTextFile方法组成，根据RDD之间的依赖关系从RDD-3开始回溯搜索，直到没有依赖的RDD-0，在回溯搜索过程中，RDD-3依赖RDD-2，并且是宽依赖，所以在RDD-2和RDD-3之间划分Stage，RDD-3被划到最后一个Stage，即ResultStage中，RDD-2依赖RDD-1，RDD-1依赖RDD-0，这些依赖都是窄依赖，所以将RDD-0、RDD-1和RDD-2划分到同一个Stage，形成pipeline操作，。即ShuffleMapStage中，实际执行的时候，数据记录会一气呵成地执行RDD-0到RDD-2的转化。不难看出，其本质上是一个深度优先搜索（Depth First Search）算法。</p><p>​一个Stage是否被提交，需要判断它的父Stage是否执行，只有在父Stage执行完毕才能提交当前Stage，如果一个Stage没有父Stage，那么从该Stage开始提交。Stage提交时会将Task信息（分区信息以及方法等）序列化并被打包成TaskSet交给TaskScheduler，一个Partition对应一个Task，另一方面TaskScheduler会监控Stage的运行状态，只有Executor丢失或者Task由于Fetch失败才需要重新提交失败的Stage以调度运行失败的任务，其他类型的Task失败会在TaskScheduler的调度过程中重试。</p><p>​相对来说DAGScheduler做的事情较为简单，仅仅是在Stage层面上划分DAG，提交Stage并监控相关状态信息。TaskScheduler则相对较为复杂，下面详细阐述其细节。</p><h3 id="4-3-task级调度"><a href="#4-3-task级调度" class="headerlink" title="4.3 task级调度"></a>4.3 task级调度</h3><p>​Spark Task的调度是由TaskScheduler来完成，由前文可知，DAGScheduler将Stage打包到交给TaskScheTaskSetduler，TaskScheduler会将TaskSet封装为TaskSetManager加入到调度队列中，TaskSetManager结构如下图所示。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796267431.png" alt="1662796267431"></p><p>​TaskSetManager负责监控管理同一个Stage中的Tasks，TaskScheduler就是以TaskSetManager为单元来调度任务。</p><p>​前面也提到，TaskScheduler初始化后会启动SchedulerBackend，它负责跟外界打交道，接收Executor的注册信息，并维护Executor的状态，所以说SchedulerBackend是管“粮食”的，同时它在启动后会定期地去“询问”TaskScheduler有没有任务要运行，也就是说，它会定期地“问”TaskScheduler“我有这么余粮，你要不要啊”，TaskScheduler在SchedulerBackend“问”它的时候，会从调度队列中按照指定的调度策略选择TaskSetManager去调度运行，大致方法调用流程如下图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796291094.png" alt="1662796291094"></p><p>​上图中，将TaskSetManager加入rootPool调度池中之后，调用SchedulerBackend的riviveOffers方法给driverEndpoint发送ReviveOffer消息；driverEndpoint收到ReviveOffer消息后调用makeOffers方法，过滤出活跃状态的Executor（这些Executor都是任务启动时反向注册到Driver的Executor），然后将Executor封装成WorkerOffer对象；准备好计算资源（WorkerOffer）后，taskScheduler基于这些资源调用resourceOffer在Executor上分配task。</p><h4 id="4-3-1-调度策略"><a href="#4-3-1-调度策略" class="headerlink" title="4.3.1 调度策略"></a>4.3.1 调度策略</h4><p>TaskScheduler支持两种调度策略，一种是FIFO，也是默认的调度策略，另一种是FAIR。在TaskScheduler初始化过程中会实例化rootPool，表示树的根节点，是Pool类型。</p><ol><li>FIFO调度策略</li></ol><p>如果是采用FIFO调度策略，则直接简单地将TaskSetManager按照先来先到的方式入队，出队时直接拿出最先进队的TaskSetManager，其树结构如下图所示，TaskSetManager保存在一个FIFO队列中。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796335654.png" alt="1662796335654"></p><ol start="2"><li>FAIR调度策略</li></ol><p>FAIR调度策略的树结构如下图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796352169.png" alt="1662796352169"></p><p>​FAIR模式中有一个rootPool和多个子Pool，各个子Pool中存储着所有待分配的TaskSetMagager。</p><p>​在FAIR模式中，需要先对子Pool进行排序，再对子Pool里面的TaskSetMagager进行排序，因为Pool和TaskSetMagager都继承了Schedulable特质，因此使用相同的排序算法。</p><p>​排序过程的比较是基于Fair-share来比较的，每个要排序的对象包含三个属性: runningTasks值（正在运行的Task数）、minShare值、weight值，比较时会综合考量runningTasks值，minShare值以及weight值。</p><p>​注意，minShare、weight的值均在公平调度配置文件fairscheduler.xml中被指定，调度池在构建阶段会读取此文件的相关配置。</p><ol><li><p>如果A对象的runningTasks大于它的minShare，B对象的runningTasks小于它的minShare，那么B排在A前面；（runningTasks比minShare小的先执行）</p></li><li><p>如果A、B对象的runningTasks都小于它们的minShare，那么就比较runningTasks与minShare的比值（minShare使用率），谁小谁排前面；（minShare使用率低的先执行）</p></li><li><p>如果A、B对象的runningTasks都大于它们的minShare，那么就比较runningTasks与weight的比值（权重使用率），谁小谁排前面。（权重使用率低的先执行）</p></li><li><p>如果上述比较均相等，则比较名字。</p></li></ol><p>​整体上来说就是通过minShare和weight这两个参数控制比较过程，可以做到让minShare使用率和权重使用率少（实际运行task比例较少）的先运行。</p><p>​FAIR模式排序完成后，所有的TaskSetManager被放入一个ArrayBuffer里，之后依次被取出并发送给Executor执行。</p><p>​从调度队列中拿到TaskSetManager后，由于TaskSetManager封装了一个Stage的所有Task，并负责管理调度这些Task，那么接下来的工作就是TaskSetManager按照一定的规则一个个取出Task给TaskScheduler，TaskScheduler再交给SchedulerBackend去发到Executor上执行。</p><h4 id="4-3-2-本地化调度"><a href="#4-3-2-本地化调度" class="headerlink" title="4.3.2 本地化调度"></a>4.3.2 本地化调度</h4><p>​DAGScheduler切割Job，划分Stage, 通过调用submitStage来提交一个Stage对应的tasks，submitStage会调用submitMissingTasks，submitMissingTasks 确定每个需要计算的 task 的preferredLocations，通过调用getPreferrdeLocations()得到partition 的优先位置，由于一个partition对应一个Task，此partition的优先位置就是task的优先位置，对于要提交到TaskScheduler的TaskSet中的每一个Task，该task优先位置与其对应的partition对应的优先位置一致。</p><p>​从调度队列中拿到TaskSetManager后，那么接下来的工作就是TaskSetManager按照一定的规则一个个取出task给TaskScheduler，TaskScheduler再交给SchedulerBackend去发到Executor上执行。前面也提到，TaskSetManager封装了一个Stage的所有Task，并负责管理调度这些Task。</p><p>​根据每个Task的优先位置，确定Task的Locality级别，Locality一共有五种，优先级由高到低顺序：</p><table><thead><tr><th>名称</th><th>解析</th></tr></thead><tbody><tr><td>PROCESS_LOCAL</td><td>进程本地化，task和数据在同一个Executor中，性能最好。</td></tr><tr><td>NODE_LOCAL</td><td>节点本地化，task和数据在同一个节点中，但是task和数据不在同一个Executor中，数据需要在进程间进行传输。</td></tr><tr><td>RACK_LOCAL</td><td>机架本地化，task和数据在同一个机架的两个节点上，数据需要通过网络在节点之间进行传输。</td></tr><tr><td>NO_PREF</td><td>对于task来说，从哪里获取都一样，没有好坏之分。</td></tr><tr><td>ANY</td><td>task和数据可以在集群的任何地方，而且不在一个机架中，性能最差。</td></tr></tbody></table><p>​在调度执行时，Spark调度总是会尽量让每个task以最高的本地性级别来启动，当一个task以X本地性级别启动，但是该本地性级别对应的所有节点都没有空闲资源而启动失败，此时并不会马上降低本地性级别启动而是在某个时间长度内再次以X本地性级别来启动该task，若超过限时时间则降级启动，去尝试下一个本地性级别，依次类推。</p><p>​可以通过调大每个类别的最大容忍延迟时间，在等待阶段对应的Executor可能就会有相应的资源去执行此task，这就在在一定程度上提到了运行性能。</p><h4 id="4-3-3-失败重传和黑名单机制"><a href="#4-3-3-失败重传和黑名单机制" class="headerlink" title="4.3.3 失败重传和黑名单机制"></a>4.3.3 失败重传和黑名单机制</h4><p>​除了选择合适的Task调度运行外，还需要监控Task的执行状态，前面也提到，与外部打交道的是SchedulerBackend，Task被提交到Executor启动执行后，Executor会将执行状态上报给SchedulerBackend，SchedulerBackend则告诉TaskScheduler，TaskScheduler找到该Task对应的TaskSetManager，并通知到该TaskSetManager，这样TaskSetManager就知道Task的失败与成功状态，对于失败的Task，会记录它失败的次数，如果失败次数还没有超过最大重试次数，那么就把它放回待调度的Task池子中，否则整个Application失败。</p><p>​在记录Task失败次数过程中，会记录它上一次失败所在的Executor Id和Host，这样下次再调度这个Task时，会使用黑名单机制，避免它被调度到上一次失败的节点上，起到一定的容错作用。黑名单记录Task上一次失败所在的Executor Id和Host，以及其对应的“拉黑”时间，“拉黑”时间是指这段时间内不要再往这个节点上调度这个Task了。</p><h2 id="5-Spark-shuffle-解析"><a href="#5-Spark-shuffle-解析" class="headerlink" title="5. Spark shuffle 解析"></a>5. Spark shuffle 解析</h2><h3 id="5-1-ShuffleMapStage与ResultStage"><a href="#5-1-ShuffleMapStage与ResultStage" class="headerlink" title="5.1 ShuffleMapStage与ResultStage"></a>5.1 ShuffleMapStage与ResultStage</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796806091.png" alt="1662796806091"></p><p>​在划分stage时，最后一个stage称为finalStage，它本质上是一个ResultStage对象，前面的所有stage被称为ShuffleMapStage。</p><p>​ShuffleMapStage的结束伴随着shuffle文件的写磁盘。</p><p>​ResultStage基本上对应代码中的action算子，即将一个函数应用在RDD的各个partition的数据集上，意味着一个job的运行结束。</p><h3 id="5-2-HashShuffle解析"><a href="#5-2-HashShuffle解析" class="headerlink" title="5.2 HashShuffle解析"></a>5.2 HashShuffle解析</h3><h4 id="5-2-1-未优化的HashShuffle"><a href="#5-2-1-未优化的HashShuffle" class="headerlink" title="5.2.1 未优化的HashShuffle"></a>5.2.1 未优化的HashShuffle</h4><p>​这里我们先明确一个假设前提：每个Executor只有1个CPU core，也就是说，无论这个Executor上分配多少个task线程，同一时间都只能执行一个task线程。</p><p>​如下图中有3个 Reducer，从Task 开始那边各自把自己进行 Hash 计算(分区器：hash&#x2F;numreduce取模)，分类出3个不同的类别，每个 Task 都分成3种类别的数据，想把不同的数据汇聚然后计算出最终的结果，所以Reducer 会在每个 Task 中把属于自己类别的数据收集过来，汇聚成一个同类别的大集合，每1个 Task 输出3份本地文件，这里有4个 Mapper Tasks，所以总共输出了4个 Tasks x 3个分类文件 &#x3D; 12个本地小文件。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796963811.png" alt="1662796963811"></p><h4 id="5-2-2-优化后的HashShuffle"><a href="#5-2-2-优化后的HashShuffle" class="headerlink" title="5.2.2 优化后的HashShuffle"></a>5.2.2 优化后的HashShuffle</h4><p>​优化的HashShuffle过程就是启用合并机制，合并机制就是复用buffer，开启合并机制的配置是spark.shuffle.consolidateFiles。该参数默认值为false，将其设置为true即可开启优化机制。通常来说，如果我们使用HashShuffleManager，那么都建议开启这个选项。</p><p>​这里还是有4个Tasks，数据类别还是分成3种类型，因为Hash算法会根据你的 Key 进行分类，在同一个进程中，无论是有多少过Task，都会把同样的Key放在同一个Buffer里，然后把Buffer中的数据写入以Core数量为单位的本地文件中，(一个Core只有一种类型的Key的数据)，每1个Task所在的进程中，分别写入共同进程中的3份本地文件，这里有4个Mapper Tasks，所以总共输出是 2个Cores x 3个分类文件 &#x3D; 6个本地小文件。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797077555.png" alt="1662797077555"></p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797358038.png" alt="1662797358038"></p><h3 id="5-3-SortShuffle解析"><a href="#5-3-SortShuffle解析" class="headerlink" title="5.3 SortShuffle解析"></a>5.3 SortShuffle解析</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662798548677.png" alt="1662798548677"></p><h4 id="5-3-1-普通SortShuffle"><a href="#5-3-1-普通SortShuffle" class="headerlink" title="5.3.1 普通SortShuffle"></a>5.3.1 普通SortShuffle</h4><p>​在该模式下，数据会先写入一个数据结构，reduceByKey写入Map，一边通过Map局部聚合，一遍写入内存。Join算子写入ArrayList直接写入内存中。然后需要判断是否达到阈值，如果达到就会将内存数据结构的数据写入到磁盘，清空内存数据结构。</p><p>​在溢写磁盘前，先根据key进行排序，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个Task过程会产生多个临时文件。</p><p>​最后在每个Task中，将所有的临时文件合并，这就是merge过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个Task的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个Task的数据在文件中的索引，start offset和end offset。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797475727.png" alt="1662797475727"></p><h4 id="5-3-2-bypass-SortShuffle"><a href="#5-3-2-bypass-SortShuffle" class="headerlink" title="5.3.2 bypass SortShuffle"></a>5.3.2 bypass SortShuffle</h4><p>​bypass运行机制的触发条件如下：</p><p><strong>1. shuffle reduce task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值，默认为200。</strong></p><p><strong>2. 不是预聚合类的shuffle算子（比如reduceByKey）。</strong></p><p>​此时task会为每个reduce端的task都创建一个临时磁盘文件，并将数据按key进行hash然后根据key的hash值，将key写入对应的磁盘文件之中。当然，写入磁盘文件时也是先写入内存缓冲，缓冲写满之后再溢写到磁盘文件的。最后，同样会将所有临时磁盘文件都合并成一个磁盘文件，并创建一个单独的索引文件。</p><p>​该过程的磁盘写机制其实跟未经优化的HashShuffleManager是一模一样的，因为都要创建数量惊人的磁盘文件，只是在最后会做一个磁盘文件的合并而已。因此少量的最终磁盘文件，也让该机制相对未经优化的HashShuffleManager来说，shuffle read的性能会更好。</p><p>​而该机制与普通SortShuffleManager运行机制的不同在于：不会进行排序。也就是说，启用该机制的最大好处在于，shuffle write过程中，不需要进行数据的排序操作，也就节省掉了这部分的性能开销。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797957056.png" alt="1662797957056"></p><h2 id="6-Spark-内存管理"><a href="#6-Spark-内存管理" class="headerlink" title="6. Spark 内存管理"></a>6. Spark 内存管理</h2><h3 id="6-1-堆内内存和堆外内存规划"><a href="#6-1-堆内内存和堆外内存规划" class="headerlink" title="6.1 堆内内存和堆外内存规划"></a>6.1 堆内内存和堆外内存规划</h3><p>​作为一个JVM 进程，Executor 的内存管理建立在JVM的内存管理之上，Spark对 JVM的堆内（On-heap）空间进行了更为详细的分配，以充分利用内存。同时，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，进一步优化了内存的使用。堆内内存受到JVM统一管理，堆外内存是直接向操作系统进行内存的申请和释放。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662810917491.png" alt="1662810917491"></p><ol><li><p><strong>堆内内存</strong></p><p>​堆内内存的大小，由Spark应用程序启动时的 –executor-memory 或 spark.executor.memory 参数配置。Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存，而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些Spark内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。不同的管理模式下，这三部分占用的空间大小各不相同。</p><p>​Spark对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由JVM完成，Spark只能在申请后和释放前记录这些内存，我们来看其具体流程：</p><p>​申请内存流程如下：</p><p>​Spark 在代码中 new 一个对象实例；</p><p>​JVM 从堆内内存分配空间，创建对象并返回对象引用；</p><p>​Spark 保存该对象的引用，记录该对象占用的内存。</p><p>​释放内存流程如下：</p><p>​Spark记录该对象释放的内存，删除该对象的引用；</p><p>​等待JVM的垃圾回收机制释放该对象占用的堆内内存。</p><p>​我们知道，JVM 的对象可以以序列化的方式存储，序列化的过程是将对象转换为二进制字节流，本质上可以理解为将非连续空间的链式存储转化为连续空间或块存储，在访问时则需要进行序列化的逆过程——反序列化，将字节流转化为对象，序列化的方式可以节省存储空间，但增加了存储和读取时候的计算开销。</p><p>​对于Spark中序列化的对象，由于是字节流的形式，其占用的内存大小可直接计算，而对于非序列化的对象，其占用的内存是通过周期性地采样近似估算而得，即并不是每次新增的数据项都会计算一次占用的内存大小，这种方法降低了时间开销但是有可能误差较大，导致某一时刻的实际内存有可能远远超出预期。此外，在被Spark标记为释放的对象实例，很有可能在实际上并没有被JVM回收，导致实际可用的内存小于Spark记录的可用内存。所以 Spark并不能准确记录实际可用的堆内内存，从而也就无法完全避免内存溢出（OOM, Out of Memory）的异常。</p><p>​虽然不能精准控制堆内内存的申请和释放，但 Spark 通过对存储内存和执行内存各自独立的规划管理，可以决定是否要在存储内存里缓存新的 RDD，以及是否为新的任务分配执行内存，在一定程度上可以提升内存的利用率，减少异常的出现。</p></li><li><p><strong>堆外内存</strong></p><p>​为了进一步优化内存的使用以及提高Shuffle时排序的效率，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。</p><p>​堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。</p><p>​利用JDK Unsafe API（从Spark 2.0开始，在管理堆外的存储内存时不再基于Tachyon，而是与堆外的执行内存一样，基于 JDK Unsafe API 实现），Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过JVM机制，而是直接向操作系统申请，JVM对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。</p><p>​在默认情况下堆外内存并不启用，可通过配置 spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size 参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。</p></li></ol><h3 id="6-2-内存分配"><a href="#6-2-内存分配" class="headerlink" title="6.2 内存分配"></a>6.2 内存分配</h3><p><strong>静态内存管理</strong></p><p>​在Spark最初采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在Spark应用程序运行期间均为固定的，但用户可以应用程序启动前进行配置，堆内内存的分配如图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811152441.png" alt="1662811152441"></p><p>​可以看到，可用的堆内内存的大小需要按照下列方式计算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可用的存储内存 = systemMaxMemory * spark.storage.memoryFraction * spark.storage.safety Fraction</span><br><span class="line">可用的执行内存 = systemMaxMemory * spark.shuffle.memoryFraction * spark.shuffle.safety Fraction</span><br></pre></td></tr></table></figure><p>​其中systemMaxMemory取决于当前JVM堆内内存的大小，最后可用的执行内存或者存储内存要在此基础上与各自的memoryFraction 参数和safetyFraction 参数相乘得出。上述计算公式中的两个 safetyFraction 参数，其意义在于在逻辑上预留出 1-safetyFraction 这么一块保险区域，降低因实际内存超出当前预设范围而导致 OOM 的风险（上文提到，对于非序列化对象的内存采样估算会产生误差）。值得注意的是，这个预留的保险区域仅仅是一种逻辑上的规划，在具体使用时 Spark 并没有区别对待，和”其它内存”一样交给了 JVM 去管理。</p><p>​Storage内存和Execution内存都有预留空间，目的是防止OOM，因为Spark堆内内存大小的记录是不准确的，需要留出保险区域。</p><p>​堆外的空间分配较为简单，只有存储内存和执行内存，如下图所示。可用的执行内存和存储内存占用的空间大小直接由参数spark.memory.storageFraction 决定，由于堆外内存占用的空间可以被精确计算，所以无需再设定保险区域。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811227103.png" alt="1662811227103"></p><p>​静态内存管理机制实现起来较为简单，但如果用户不熟悉Spark的存储机制，或没有根据具体的数据规模和计算任务或做相应的配置，很容易造成”一半海水，一半火焰”的局面，即存储内存和执行内存中的一方剩余大量的空间，而另一方却早早被占满，不得不淘汰或移出旧的内容以存储新的内容。由于新的内存管理机制的出现，这种方式目前已经很少有开发者使用，出于兼容旧版本的应用程序的目的，Spark 仍然保留了它的实现。</p><p><strong>动态内存管理</strong></p><p>​Spark1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域，统一内存管理的堆内内存结构如图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811270969.png" alt="1662811270969"></p><p>​统一内存管理的堆外内存结构如下图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811288550.png" alt="1662811288550"></p><p>其中最重要的优化在于动态占用机制，其规则如下：</p><ol><li><p>设定基本的存储内存和执行内存区域（spark.storage.storageFraction参数），该设定确定了双方各自拥有的空间的范围；</p></li><li><p>双方的空间都不足时，则存储到硬盘；若己方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的Block）</p></li><li><p>执行内存的空间被对方占用后，可让对方将占用的部分转存到硬盘，然后”归还”借用的空间；</p></li><li><p>存储内存的空间被对方占用后，无法让对方”归还”，因为需要考虑 Shuffle过程中的很多因素，实现起来较为复杂。</p></li></ol><p>统一内存管理的动态占用机制如图所示：</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811314259.png" alt="1662811314259"></p><p>​凭借统一内存管理机制，Spark在一定程度上提高了堆内和堆外内存资源的利用率，降低了开发者维护Spark内存的难度，但并不意味着开发者可以高枕无忧。如果存储内存的空间太大或者说缓存的数据过多，反而会导致频繁的全量垃圾回收，降低任务执行时的性能，因为缓存的RDD数据通常都是长期驻留内存的。所以要想充分发挥Spark的性能，需要开发者进一步了解存储内存和执行内存各自的管理方式和实现原理。</p><h3 id="6-3-存储内存管理"><a href="#6-3-存储内存管理" class="headerlink" title="6.3 存储内存管理"></a>6.3 存储内存管理</h3><p><strong>RDD持久化机制</strong></p><p>​弹性分布式数据集（RDD）作为 Spark 最根本的数据抽象，是只读的分区记录（Partition）的集合，只能基于在稳定物理存储中的数据集上创建，或者在其他已有的RDD上执行转换（Transformation）操作产生一个新的RDD。转换后的RDD与原始的RDD之间产生的依赖关系，构成了血统（Lineage）。凭借血统，Spark 保证了每一个RDD都可以被重新恢复。但RDD的所有转换都是惰性的，即只有当一个返回结果给Driver的行动（Action）发生时，Spark才会创建任务读取RDD，然后真正触发转换的执行。</p><p>​Task在启动之初读取一个分区时，会先判断这个分区是否已经被持久化，如果没有则需要检查Checkpoint 或按照血统重新计算。所以如果一个 RDD 上要执行多次行动，可以在第一次行动中使用 persist或cache 方法，在内存或磁盘中持久化或缓存这个RDD，从而在后面的行动时提升计算速度。</p><p>​事实上，cache 方法是使用默认的 MEMORY_ONLY 的存储级别将 RDD 持久化到内存，故缓存是一种特殊的持久化。 堆内和堆外存储内存的设计，便可以对缓存RDD时使用的内存做统一的规划和管理。</p><p>​RDD的持久化由 Spark的Storage模块负责，实现了RDD与物理存储的解耦合。Storage模块负责管理Spark在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来。在具体实现时Driver端和 Executor 端的Storage模块构成了主从式的架构，即Driver端的BlockManager为Master，Executor端的BlockManager 为 Slave。</p><p>​Storage模块在逻辑上以Block为基本存储单位，RDD的每个Partition经过处理后唯一对应一个 Block（BlockId 的格式为rdd_RDD-ID_PARTITION-ID ）。Driver端的Master负责整个Spark应用程序的Block的元数据信息的管理和维护，而Executor端的Slave需要将Block的更新等状态上报到Master，同时接收Master 的命令，例如新增或删除一个RDD。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811414359.png" alt="1662811414359"></p><p>​在对RDD持久化时，Spark规定了MEMORY_ONLY、MEMORY_AND_DISK 等7种不同的存储级别，而存储级别是以下5个变量的组合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class StorageLevel private(</span><br><span class="line">private var _useDisk: Boolean, //磁盘</span><br><span class="line">private var _useMemory: Boolean, //这里其实是指堆内内存</span><br><span class="line">private var _useOffHeap: Boolean, //堆外内存</span><br><span class="line">private var _deserialized: Boolean, //是否为非序列化</span><br><span class="line">private var _replication: Int = 1 //副本个数</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​Spark中7种存储级别如下：</p><table><thead><tr><th><strong>持久化级别</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>MEMORY_ONLY</td><td>以非序列化的Java对象的方式持久化在JVM内存中。如果内存无法完全存储RDD所有的partition，那么那些没有持久化的partition就会在下一次需要使用它们的时候，重新被计算</td></tr><tr><td>MEMORY_AND_DISK</td><td>同上，但是当某些partition无法存储在内存中时，会持久化到磁盘中。下次需要使用这些partition时，需要从磁盘上读取</td></tr><tr><td>MEMORY_ONLY_SER</td><td>同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是需要进行反序列化，因此会加大CPU开销</td></tr><tr><td>MEMORY_AND_DISK_SER</td><td>同MEMORY_AND_DISK，但是使用序列化方式持久化Java对象</td></tr><tr><td>DISK_ONLY</td><td>使用非序列化Java对象的方式持久化，完全存储到磁盘上</td></tr><tr><td>MEMORY_ONLY_2   MEMORY_AND_DISK_2   等等</td><td>如果是尾部加了2的持久化级别，表示将持久化数据复用一份，保存到其他节点，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可</td></tr></tbody></table><p>​通过对数据结构的分析，可以看出存储级别从三个维度定义了RDD的 Partition（同时也就是Block）的存储方式：</p><ul><li><p><strong>存储位置</strong>：磁盘／堆内内存／堆外内存。如MEMORY_AND_DISK是同时在磁盘和堆内内存上存储，实现了冗余备份。OFF_HEAP 则是只在堆外内存存储，目前选择堆外内存时不能同时存储到其他位置。</p></li><li><p><strong>存储形式</strong>：Block 缓存到存储内存后，是否为非序列化的形式。如 MEMORY_ONLY是非序列化方式存储，OFF_HEAP 是序列化方式存储。</p></li><li><p><strong>副本数量</strong>：大于1时需要远程冗余备份到其他节点。如DISK_ONLY_2需要远程备份1个副本。</p></li></ul><p><strong>RDD的缓存过程</strong></p><p>​RDD 在缓存到存储内存之前，Partition中的数据一般以迭代器（<a href="http://www.scala-lang.org/docu/files/collections-api/collections_43.html">Iterator</a>）的数据结构来访问，这是Scala语言中一种遍历数据集合的方法。通过Iterator可以获取分区中每一条序列化或者非序列化的数据项(Record)，这些Record的对象实例在逻辑上占用了JVM堆内内存的other部分的空间，同一Partition的不同 Record 的存储空间并不连续。</p><p>​RDD 在缓存到存储内存之后，Partition 被转换成Block，Record在堆内或堆外存储内存中占用一块连续的空间。将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）。</p><p>​Block 有序列化和非序列化两种存储格式，具体以哪种方式取决于该 RDD 的存储级别。非序列化的Block以一种 DeserializedMemoryEntry 的数据结构定义，用一个数组存储所有的对象实例，序列化的Block则以SerializedMemoryEntry的数据结构定义，用字节缓冲区（ByteBuffer）来存储二进制数据。每个 Executor 的 Storage模块用一个链式Map结构（LinkedHashMap）来管理堆内和堆外存储内存中所有的Block对象的实例，对这个LinkedHashMap新增和删除间接记录了内存的申请和释放。</p><p>​因为不能保证存储空间可以一次容纳 Iterator 中的所有数据，当前的计算任务在 Unroll 时要向 MemoryManager 申请足够的Unroll空间来临时占位，空间不足则Unroll失败，空间足够时可以继续进行。</p><p>​对于序列化的Partition，其所需的Unroll空间可以直接累加计算，一次申请。</p><p>​对于非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的Unroll空间并进行申请，空间不足时可以中断，释放已占用的Unroll空间。</p><p>​如果最终Unroll成功，当前Partition所占用的Unroll空间被转换为正常的缓存 RDD的存储空间，如下图所示。</p><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811529775.png" alt="1662811529775"></p><p>​在静态内存管理时，Spark 在存储内存中专门划分了一块Unroll 空间，其大小是固定的，统一内存管理时则没有对 Unroll 空间进行特别区分，当存储空间不足时会根据动态占用机制进行处理。</p><p><strong>淘汰与落盘</strong></p><p>​由于同一个Executor的所有的计算任务共享有限的存储内存空间，当有新的 Block 需要缓存但是剩余空间不足且无法动态占用时，就要对LinkedHashMap中的旧Block进行淘汰（Eviction），而被淘汰的Block如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该Block。</p><p>存储内存的淘汰规则为：</p><ul><li><p>被淘汰的旧Block要与新Block的MemoryMode相同，即同属于堆外或堆内内存；</p></li><li><p>新旧Block不能属于同一个RDD，避免循环淘汰；</p></li><li><p>旧Block所属RDD不能处于被读状态，避免引发一致性问题；</p></li><li><p>遍历LinkedHashMap中Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新Block所需的空间。其中LRU是LinkedHashMap的特性。</p></li></ul><p>落盘的流程则比较简单，如果其存储级别符合_useDisk为true的条件，再根据其_deserialized判断是否是非序列化的形式，若是则对其进行序列化，最后将数据存储到磁盘，在Storage模块中更新其信息。</p><h3 id="6-4-执行内存管理"><a href="#6-4-执行内存管理" class="headerlink" title="6.4 执行内存管理"></a>6.4 执行内存管理</h3><p>​执行内存主要用来存储任务在执行Shuffle时占用的内存，Shuffle是按照一定规则对RDD数据重新分区的过程，我们来看Shuffle的Write和Read两阶段对执行内存的使用：</p><p><strong>Shuffle Write</strong></p><p>​若在map端选择普通的排序方式，会采用ExternalSorter进行外排，在内存中存储数据时主要占用堆内执行空间。</p><p>​若在map端选择 Tungsten 的排序方式，则采用ShuffleExternalSorter直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。</p><p><strong>Shuffle read</strong></p><p>​在对reduce端的数据进行聚合时，要将数据交给Aggregator处理，在内存中存储数据时占用堆内执行空间。</p><p>​如果需要进行最终结果排序，则要将再次将数据交给ExternalSorter 处理，占用堆内执行空间。</p><p>​在ExternalSorter和Aggregator中，Spark会使用一种叫AppendOnlyMap的哈希表在堆内执行内存中存储数据，但在 Shuffle 过程中所有数据并不能都保存到该哈希表中，当这个哈希表占用的内存会进行周期性地采样估算，当其大到一定程度，无法再从MemoryManager 申请到新的执行内存时，Spark就会将其全部内容存储到磁盘文件中，这个过程被称为溢存(Spill)，溢存到磁盘的文件最后会被归并(Merge)。</p><p>​Shuffle Write 阶段中用到的Tungsten是Databricks公司提出的对Spark优化内存和CPU使用的计划（钨丝计划），解决了一些JVM在性能上的限制和弊端。Spark会根据Shuffle的情况来自动选择是否采用Tungsten排序。</p><p>​Tungsten 采用的页式内存管理机制建立在MemoryManager之上，即 Tungsten 对执行内存的使用进行了一步的抽象，这样在 Shuffle 过程中无需关心数据具体存储在堆内还是堆外。</p><p>​每个内存页用一个MemoryBlock来定义，并用 Object obj 和 long offset 这两个变量统一标识一个内存页在系统内存中的地址。</p><p>​堆内的MemoryBlock是以long型数组的形式分配的内存，其obj的值为是这个数组的对象引用，offset是long型数组的在JVM中的初始偏移地址，两者配合使用可以定位这个数组在堆内的绝对地址；堆外的 MemoryBlock是直接申请到的内存块，其obj为null，offset是这个内存块在系统内存中的64位绝对地址。Spark用MemoryBlock巧妙地将堆内和堆外内存页统一抽象封装，并用页表(pageTable)管理每个Task申请到的内存页。</p><p>​Tungsten 页式管理下的所有内存用64位的逻辑地址表示，由页号和页内偏移量组成：</p><p>​页号：占13位，唯一标识一个内存页，Spark在申请内存页之前要先申请空闲页号。</p><p>​页内偏移量：占51位，是在使用内存页存储数据时，数据在页内的偏移地址。</p><p>​有了统一的寻址方式，Spark 可以用64位逻辑地址的指针定位到堆内或堆外的内存，整个Shuffle Write排序的过程只需要对指针进行排序，并且无需反序列化，整个过程非常高效，对于内存访问效率和CPU使用效率带来了明显的提升。</p><p>​Spark的存储内存和执行内存有着截然不同的管理方式：对于存储内存来说，Spark用一个LinkedHashMap来集中管理所有的Block，Block由需要缓存的 RDD的Partition转化而成；而对于执行内存，Spark用AppendOnlyMap来存储 Shuffle过程中的数据，在Tungsten排序中甚至抽象成为页式内存管理，开辟了全新的JVM内存管理机制。</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> NIO </tag>
            
            <tag> Netty </tag>
            
            <tag> RpcEndpoint </tag>
            
            <tag> 任务划分 </tag>
            
            <tag> 任务的调度 </tag>
            
            <tag> ShuffleMapStage </tag>
            
            <tag> ResultStage </tag>
            
            <tag> SortShuffle </tag>
            
            <tag> bypass SortShuffle </tag>
            
            <tag> HashShuffle </tag>
            
            <tag> Spark内存管理 </tag>
            
            <tag> 堆外内存 </tag>
            
            <tag> Storage </tag>
            
            <tag> Execution </tag>
            
            <tag> 静态内存管理 </tag>
            
            <tag> 动态内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark一个小案例</title>
      <link href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>数据格式：</strong></p><p><img src="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/1662722755369.png" alt="1662722755369"></p><p>​上面的数据图是从数据文件中截取的一部分内容，表示为电商网站的用户行为数据，主要包含用户的4种行为：<strong>搜索，点击，下单，支付</strong>。数据规则如下：</p><ul><li><p>数据文件中每行数据采用下划线分隔数据</p></li><li><p>每一行数据表示用户的一次行为，这个行为只能是4种行为的一种</p></li><li><p>如果搜索关键字为null,表示数据不是搜索数据</p></li><li><p>如果点击的品类ID和产品ID为-1，表示数据不是点击数据</p></li><li><p>针对于下单行为，一次可以下单多个商品，所以品类ID和产品ID可以是多个，id之间采用逗号分隔，如果本次不是下单行为，则数据采用null表示</p></li><li><p>支付行为和下单行为类似</p></li></ul><p>详细字段说明</p><table><thead><tr><th>编号</th><th>字段名称</th><th>字段类型</th><th>字段含义</th></tr></thead><tbody><tr><td>1</td><td>date</td><td>String</td><td>用户点击行为的日期</td></tr><tr><td>2</td><td>user_id</td><td>Long</td><td>用户的ID</td></tr><tr><td>3</td><td>session_id</td><td>String</td><td>Session的ID</td></tr><tr><td>4</td><td>page_id</td><td>Long</td><td>某个页面的ID</td></tr><tr><td>5</td><td>action_time</td><td>String</td><td>动作的时间点</td></tr><tr><td>6</td><td>search_keyword</td><td>String</td><td>用户搜索的关键词</td></tr><tr><td>7</td><td>click_category_id</td><td>Long</td><td>某一个商品品类的ID</td></tr><tr><td>8</td><td>click_product_id</td><td>Long</td><td>某一个商品的ID</td></tr><tr><td>9</td><td>order_category_ids</td><td>String</td><td>一次订单中所有品类的ID集合</td></tr><tr><td>10</td><td>order_product_ids</td><td>String</td><td>一次订单中所有商品的ID集合</td></tr><tr><td>11</td><td>pay_category_ids</td><td>String</td><td>一次支付中所有品类的ID集合</td></tr><tr><td>12</td><td>pay_product_ids</td><td>String</td><td>一次支付中所有商品的ID集合</td></tr><tr><td>13</td><td>city_id</td><td>Long</td><td>城市   id</td></tr></tbody></table><p>样例类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户访问动作表</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVisitAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    date: <span class="type">String</span>,//用户点击行为的日期</span></span></span><br><span class="line"><span class="params"><span class="class">    user_id: <span class="type">Long</span>,//用户的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">    session_id: <span class="type">String</span>,//<span class="type">Session</span>的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">    page_id: <span class="type">Long</span>,//某个页面的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">    action_time: <span class="type">String</span>,//动作的时间点</span></span></span><br><span class="line"><span class="params"><span class="class">    search_keyword: <span class="type">String</span>,//用户搜索的关键词</span></span></span><br><span class="line"><span class="params"><span class="class">    click_category_id: <span class="type">Long</span>,//某一个商品品类的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">    click_product_id: <span class="type">Long</span>,//某一个商品的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">    order_category_ids: <span class="type">String</span>,//一次订单中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">    order_product_ids: <span class="type">String</span>,//一次订单中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">    pay_category_ids: <span class="type">String</span>,//一次支付中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">    pay_product_ids: <span class="type">String</span>,//一次支付中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">    city_id: <span class="type">Long</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>)<span class="comment">//城市 id</span></span></span><br></pre></td></tr></table></figure><p><strong>需求一：Top10热门品类</strong></p><p>​品类是指产品的分类，大型电商网站品类分多级，咱们的项目中品类只有一级，不同的公司可能对热门的定义不一样。我们按照每个品类的点击、下单、支付的量来统计热门品类。</p><p>​鞋                 点击数 下单数  支付数</p><p>​衣服              点击数 下单数  支付数</p><p>​电脑              点击数 下单数  支付数</p><p>​例如，综合排名 &#x3D; 点击数<em>20%+下单数</em>30%+支付数*50%</p><p>​<strong>本项目需求优化为：先按照点击数排名，靠前的就排名高；如果点击数相同，再比较下单数；下单数再相同，就比较支付数。</strong></p><p>实现方案一：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiang.bigdata.spark.wordcount</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Top10&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileData = sc.textFile(<span class="string">&quot;data/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> clickData = fileData</span><br><span class="line">      .filter(data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        datas(<span class="number">6</span>)!=<span class="string">&quot;-1&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .map(data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        (datas(<span class="number">6</span>),<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> orderData = fileData</span><br><span class="line">      .filter(data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        datas(<span class="number">8</span>)!=<span class="string">&quot;null&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .flatMap(data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> orderString: <span class="type">String</span> = datas(<span class="number">8</span>)</span><br><span class="line">        orderString.split(<span class="string">&quot;,&quot;</span>).map(orderId=&gt;&#123;</span><br><span class="line">          (orderId,<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> payData = fileData</span><br><span class="line">      .filter(data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        datas(<span class="number">10</span>)!=<span class="string">&quot;null&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .flatMap(data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> payString: <span class="type">String</span> = datas(<span class="number">10</span>)</span><br><span class="line">        payString.split(<span class="string">&quot;,&quot;</span>).map(payId=&gt;&#123;</span><br><span class="line">          (payId,<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allData: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] = clickData.cogroup(orderData,payData)</span><br><span class="line">    allData</span><br><span class="line">      .map&#123; <span class="keyword">case</span> (cid,(clickIter,orderIter,payIter))=&gt;&#123;</span><br><span class="line">        <span class="keyword">var</span> clickNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> orderNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> payNumber = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> iter1 = clickIter.iterator</span><br><span class="line">        <span class="keyword">if</span>(iter1.hasNext)&#123;</span><br><span class="line">          clickNumber = iter1.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> iter2 = orderIter.iterator</span><br><span class="line">        <span class="keyword">if</span>(iter2.hasNext)&#123;</span><br><span class="line">          orderNumber = iter2.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> iter3 = payIter.iterator</span><br><span class="line">        <span class="keyword">if</span>(iter3.hasNext)&#123;</span><br><span class="line">          payNumber = iter3.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (cid,(clickNumber,orderNumber,payNumber))</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      .sortBy(_._2,<span class="literal">false</span>).take(<span class="number">10</span>).foreach(println(_))</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用户访问动作表</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVisitAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">      date: <span class="type">String</span>,//用户点击行为的日期</span></span></span><br><span class="line"><span class="params"><span class="class">      user_id: <span class="type">Long</span>,//用户的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">      session_id: <span class="type">String</span>,//<span class="type">Session</span>的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">      page_id: <span class="type">Long</span>,//某个页面的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">      action_time: <span class="type">String</span>,//动作的时间点</span></span></span><br><span class="line"><span class="params"><span class="class">      search_keyword: <span class="type">String</span>,//用户搜索的关键词</span></span></span><br><span class="line"><span class="params"><span class="class">      click_category_id: <span class="type">Long</span>,//某一个商品品类的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">      click_product_id: <span class="type">Long</span>,//某一个商品的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">      order_category_ids: <span class="type">String</span>,//一次订单中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">      order_product_ids: <span class="type">String</span>,//一次订单中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">      pay_category_ids: <span class="type">String</span>,//一次支付中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">      pay_product_ids: <span class="type">String</span>,//一次支付中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">      city_id: <span class="type">Long</span> //城市 id</span></span></span><br><span class="line"><span class="params"><span class="class">  </span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方案二：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_Req_HotCategoryTop10_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;HotCategoryTop10&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 需求一 ： Top10热门品类</span></span><br><span class="line">        <span class="comment">// TODO (找茬) :</span></span><br><span class="line">        <span class="comment">// 1. 同一个RDD的重复使用</span></span><br><span class="line">        <span class="comment">// 2. cogroup算子可能性能底下</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 读取文件，获取原始数据</span></span><br><span class="line">        <span class="keyword">val</span> fileDatas = sc.textFile(<span class="string">&quot;data/user_visit_action.txt&quot;</span>)</span><br><span class="line">        <span class="comment">//fileDatas.persist(StorageLevel.MEMORY_AND_DISK)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 统计品类的点击数量</span></span><br><span class="line">        <span class="comment">// 统计分区前需要将不需要的数据过滤掉</span></span><br><span class="line">        <span class="comment">// 先保留所有的点击数据</span></span><br><span class="line">        <span class="keyword">val</span> clickDatas = fileDatas.filter(</span><br><span class="line">            data =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">6</span>)</span><br><span class="line">                cid != <span class="string">&quot;-1&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 对点击数据进行统计</span></span><br><span class="line">        <span class="keyword">val</span> clickCntDatas = clickDatas.map(</span><br><span class="line">            data =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">6</span>)</span><br><span class="line">                (cid, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 统计品类的下单数量</span></span><br><span class="line">        <span class="comment">// 先保留所有的下单数据</span></span><br><span class="line">        <span class="keyword">val</span> orderDatas = fileDatas.filter(</span><br><span class="line">            data =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">8</span>)</span><br><span class="line">                cid != <span class="string">&quot;null&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 对下单数据进行统计</span></span><br><span class="line">        <span class="comment">// (1,2,3,4) =&gt; ((1,2,3,4), 1)</span></span><br><span class="line">        <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">        <span class="comment">// (1,1),(2,1),(3,1),(4,1)</span></span><br><span class="line">        <span class="keyword">val</span> orderCntDatas = orderDatas.flatMap(</span><br><span class="line">            data =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">val</span> cids = cid.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                cids.map((_, <span class="number">1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line">        <span class="comment">// TODO 统计品类的支付数量</span></span><br><span class="line">        <span class="comment">// 先保留所有的支付数据</span></span><br><span class="line">        <span class="keyword">val</span> payDatas = fileDatas.filter(</span><br><span class="line">            data =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">10</span>)</span><br><span class="line">                cid != <span class="string">&quot;null&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 对下单数据进行统计</span></span><br><span class="line">        <span class="keyword">val</span> payCntDatas = payDatas.flatMap(</span><br><span class="line">            data =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> datas = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">                <span class="keyword">val</span> cid = datas(<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">val</span> cids = cid.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">                cids.map((_, <span class="number">1</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        ).reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 对统计结果进行排序 =&gt; Tuple(点击，下单，支付)</span></span><br><span class="line">        <span class="comment">// (品类ID, 点击) =&gt; ( 品类ID, ( 点击，0，0 ) )</span></span><br><span class="line">        <span class="comment">// (品类ID, 下单) =&gt; ( 品类ID, ( 0，下单，0 ) )</span></span><br><span class="line">        <span class="comment">// (品类ID, 支付) =&gt; ( 品类ID, ( 0，0，支付 ))</span></span><br><span class="line">        <span class="comment">// (品类ID, ( 点击，下单，支付 ))</span></span><br><span class="line">        <span class="comment">// 3 =&gt; 1 =&gt; （聚合）</span></span><br><span class="line">        <span class="comment">// reduceByKey</span></span><br><span class="line">        <span class="comment">// (( 点击，下单，支付 ), ( 点击，下单，支付 )) =&gt; ( 点击，下单，支付 )</span></span><br><span class="line">        <span class="keyword">val</span> clickMapDatas = clickCntDatas.map &#123;</span><br><span class="line">            <span class="keyword">case</span> ( cid, cnt ) =&gt; &#123;</span><br><span class="line">                ( cid, (cnt, <span class="number">0</span>, <span class="number">0</span>) )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> orderMapDatas = orderCntDatas.map &#123;</span><br><span class="line">            <span class="keyword">case</span> ( cid, cnt ) =&gt; &#123;</span><br><span class="line">                ( cid, (<span class="number">0</span>, cnt, <span class="number">0</span>) )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> payMapDatas = payCntDatas.map &#123;</span><br><span class="line">            <span class="keyword">case</span> ( cid, cnt ) =&gt; &#123;</span><br><span class="line">                ( cid, (<span class="number">0</span>, <span class="number">0</span>, cnt) )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> unionRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>))] = clickMapDatas.union(orderMapDatas).union(payMapDatas)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> reduceRDD = unionRDD.reduceByKey(</span><br><span class="line">            (t1, t2) =&gt; &#123;</span><br><span class="line">                ( t1._1 + t2._1, t1._2 + t2._2, t1._3 + t2._3 )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> top10 = reduceRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 将结果采集后打印再控制台上</span></span><br><span class="line">        top10.foreach(println)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方案三</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiang.bigdata.spark.wordcount</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Top10&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileData = sc.textFile(<span class="string">&quot;data/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fileData</span><br><span class="line">      .flatMap(data=&gt;&#123;</span><br><span class="line">      <span class="keyword">val</span> strings = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span>(strings(<span class="number">6</span>)!=<span class="string">&quot;-1&quot;</span>)&#123;</span><br><span class="line">        <span class="type">List</span>((strings(<span class="number">6</span>),(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strings(<span class="number">8</span>)!=<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        strings(<span class="number">8</span>)</span><br><span class="line">          .split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">          .map((_,(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)))</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(strings(<span class="number">10</span>)!=<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        strings(<span class="number">10</span>)</span><br><span class="line">          .split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">          .map((_,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)))</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">Nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">      .reduceByKey((t1,t2) =&gt;&#123;</span><br><span class="line">        (t1._1+t2._1,t1._2+t2._2,t1._3+t2._3)</span><br><span class="line">      &#125;)</span><br><span class="line">      .sortBy(_._2,<span class="literal">false</span>)</span><br><span class="line">      .take(<span class="number">10</span>)</span><br><span class="line">      .foreach(println(_))</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需求二：Top10热门品类中每个品类的Top10活跃Session统计</strong></p><p><strong>需求三：页面单跳转换率统计</strong></p><p>​计算页面单跳转化率，什么是页面单跳转换率，比如一个用户在一次 Session 过程中访问的页面路径 3,5,7,9,10,21，那么页面 3 跳到页面 5 叫一次单跳，7-9 也叫一次单跳，那么单跳转化率就是要统计页面点击的概率。</p><p>​比如：计算 3-5 的单跳转化率，先获取符合条件的 Session 对于页面 3 的访问次数（PV）为 A，然后获取符合条件的 Session 中访问了页面 3 又紧接着访问了页面 5 的次数为 B，那么 B&#x2F;A 就是 3-5 的页面单跳转化率。</p><p><img src="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/1662729175397.png" alt="1662729175397"></p><p>​产品经理和运营总监，可以根据这个指标，去尝试分析，整个网站，产品，各个页面的表现怎么样，是不是需要去优化产品的布局；吸引用户最终可以进入最后的支付页面。</p><p>​数据分析师，可以此数据做更深一步的计算和分析。</p><p>​企业管理层，可以看到整个公司的网站，各个页面的之间的跳转的表现如何，可以适当调整公司的经营战略或策略。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiang.bigdata.spark.wordcount</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;Top10&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileData = sc.textFile(<span class="string">&quot;data/user_visit_action.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userData = fileData.map(</span><br><span class="line">      data=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> values = data.split(<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        <span class="type">UserVisitAction</span>(</span><br><span class="line">          values(<span class="number">0</span>),</span><br><span class="line">          values(<span class="number">1</span>).toInt,</span><br><span class="line">          values(<span class="number">2</span>),</span><br><span class="line">          values(<span class="number">3</span>).toInt,</span><br><span class="line">          values(<span class="number">4</span>),</span><br><span class="line">          values(<span class="number">5</span>),</span><br><span class="line">          values(<span class="number">6</span>).toInt,</span><br><span class="line">          values(<span class="number">7</span>).toInt,</span><br><span class="line">          values(<span class="number">8</span>),</span><br><span class="line">          values(<span class="number">9</span>),</span><br><span class="line">          values(<span class="number">10</span>),</span><br><span class="line">          values(<span class="number">11</span>),</span><br><span class="line">          values(<span class="number">12</span>).toInt</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出分母</span></span><br><span class="line">    <span class="keyword">val</span> pageMap = userData</span><br><span class="line">      .map(data=&gt;&#123;</span><br><span class="line">      (data.page_id,<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      .collect().toMap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出分子</span></span><br><span class="line">    <span class="keyword">val</span> pageFenZi = userData</span><br><span class="line">      .groupBy(_.session_id)</span><br><span class="line">      .mapValues(userIter=&gt;&#123;</span><br><span class="line">        <span class="keyword">val</span> sortUsers = userIter.toList.sortBy(_.action_time)</span><br><span class="line">        <span class="keyword">val</span> pageIds = sortUsers.map(_.page_id)</span><br><span class="line">        pageIds.zip(pageIds.tail)</span><br><span class="line">      &#125;)</span><br><span class="line">      .map(_._2)</span><br><span class="line">      .flatMap(list=&gt;list)</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出页面转换率</span></span><br><span class="line">    <span class="keyword">val</span> res = pageFenZi</span><br><span class="line">      .foreach&#123;</span><br><span class="line">        <span class="keyword">case</span> ((id1,id2),cnt) =&gt;&#123;</span><br><span class="line">          println(<span class="string">s&quot;从页面<span class="subst">$&#123;id1&#125;</span>到页面<span class="subst">$&#123;id2&#125;</span>的页面转换率是&quot;</span>,cnt.toDouble/pageMap.getOrElse(id2,<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVisitAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">          date: <span class="type">String</span>,//用户点击行为的日期</span></span></span><br><span class="line"><span class="params"><span class="class">          user_id: <span class="type">Long</span>,//用户的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">          session_id: <span class="type">String</span>,//<span class="type">Session</span>的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">          page_id: <span class="type">Long</span>,//某个页面的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">          action_time: <span class="type">String</span>,//动作的时间点</span></span></span><br><span class="line"><span class="params"><span class="class">          search_keyword: <span class="type">String</span>,//用户搜索的关键词</span></span></span><br><span class="line"><span class="params"><span class="class">          click_category_id: <span class="type">Long</span>,//某一个商品品类的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">          click_product_id: <span class="type">Long</span>,//某一个商品的<span class="type">ID</span></span></span></span><br><span class="line"><span class="params"><span class="class">          order_category_ids: <span class="type">String</span>,//一次订单中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">          order_product_ids: <span class="type">String</span>,//一次订单中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">          pay_category_ids: <span class="type">String</span>,//一次支付中所有品类的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">          pay_product_ids: <span class="type">String</span>,//一次支付中所有商品的<span class="type">ID</span>集合</span></span></span><br><span class="line"><span class="params"><span class="class">          city_id: <span class="type">Long</span> //城市 id</span></span></span><br><span class="line"><span class="params"><span class="class">                            </span>)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> 页面跳转率 </tag>
            
            <tag> 热门品类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark核心编程</title>
      <link href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spark计算框架为了能够进行高并发和高吞吐的数据处理，封装了三大数据结构，用于处理不同的应用场景。三大数据结构分别是：</p><ul><li><p>RDD : 弹性分布式数据集</p></li><li><p>累加器：分布式共享只写变量</p></li><li><p>广播变量：分布式共享只读变量</p></li></ul><p>​接下来我们一起看看这三大数据结构是如何在数据处理中使用的。</p><h2 id="1-RDD"><a href="#1-RDD" class="headerlink" title="1.RDD"></a>1.RDD</h2><h3 id="1-1-什么是RDD？"><a href="#1-1-什么是RDD？" class="headerlink" title="1.1 什么是RDD？"></a>1.1 什么是RDD？</h3><p>​RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p><p>Ø  弹性</p><ul><li><p>存储的弹性：内存与磁盘的自动切换；</p></li><li><p>容错的弹性：数据丢失可以自动恢复；</p></li><li><p>计算的弹性：计算出错重试机制；</p></li><li><p>分片的弹性：可根据需要重新分片。</p></li></ul><p>Ø  分布式：数据存储在大数据集群不同节点上</p><p>Ø  数据集：RDD封装了计算逻辑，并不保存数据</p><p>Ø  数据抽象：RDD是一个抽象类，需要子类具体实现</p><p>Ø  不可变：RDD封装了计算逻辑，是不可以改变的，想要改变，只能产生新的RDD，在新的RDD里面封装计算逻辑</p><p>Ø  可分区、并行计算</p><h3 id="1-2-核心属性"><a href="#1-2-核心属性" class="headerlink" title="1.2 核心属性"></a>1.2 核心属性</h3><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662465977252.png" alt="1662465977252"></p><p><strong>分区列表</strong></p><p>​RDD数据结构中存在分区列表，用于执行任务时并行计算，是实现分布式计算的重要属性</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466046354.png" alt="1662466046354"></p><p><strong>分区计算函数</strong></p><p>​Spark在计算时，是使用分区函数对每一个分区进行计算</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466110963.png" alt="1662466110963"></p><p><strong>RDD之间的依赖关系</strong></p><p>​RDD是计算模型的封装，当需求中需要将多个计算模型进行组合时，就需要将多个RDD建立依赖关系</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466141339.png" alt="1662466141339"></p><p><strong>分区器（可选）</strong></p><p>​当数据为KV类型数据时，可以通过设定分区器自定义数据的分区</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466172151.png" alt="1662466172151"></p><p><strong>首选位置（可选）</strong></p><p>​计算数据时，可以根据计算节点的状态选择不同的节点位置进行计算</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466199888.png" alt="1662466199888"></p><p>这个首选位置的含义：</p><p>当一个task想要分配给某一个executor执行的时候，由于在大数据环境下，我们将会尽可能的把task分配给数据所在的executor之中，因此会给所有可用的executor排序，选最接近数据的那个executor。</p><p>在大数据中，移动数据不如移动计算</p><h3 id="1-3-执行原理"><a href="#1-3-执行原理" class="headerlink" title="1.3 执行原理"></a>1.3 执行原理</h3><p>​从计算的角度来讲，数据处理过程中需要计算资源（内存 &amp; CPU）和计算模型（逻辑）。执行时，需要将计算资源和计算模型进行协调和整合。</p><p>​Spark框架在执行时，先申请资源，然后将应用程序的数据处理逻辑分解成一个一个的计算任务。然后将任务发到已经分配资源的计算节点上, 按照指定的计算模型进行数据计算。最后得到计算结果。</p><p>​RDD是Spark框架中用于数据处理的核心模型，接下来我们看看，在Yarn环境中，RDD的工作原理:</p><ol><li>启动Yarn集群环境</li></ol><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466788800.png" alt="1662466788800"></p><ol start="2"><li>Spark通过申请资源创建调度节点和计算节点</li></ol><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466804123.png" alt="1662466804123"></p><ol start="3"><li>Spark框架根据需求将计算逻辑根据分区划分成不同的任务</li></ol><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466830420.png" alt="1662466830420"></p><ol start="4"><li>调度节点将任务根据计算节点状态发送到对应的计算节点进行计算</li></ol><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662466858344.png" alt="1662466858344"></p><p>​从以上流程可以看出RDD在整个流程中主要用于将逻辑进行封装，并生成Task发送给Executor节点执行计算，接下来我们就一起看看Spark框架中RDD是具体是如何进行数据处理的。</p><h3 id="1-4-基础编程"><a href="#1-4-基础编程" class="headerlink" title="1.4 基础编程"></a>1.4 基础编程</h3><h4 id="1-4-1-RDD的四种创建方式"><a href="#1-4-1-RDD的四种创建方式" class="headerlink" title="1.4.1 RDD的四种创建方式"></a>1.4.1 RDD的四种创建方式</h4><p>​在Spark中创建RDD的创建方式可以分为四种：</p><p><strong>从集合（内存）中创建RDD</strong></p><p>​从集合中创建RDD，<a href="https://www.iteblog.com/archives/tag/spark/">Spark</a>主要提供了两个方法：parallelize和makeRDD</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;spark&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> rdd1 = sparkContext.parallelize(</span><br><span class="line">    <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> rdd2 = sparkContext.makeRDD(</span><br><span class="line">    <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">)</span><br><span class="line">rdd1.collect().foreach(println)</span><br><span class="line">rdd2.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure><p>​从底层代码实现来讲，makeRDD方法其实就是parallelize方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeRDD</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">    seq: <span class="type">Seq</span>[<span class="type">T</span>],</span><br><span class="line">    numSlices: <span class="type">Int</span> = defaultParallelism): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">  parallelize(seq, numSlices)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从文件中创建RDD</strong></p><p>​由外部存储系统的数据集创建RDD包括：本地的文件系统，所有Hadoop支持的数据集，比如HDFS、HBase等。</p><p>​input路径支持本地路径（绝对、相对）、文件夹、HDFS等等</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;spark&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sparkContext.textFile(<span class="string">&quot;input&quot;</span>)</span><br><span class="line">fileRDD.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure><p><strong>从其它RDD中创建</strong></p><p>主要是通过一个RDD运算完后，再产生新的RDD</p><p><strong>直接创建RDD（new）</strong></p><p>使用new的方式直接构造RDD，一般由Spark框架自身使用</p><h4 id="1-4-2-RDD的分区和并行度"><a href="#1-4-2-RDD的分区和并行度" class="headerlink" title="1.4.2 RDD的分区和并行度"></a>1.4.2 RDD的分区和并行度</h4><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662468520960.png" alt="1662468520960"></p><p>​分区可以提高并行度，达到复杂均衡的效果。</p><p>​默认情况下，Spark可以将一个作业切分多个任务后，发送给Executor节点并行计算，而能够并行计算的任务数量我们称之为并行度。这个数量可以在构建RDD时指定。记住，这里的并行执行的任务数量，并不是指的切分任务的数量，不要混淆了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;spark&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">Int</span>] =</span><br><span class="line">    sparkContext.makeRDD(</span><br><span class="line">        <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">        <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] =</span><br><span class="line">    sparkContext.textFile(</span><br><span class="line">        <span class="string">&quot;input&quot;</span>,</span><br><span class="line">        <span class="number">2</span>)</span><br><span class="line">fileRDD.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure><p>​makeRDD 可以指定创建的RDD的分区数目，</p><hr><p><strong>利用集合在内存中创建RDD的分区策略</strong></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662469402062.png" alt="1662469402062"></p><p>通过源码我们可以追溯到上述代码，其中length就是集合的元素个数，numSlices代表的切片个数</p><p>那么对于第一个分区的范围就是start &#x3D; 0 end &#x3D; 1*len &#x2F; numSlices，</p><p>通过上述代码可以计算出所有分区的数字范围，从而得到每一个分区内的数据</p><hr><p><strong>利用文件创建RDD的分区策略</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">InputSplit</span>[] getSplits(<span class="type">JobConf</span> job, int numSplits)</span><br><span class="line">    <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line"></span><br><span class="line">    long totalSize = <span class="number">0</span>;                           <span class="comment">// compute total size</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">FileStatus</span> file: files) &#123;                <span class="comment">// check we have valid files</span></span><br><span class="line">      <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">&quot;Not a file: &quot;</span>+ file.getPath());</span><br><span class="line">      &#125;</span><br><span class="line">      totalSize += file.getLen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long goalSize = totalSize / (numSplits == <span class="number">0</span> ? <span class="number">1</span> : numSplits);</span><br><span class="line">    long minSize = <span class="type">Math</span>.max(job.getLong(org.apache.hadoop.mapreduce.lib.input.</span><br><span class="line">      <span class="type">FileInputFormat</span>.<span class="type">SPLIT_MINSIZE</span>, <span class="number">1</span>), minSplitSize);</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">FileStatus</span> file: files) &#123;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isSplitable(fs, path)) &#123;</span><br><span class="line">          long blockSize = file.getBlockSize();</span><br><span class="line">          long splitSize = computeSplitSize(goalSize, minSize, blockSize);</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> long computeSplitSize(long goalSize, long minSize,</span><br><span class="line">                                       long blockSize) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Math</span>.max(minSize, <span class="type">Math</span>.min(goalSize, blockSize));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>利用文件来计算RDD的分区比较麻烦。主要分为两个步骤，第一步是计算真正的分区数目，第二步是计算每一个分区到底该存放那些数据</p><p>首先对于第一步计算真正的分区数目，你在创建RDD的时候会输入一个分区数目，这个分区数目就是你预计的分区数目，但并不是真正的分区数目，如果你没有指定分区数目，那么将有内部来计算一个。其实就是计算defaultParallelism和2的最小值作为预计分区数目，而defaultParallelism，这个值其实和上面的集合常见的RDD中计算规则一样，是根据当前环境来计算得出的，默认下是使用的当前环境的虚拟核数目。</p><p>得到预计的分区数目之后，我们计算得出总共文件的大小，然后计算预计每一个分区的字节数目，就是利用totalsize除以预期分区数目，为了防止预计分区数目过少，而文件过大，因此后续得到每一个分区真实的字节数目还需要做一个比较，就是计算你预期每一个分区的字节数和blocksize的最小值，计算得到每一个分区应该的字节数目之后，我们再用totalsize除以字节数目，就得到了真实的分区数目，如果有余数，我们需要计算余数字节数目除以每一个分区的字节数，是否大于10%，大于就再多一个分区，不大于，就把数据放到最后的那个分区中。这些概念在hadoop中也有涉及。这样就计算得到了真实的分区数目</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662470735371.png" alt="1662470735371"></p><p>得到了真实的分区数目之后，每一个分区真实的字节数目还需要真实介绍，由于我们刚才是按照字节数目来划分的，但是由于spark内部读取文件数据的底层使用的Hadoop，Hadoop的读取数据是按照行来读取的，并不是按照字节来读取，因此还需要计算每一个分区真实存放的字节数目</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662471249739.png" alt="1662471249739"></p><p>如下图所示，假设按照字节数目，第一个分区应该是0-3，第二个分区是3-6，第三个分区是6-7，但是3这个偏移量是第二行的，因此第一个分区会把第一行以及第二行全部放到这个分区里面，后续计算过程类似，这样就得到了最后真实的每一个分区存放的数据。</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662472110962.png" alt="1662472110962"></p><p><a href="https://blog.csdn.net/weixin_45425054/article/details/113899916">(72条消息) Spark之RDD理解（分区策略）_黑星bm的博客-CSDN博客</a></p><h4 id="1-4-3-RDD转换算子"><a href="#1-4-3-RDD转换算子" class="headerlink" title="1.4.3 RDD转换算子"></a>1.4.3 RDD转换算子</h4><p>​转换算子，是对于逻辑的封装，把旧的逻辑转换为新的逻辑</p><h5 id="1-4-3-1-map"><a href="#1-4-3-1-map" class="headerlink" title="1.4.3.1 map"></a>1.4.3.1 map</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD1: <span class="type">RDD</span>[<span class="type">Int</span>] = dataRDD.map(</span><br><span class="line">    num =&gt; &#123;</span><br><span class="line">        num * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> dataRDD2: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD1.map(</span><br><span class="line">    num =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span> + num</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662474951904.png" alt="1662474951904"></p><p>​如果有多个RDD转换算子，而且一个分区内有多条数据需要处理，那么需要把前面的数据把所有的RDD转换算子执行完，才会执行下一条数据。</p><h5 id="1-4-3-2-mapPartitions"><a href="#1-4-3-2-mapPartitions" class="headerlink" title="1.4.3.2 mapPartitions"></a>1.4.3.2 mapPartitions</h5><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662475638410.png" alt="1662475638410"></p><p>mappartitions方法，该方法相当于对每一个分区的数据执行一次。所以取到的数据是一个List集合<br><strong>数据处理角度</strong></p><p>​Map算子是分区内一个数据一个数据的执行，类似于串行操作。而mapPartitions算子是以分区为单位进行批处理操作。</p><p><strong>功能的角度</strong></p><p>​Map算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。MapPartitions算子需要传递一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变，所以可以增加或减少数据</p><p><strong>性能的角度</strong></p><p>​Map算子因为类似于串行操作，所以性能比较低，而是mapPartitions算子类似于批处理，所以性能较高。但是mapPartitions算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。所以在内存有限的情况下，不推荐使用。使用map操作。</p><h5 id="1-4-3-3-mapPartitionsWithIndex"><a href="#1-4-3-3-mapPartitionsWithIndex" class="headerlink" title="1.4.3.3 mapPartitionsWithIndex"></a>1.4.3.3 mapPartitionsWithIndex</h5><p>​将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662476260503.png" alt="1662476260503"></p><p>参数由1个变为2个，多的那个参数代表第几个分区</p><h5 id="1-4-3-4-flatMap"><a href="#1-4-3-4-flatMap" class="headerlink" title="1.4.3.4 flatMap"></a>1.4.3.4 flatMap</h5><p>​将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662476457554.png" alt="1662476457554"></p><p>一个小练习</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662476588362.png" alt="1662476588362"></p><p>​这里的数据类型不同，既有list类型，还有Int类型，因此需要使用到模式匹配，如果是List类型那就直接返回list，如果是其它类型，那么就直接使用List包装一下。</p><h5 id="1-4-3-5-glom"><a href="#1-4-3-5-glom" class="headerlink" title="1.4.3.5 glom"></a>1.4.3.5 glom</h5><p>​将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变</p><p>练习：计算所有分区最大值求和（分区内求最大值，分区间最大值求和）</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662477134288.png" alt="1662477134288"></p><h5 id="1-4-3-6-groupBy-shuffle"><a href="#1-4-3-6-groupBy-shuffle" class="headerlink" title="1.4.3.6 groupBy(shuffle)"></a>1.4.3.6 groupBy(shuffle)</h5><p>​将数据根据指定的规则进行分组, 分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为shuffle。极限情况下，数据可能被分在同一个分区中</p><p>​<strong>一个组的数据在一个分区中，但是并不是说一个分区中只有一个组</strong></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662477321533.png" alt="1662477321533"></p><p>​默认情况下，数据处理之后，所在分区不会发生改变</p><p>​Spark要求，一个组的数据必须在一个分区中</p><p>一个分区的数据被打乱重新和其它分区的数据组合在一起，这个操作叫做shuffle</p><p>shuffle操作不允许在内存中等待，必须要落盘</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662477719598.png" alt="1662477719598"></p><p>如上图所示，如果我们RDD中存在很多个分区，后面紧跟了个shuffle操作，那么如果在内存中执行，我们需要等待RDD所有的分区执行结束后才能接着往下走，但是这个过程极其耗费时间，而且十分耗费内存。</p><p>因此shuffle不允许在内存中等待，必须要落盘</p><p>shuffle会把完整的计算过程分为两个部分，一个阶段用于写数据，一个阶段用于读数据</p><p>写数据的阶段没有完成，读数据的操作不能执行</p><p>shuffle的操作可以更改分区数目</p><h5 id="1-4-3-7-filter"><a href="#1-4-3-7-filter" class="headerlink" title="1.4.3.7 filter"></a>1.4.3.7 filter</h5><p>​将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现数据倾斜。</p><p><strong>什么叫数据倾斜？</strong></p><p>​分区之间数据十分不均衡就是数据倾斜</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.filter(_%<span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="1-4-3-8-sample"><a href="#1-4-3-8-sample" class="headerlink" title="1.4.3.8 sample"></a>1.4.3.8 sample</h5><p>​根据指定的规则从数据集中抽取数据 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 抽取数据不放回（伯努利算法）</span></span><br><span class="line"><span class="comment">// 伯努利算法：又叫0、1分布。例如扔硬币，要么正面，要么反面。</span></span><br><span class="line"><span class="comment">// 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不要</span></span><br><span class="line"><span class="comment">// 第一个参数：抽取的数据是否放回，false：不放回</span></span><br><span class="line"><span class="comment">// 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取；1：全取；</span></span><br><span class="line"><span class="comment">// 第三个参数：随机数种子</span></span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.sample(<span class="literal">false</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">// 抽取数据放回（泊松算法）</span></span><br><span class="line"><span class="comment">// 第一个参数：抽取的数据是否放回，true：放回；false：不放回</span></span><br><span class="line"><span class="comment">// 第二个参数：重复数据的几率，范围大于等于0.表示每一个元素被期望抽取到的次数</span></span><br><span class="line"><span class="comment">// 第三个参数：随机数种子</span></span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD.sample(<span class="literal">true</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们可以使用sample取部分数据，来判断这个数据经过后面的数据转换是否会发生数据倾斜的现象</p><h5 id="1-4-3-9-distinct-shuffle"><a href="#1-4-3-9-distinct-shuffle" class="headerlink" title="1.4.3.9 distinct (shuffle)"></a>1.4.3.9 distinct (shuffle)</h5><p>​将数据集中重复的数据去重</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.distinct()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD.distinct(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>​由于RDD中是存在分区的概念的，那spark是如何实现的去重操作呢？</p><p>​内部会把每一条数据作为key，value填充null，然后使用reduceBykey操作，该操作只会对于相同key值的value进行聚合，由于value值都是null，最终把相同key值的所有值转换为（key,null)，最后在经过一个map操作把key得到就实现了去重操作。</p><h5 id="1-4-3-10-coalesce-shuffle"><a href="#1-4-3-10-coalesce-shuffle" class="headerlink" title="1.4.3.10 coalesce(shuffle)"></a>1.4.3.10 coalesce(shuffle)</h5><p>​根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率</p><p>​当spark程序中，存在过多的小任务的时候，可以通过coalesce方法，收缩合并分区，减少分区的个数，减小任务调度成本</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>),<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.coalesce(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>​这种方式在某些情况下，无法解决数据倾斜的问题，所以还可以在缩减分区的同时，进行数据的shuffle操作 </p><p>​由于coalesce方法并不是完全按照几个数据量小的来合并，由于他根本不清楚每一个分区的数量到底是多大，因此它使用的是首选位置来进行合并，就是按照数据所在节点之间的距离来抉择。因此无法解决数据倾斜的问题。</p><p>​该方法还可以传入第二个参数，指定是否进行shuffle操作，如果值为false并不会执行shuffle，shuffle是把一个分区内的数据打乱放到其它分区中，此处只是把多个分区间的数据进行合并，所以并不算shuffle操作。其执行shuffle后数据会稍微均衡一点，但也无法做到十分均衡。后续还会接着介绍。</p><p>​该方法的第一个参数是分区数目，该数目还可以大于之前的分区数目，并不是一定要缩减分区。</p><p>但是当大于之前的分区数目的时候，如果没有打开shuffle操作，将不能把一个分区的数据打乱放到其它分区内，所以并不会执行，扩大分区无效。只有开启shuffle才会增大分区数目。</p><h5 id="1-4-3-11-repartition-shuffle"><a href="#1-4-3-11-repartition-shuffle" class="headerlink" title="1.4.3.11 repartition (shuffle)"></a>1.4.3.11 repartition (shuffle)</h5><p>​该操作内部其实执行的是coalesce操作，参数shuffle的默认值为true。无论是将分区数多的RDD转换为分区数少的RDD，还是将分区数少的RDD转换为分区数多的RDD，repartition操作都可以完成，因为无论如何都会经shuffle过程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.repartition(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>因此之后我们扩大分区可以使用repartition函数，缩减分区使用coalesce函数。</p><h5 id="1-4-3-12-sortBy-shuffle"><a href="#1-4-3-12-sortBy-shuffle" class="headerlink" title="1.4.3.12 sortBy (shuffle)"></a>1.4.3.12 sortBy (shuffle)</h5><p>​该操作用于排序数据。在排序之前，可以将数据通过f函数进行处理，之后按照f函数处理的结果进行排序，默认为升序排列。排序后新产生的RDD的分区数与原RDD的分区数一致。中间存在shuffle的过程</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.sortBy(num=&gt;num, <span class="literal">false</span>, <span class="number">4</span>) <span class="comment">//false参数代表降序排列</span></span><br></pre></td></tr></table></figure><p>但是我目前产生一个疑问，RDD是存在分区概念的，那么它是如何实现的所有分区内的数据排好顺序呢？</p><p>实验一波</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662547994160.png" alt="1662547994160"></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662548008359.png" alt="1662548008359"></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662548014650.png" alt="1662548014650"></p><p>sortBy之后</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662548075504.png" alt="1662548075504"></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662548086800.png" alt="1662548086800"></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662548095986.png" alt="1662548095986"></p><p>因此我们可以看出，他是肯定会执行一个shuffle操作，然后按照分区号码，把更小的数字放到分区号小的位置中去，并且分区间也是有序的。</p><h5 id="1-4-3-13-intersection"><a href="#1-4-3-13-intersection" class="headerlink" title="1.4.3.13 intersection"></a>1.4.3.13 intersection</h5><p>​对源RDD和参数RDD求交集后返回一个新的RDD</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.intersection(dataRDD2)</span><br></pre></td></tr></table></figure><h5 id="1-4-3-14-union"><a href="#1-4-3-14-union" class="headerlink" title="1.4.3.14 union"></a>1.4.3.14 union</h5><p>​以一个RDD元素为主，去除两个RDD中重复元素，将其他元素保留下来。求差集</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.union(dataRDD2)</span><br></pre></td></tr></table></figure><h5 id="1-4-3-15-subtract"><a href="#1-4-3-15-subtract" class="headerlink" title="1.4.3.15 subtract"></a>1.4.3.15 subtract</h5><p>​以一个RDD元素为主，去除两个RDD中重复元素，将其他元素保留下来。求差集</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.subtract(dataRDD2)</span><br></pre></td></tr></table></figure><h5 id="1-4-3-16-zip"><a href="#1-4-3-16-zip" class="headerlink" title="1.4.3.16 zip"></a>1.4.3.16 zip</h5><p>​将两个RDD中的元素，以键值对的形式进行合并。其中，键值对中的Key为第1个RDD中的元素，Value为第2个RDD中的相同位置的元素。</p><p>​但是必须要满足两个RDD的元素类型相同，以及RDD每一个分区之间的数目要相同</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662548984343.png" alt="1662548984343"></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662549021025.png" alt="1662549021025"></p><h5 id="1-4-3-17-partitionBy"><a href="#1-4-3-17-partitionBy" class="headerlink" title="1.4.3.17 partitionBy"></a>1.4.3.17 partitionBy</h5><p>​将数据按照指定Partitioner重新进行分区。Spark默认的分区器是HashPartitioner</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] =</span><br><span class="line">    sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>,<span class="string">&quot;aaa&quot;</span>),(<span class="number">2</span>,<span class="string">&quot;bbb&quot;</span>),(<span class="number">3</span>,<span class="string">&quot;ccc&quot;</span>)),<span class="number">3</span>)</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">HashPartitioner</span></span><br><span class="line"><span class="keyword">val</span> rdd2: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] =</span><br><span class="line">    rdd.partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>partitionBy算子是根据指定的规则对每一条数据进行重新分区</p><p>repartition：强调分区数量的变换，对于数据并不关心</p><p>partitionBy：强调把数据放到哪一个分区</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662549392283.png" alt="1662549392283"></p><p>使用的是默认Spark中默认的shuffle分区器，HashPartitioner分区器</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662549585805.png" alt="1662549585805"></p><p>如果key是null，放到0号分区，如果有值就是按照key的hashcode和分区数目取余数得到数据所在分区数</p><h5 id="1-4-3-18-reduceByKey"><a href="#1-4-3-18-reduceByKey" class="headerlink" title="1.4.3.18  reduceByKey"></a>1.4.3.18  reduceByKey</h5><p>​可以将数据按照相同的Key对Value进行聚合</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.reduceByKey(_+_)</span><br><span class="line"><span class="keyword">val</span> dataRDD3 = dataRDD1.reduceByKey(_+_, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>对于相同的key，把value进行聚合</p><h5 id="1-4-3-19-groupByKey"><a href="#1-4-3-19-groupByKey" class="headerlink" title="1.4.3.19 groupByKey"></a>1.4.3.19 groupByKey</h5><p>​将数据源的数据根据key对value进行分组</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 =</span><br><span class="line">    sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.groupByKey()</span><br><span class="line"><span class="keyword">val</span> dataRDD3 = dataRDD1.groupByKey(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD4 = dataRDD1.groupByKey(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>​该算子把相同key数据的value放在一个组中</p><p>groupBy和groupByKey的区别</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662550361082.png" alt="1662550361082"></p><p>reduceByKey和groupByKey区别</p><p><strong>从shuffle的角度</strong>：reduceByKey和groupByKey都存在shuffle的操作，<strong>但是reduceByKey可以在shuffle前对分区内相同key的数据进行预聚合（combine）功能</strong>，这样会减少落盘的数据量，而groupByKey只是进行分组，不存在数据量减少的问题，reduceByKey性能比较高。</p><p><strong>从功能的角度</strong>：reduceByKey其实包含分组和聚合的功能。groupByKey只能分组，不能聚合，所以在分组聚合的场合下，推荐使用reduceByKey，如果仅仅是分组而不需要聚合。那么还是只能使用groupByKey</p><h5 id="1-4-3-20-aggregateByKey"><a href="#1-4-3-20-aggregateByKey" class="headerlink" title="1.4.3.20 aggregateByKey"></a>1.4.3.20 aggregateByKey</h5><p>​将数据根据不同的规则进行分区内计算和分区间计算</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662561299897.png" alt="1662561299897"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 =</span><br><span class="line">    sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 =</span><br><span class="line">    dataRDD1.aggregateByKey(<span class="number">0</span>)(_+_,_+_)</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO : 取出每个分区内相同key的最大值然后分区间相加</span></span><br><span class="line"><span class="comment">// aggregateByKey算子是函数柯里化，存在两个参数列表</span></span><br><span class="line"><span class="comment">// 1. 第一个参数列表中的参数表示初始值</span></span><br><span class="line"><span class="comment">// 2. 第二个参数列表中含有两个参数</span></span><br><span class="line"><span class="comment">//    2.1 第一个参数表示分区内的计算规则</span></span><br><span class="line"><span class="comment">//    2.2 第二个参数表示分区间的计算规则</span></span><br><span class="line"><span class="keyword">val</span> rdd =</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">        (<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;a&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>),</span><br><span class="line">        (<span class="string">&quot;b&quot;</span>,<span class="number">4</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">5</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">6</span>)</span><br><span class="line">    ),<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 0:(&quot;a&quot;,1),(&quot;a&quot;,2),(&quot;c&quot;,3) =&gt; (a,10)(c,10)</span></span><br><span class="line"><span class="comment">//                                         =&gt; (a,10)(b,10)(c,20)</span></span><br><span class="line"><span class="comment">// 1:(&quot;b&quot;,4),(&quot;c&quot;,5),(&quot;c&quot;,6) =&gt; (b,10)(c,10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultRDD =</span><br><span class="line">    rdd.aggregateByKey(<span class="number">10</span>)(</span><br><span class="line">        (x, y) =&gt; math.max(x,y),</span><br><span class="line">        (x, y) =&gt; x + y</span><br><span class="line">    )</span><br><span class="line">resultRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure><p>​第一个参数是计算初始值，主要是可能某一个分区内的key只有一个，从而无法执行聚合计算，因此需要一个初始值进行聚合计算过程</p><p>​该函数主要是可以实现分区间一个计算规则、分区内一个计算规则，当遇到这种需求的时候，可以使用这个算子，而刚才的reduceByKey是分区内和分区间都一个计算规则。</p><p>​分区之间存在shuffle.</p><h5 id="1-4-3-21-foldByKey"><a href="#1-4-3-21-foldByKey" class="headerlink" title="1.4.3.21 foldByKey"></a>1.4.3.21 foldByKey</h5><p>​当分区内计算规则和分区间计算规则相同时，aggregateByKey就可以简化为foldByKey</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.foldByKey(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure><h5 id="1-4-3-22-combineByKey"><a href="#1-4-3-22-combineByKey" class="headerlink" title="1.4.3.22 combineByKey"></a>1.4.3.22 combineByKey</h5><p>​最通用的对key-value型rdd进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。</p><p>​小练习：将数据List((“a”, 88),(“b”, 95), (“a”, 91), (“b”, 93), (“a”,95), (“b”, 98))求每个key的平均值</p><p>conbineByKey有三个参数</p><p>第一个参数表示 当属不符合我们的规则的时候，用于进行转换的操作</p><p>第二个参数表示 分区内的计算规则</p><p>第三个参数表示 分区间计算规则</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">91</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">93</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">98</span>))</span><br><span class="line"><span class="keyword">val</span> input: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sc.makeRDD(list, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> combineRdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = input.combineByKey(</span><br><span class="line">    (_, <span class="number">1</span>),</span><br><span class="line">    (acc: (<span class="type">Int</span>, <span class="type">Int</span>), v) =&gt; (acc._1 + v, acc._2 + <span class="number">1</span>),</span><br><span class="line">    (acc1: (<span class="type">Int</span>, <span class="type">Int</span>), acc2: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​第一个参数好像只会对于每一个分区内的每一个key的第一个数据进行数据的转化，而对于该key的其它的值会进行第二个参数的规则来计算。</p><p>reduceByKey: 相同key的第一个数据不进行任何计算，分区内和分区间计算规则相同</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662563755802.png" alt="1662563755802"></p><p>foldByKey: 相同key的第一个数据和初始值进行分区内计算，分区内和分区间计算规则相同</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662563847368.png" alt="1662563847368"></p><p>aggregateByKey：相同key的第一个数据和初始值进行分区内计算，分区内和分区间计算规则可以不相同</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662563800127.png" alt="1662563800127"></p><p>combineByKey:当计算时，发现数据结构不满足要求时，可以让第一个数据转换结构。分区内和分区间计算规则不相同。</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662563880705.png" alt="1662563880705"></p><h5 id="1-4-3-23-sortByKey"><a href="#1-4-3-23-sortByKey" class="headerlink" title="1.4.3.23 sortByKey"></a>1.4.3.23 sortByKey</h5><p>​在一个(K,V)的RDD上调用，K必须实现Ordered接口(特质)，返回一个按照key进行排序的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataRDD1.sortByKey(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataRDD1.sortByKey(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h5 id="1-4-3-24-join"><a href="#1-4-3-24-join" class="headerlink" title="1.4.3.24 join"></a>1.4.3.24 join</h5><p>​在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素连接在一起的(K,(V,W))的RDD</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;b&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;c&quot;</span>)))</span><br><span class="line"><span class="keyword">val</span> rdd1: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)))</span><br><span class="line">rdd.join(rdd1).collect().foreach(println)</span><br></pre></td></tr></table></figure><p>​但是这个join操作可能会产生笛卡尔乘积，可能左边有1w个a，右边的也有1w个a，这样会产生1亿个数据，因此效率比较低，而且他由于需要把分区间的key做连接，所以需要用到shuffle操作，落盘效率较低</p><h5 id="1-4-3-25-leftOuterJoin"><a href="#1-4-3-25-leftOuterJoin" class="headerlink" title="1.4.3.25 leftOuterJoin"></a>1.4.3.25 leftOuterJoin</h5><p>​类似于SQL语句的左外连接</p><p><strong>数据：</strong></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662564991854.png" alt="1662564991854"></p><p><strong>操作：</strong></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662565024672.png" alt="1662565024672"></p><p><strong>结果：</strong></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662565046824.png" alt="1662565046824"></p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662565195311.png" alt="1662565195311"></p><h5 id="1-4-3-26-cogroup"><a href="#1-4-3-26-cogroup" class="headerlink" title="1.4.3.26 cogroup"></a>1.4.3.26 cogroup</h5><p>​cogroup 相当于connect+group 组内连接</p><p>​在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的RDD</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662565251108.png" alt="1662565251108"></p><p>​先把一个分区内的相同key做了一个分组，然后再和另外一个表进行连接，</p><h4 id="1-4-4-RDD行动算子"><a href="#1-4-4-RDD行动算子" class="headerlink" title="1.4.4 RDD行动算子"></a>1.4.4 RDD行动算子</h4><p>​执行逻辑，把封装好的逻辑执行起来。</p><p>​一个行动算子，就会提交一个作业</p><h5 id="1-4-4-1-reduce"><a href="#1-4-4-1-reduce" class="headerlink" title="1.4.4.1 reduce"></a>1.4.4.1 reduce</h5><p>​该函数会对数据进行聚合操作，和scala中的reduce方法不同，spark的reduce算子是分布式的，因此首先会对分区内数据进行聚合，然后在对分区间进行聚合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 聚合数据</span></span><br><span class="line"><span class="keyword">val</span> reduceResult: <span class="type">Int</span> = rdd.reduce(_+_)</span><br></pre></td></tr></table></figure><h5 id="1-4-4-2-collect"><a href="#1-4-4-2-collect" class="headerlink" title="1.4.4.2 collect"></a>1.4.4.2 collect</h5><p>​把数据从executor中采集数据到driver之中，但是可能driver中的内存不足，此时会产生溢写操作，因此如果数据量比较大，不要使用collect操作</p><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662636913213.png" alt="1662636913213"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集数据到Driver</span></span><br><span class="line">rdd.collect().foreach(println)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-4-4-3-count"><a href="#1-4-4-3-count" class="headerlink" title="1.4.4.3 count"></a>1.4.4.3 count</h5><p>​函数作用很简单，就是计算RDD中元素的个数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回RDD中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> countResult: <span class="type">Long</span> = rdd.count()</span><br></pre></td></tr></table></figure><h5 id="1-4-4-4-first"><a href="#1-4-4-4-first" class="headerlink" title="1.4.4.4 first"></a>1.4.4.4 first</h5><p>​函数的作用是取出RDD中第一个元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回RDD中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> firstResult: <span class="type">Int</span> = rdd.first()</span><br><span class="line">println(firstResult</span><br></pre></td></tr></table></figure><h5 id="1-4-4-5-take"><a href="#1-4-4-5-take" class="headerlink" title="1.4.4.5 take"></a>1.4.4.5 take</h5><p>​返回一个由RDD的前n个元素组成的数组</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vval rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回RDD中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> takeResult: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.take(<span class="number">2</span>)</span><br><span class="line">println(takeResult.mkString(<span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure><h5 id="1-4-4-6-takeOrdered"><a href="#1-4-4-6-takeOrdered" class="headerlink" title="1.4.4.6 takeOrdered"></a>1.4.4.6 takeOrdered</h5><pre><code> 返回该**RDD排序后**的前n个元素组成的数组</code></pre><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回RDD中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.takeOrdered(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="1-4-4-7-aggregate"><a href="#1-4-4-7-aggregate" class="headerlink" title="1.4.4.7 aggregate"></a>1.4.4.7 aggregate</h5><p>​分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将该RDD所有元素相加得到结果</span></span><br><span class="line"><span class="comment">//val result: Int = rdd.aggregate(0)(_ + _, _ + _)</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Int</span> = rdd.aggregate(<span class="number">10</span>)(_ + _, _ + _)</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662637655394.png" alt="1662637655394"></p><h5 id="1-4-4-8-fold"><a href="#1-4-4-8-fold" class="headerlink" title="1.4.4.8 fold"></a>1.4.4.8 fold</h5><p>​折叠操作，aggregate的简化版操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> foldResult: <span class="type">Int</span> = rdd.fold(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure><h5 id="1-4-4-9-countByKey"><a href="#1-4-4-9-countByKey" class="headerlink" title="1.4.4.9 countByKey"></a>1.4.4.9 countByKey</h5><p>​ 统计每种key的个数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = sc.makeRDD(<span class="type">List</span>((<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;b&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;c&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;c&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计每种key的个数</span></span><br><span class="line"><span class="keyword">val</span> result: collection.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Long</span>] = rdd.countByKey()</span><br></pre></td></tr></table></figure><h5 id="1-4-4-10-save相关算子"><a href="#1-4-4-10-save相关算子" class="headerlink" title="1.4.4.10 save相关算子"></a>1.4.4.10 save相关算子</h5><p>​将数据保存到不同格式的文件中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存成Text文件</span></span><br><span class="line">rdd.saveAsTextFile(<span class="string">&quot;output&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化成对象保存到文件</span></span><br><span class="line">rdd.saveAsObjectFile(<span class="string">&quot;output1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存成Sequencefile文件</span></span><br><span class="line">rdd.map((_,<span class="number">1</span>)).saveAsSequenceFile(<span class="string">&quot;output2&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="1-4-4-11-foreach"><a href="#1-4-4-11-foreach" class="headerlink" title="1.4.4.11 foreach"></a>1.4.4.11 foreach</h5><p>​分布式遍历RDD中的每一个元素，调用指定函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集后打印</span></span><br><span class="line">rdd.map(num=&gt;num).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;****************&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布式打印</span></span><br><span class="line">rdd.foreach(println)</span><br></pre></td></tr></table></figure><h4 id="1-4-5-RDD序列化"><a href="#1-4-5-RDD序列化" class="headerlink" title="1.4.5 RDD序列化"></a>1.4.5 RDD序列化</h4><p><strong>闭包检查</strong></p><p>​从计算的角度, 算子以外的代码都是在Driver端执行, 算子里面的代码都是在Executor端执行。那么在scala的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给Executor端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为闭包检测。Scala2.12版本后闭包编译方式发生了改变</p><p><strong>序列化方法和属性</strong></p><p>​<strong>从计算的角度, 算子以外的代码都是在Driver端执行, 算子里面的代码都是在Executor端执行，看如下代码：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">serializable02_function</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//1.创建SparkConf并设置App名称</span></span><br><span class="line">        <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;SparkCoreTest&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建SparkContext，该对象是提交Spark App的入口</span></span><br><span class="line">        <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建一个RDD</span></span><br><span class="line">        <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello spark&quot;</span>, <span class="string">&quot;hive&quot;</span>, <span class="string">&quot;atguigu&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.1创建一个Search对象</span></span><br><span class="line">        <span class="keyword">val</span> search = <span class="keyword">new</span> <span class="type">Search</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 函数传递，打印：ERROR Task not serializable</span></span><br><span class="line">        search.getMatch1(rdd).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.3 属性传递，打印：ERROR Task not serializable</span></span><br><span class="line">        search.getMatch2(rdd).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭连接</span></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span>(<span class="params">query:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        s.contains(query)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数序列化案例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatch1</span> </span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">        <span class="comment">//rdd.filter(this.isMatch)</span></span><br><span class="line">        rdd.filter(isMatch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性序列化案例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatch2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">        <span class="comment">//rdd.filter(x =&gt; x.contains(this.query))</span></span><br><span class="line">        rdd.filter(x =&gt; x.contains(query))</span><br><span class="line">        <span class="comment">//val q = query</span></span><br><span class="line">        <span class="comment">//rdd.filter(x =&gt; x.contains(q))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Kryo序列化框架</strong></p><p>​参考地址: <a href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p><p>​Java的序列化能够序列化任何的类。但是比较重（字节多），序列化后，对象的提交也比较大。Spark出于性能的考虑，Spark2.0开始支持另外一种Kryo序列化机制。Kryo速度是Serializable的10倍。当RDD在Shuffle数据的时候，简单数据类型、数组和字符串类型已经在Spark内部使用Kryo来序列化。</p><p>​注意：即使使用Kryo序列化，也要继承Serializable接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">serializable_Kryo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">                .setAppName(<span class="string">&quot;SerDemo&quot;</span>)</span><br><span class="line">                .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">                <span class="comment">// 替换默认的序列化机制</span></span><br><span class="line">                .set(<span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)</span><br><span class="line">                <span class="comment">// 注册需要使用 kryo 序列化的自定义类</span></span><br><span class="line">                .registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">Searcher</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello atguigu&quot;</span>, <span class="string">&quot;atguigu&quot;</span>, <span class="string">&quot;hahah&quot;</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> searcher = <span class="keyword">new</span> <span class="type">Searcher</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result: <span class="type">RDD</span>[<span class="type">String</span>] = searcher.getMatchedRDD1(rdd)</span><br><span class="line"></span><br><span class="line">        result.collect.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span>(<span class="params">val query: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>) = &#123;</span><br><span class="line">        s.contains(query)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatchedRDD1</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">        rdd.filter(isMatch) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatchedRDD2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">        <span class="keyword">val</span> q = query</span><br><span class="line">        rdd.filter(_.contains(q))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-6-RDD依赖关系"><a href="#1-4-6-RDD依赖关系" class="headerlink" title="1.4.6 RDD依赖关系"></a>1.4.6 RDD依赖关系</h4><p><strong>血缘关系</strong></p><p>​RDD只支持粗粒度转换，即在大量记录上执行的单个操作。将创建RDD的一系列Lineage（血统）记录下来，以便恢复丢失的分区。RDD的Lineage会记录RDD的元数据信息和转换行为，当该RDD的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line">println(fileRDD.toDebugString)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">println(wordRDD.toDebugString)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line">println(mapRDD.toDebugString)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_+_)</span><br><span class="line">println(resultRDD.toDebugString)</span><br><span class="line"></span><br><span class="line">resultRDD.collect()</span><br></pre></td></tr></table></figure><p><strong>RDD依赖关系</strong></p><p>​这里所谓的依赖关系，其实就是两个相邻RDD之间的关系</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line">println(fileRDD.dependencies)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">println(wordRDD.dependencies)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line">println(mapRDD.dependencies)</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_+_)</span><br><span class="line">println(resultRDD.dependencies)</span><br><span class="line"></span><br><span class="line">resultRDD.collect()</span><br></pre></td></tr></table></figure><p><strong>RDD窄依赖</strong></p><p>​窄依赖表示每一个父(上游)RDD的Partition最多被子（下游）RDD的一个Partition使用，窄依赖我们形象的比喻为独生子女。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneDependency</span>[<span class="type">T</span>](<span class="params">rdd: <span class="type">RDD</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">NarrowDependency</span>[<span class="type">T</span>](<span class="params">rdd</span>) </span></span><br></pre></td></tr></table></figure><p><strong>RDD宽依赖</strong></p><p>​宽依赖表示同一个父（上游）RDD的Partition被多个子（下游）RDD的Partition依赖，会引起Shuffle，总结：宽依赖我们形象的比喻为多生</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShuffleDependency</span>[<span class="type">K</span>: <span class="type">ClassTag</span>, <span class="type">V</span>: <span class="type">ClassTag</span>, <span class="type">C</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    @transient private val _rdd: <span class="type">RDD</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]],</span></span></span><br><span class="line"><span class="params"><span class="class">    val partitioner: <span class="type">Partitioner</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    val serializer: <span class="type">Serializer</span> = <span class="type">SparkEnv</span>.get.serializer,</span></span></span><br><span class="line"><span class="params"><span class="class">    val keyOrdering: <span class="type">Option</span>[<span class="type">Ordering</span>[<span class="type">K</span>]] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    val aggregator: <span class="type">Option</span>[<span class="type">Aggregator</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>]] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    val mapSideCombine: <span class="type">Boolean</span> = false</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">Dependency</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]] </span><br></pre></td></tr></table></figure><p><strong>RDD阶段划分</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on a</span></span><br><span class="line">  <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">  finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">    logWarning(<span class="string">&quot;Creating new stage failed due to exception - job: &quot;</span> + jobId, e)</span><br><span class="line">    listener.jobFailed(e)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createResultStage</span></span>(</span><br><span class="line">  rdd: <span class="type">RDD</span>[_],</span><br><span class="line">  func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">  partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">  jobId: <span class="type">Int</span>,</span><br><span class="line">  callSite: <span class="type">CallSite</span>): <span class="type">ResultStage</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId)  <span class="comment">//</span></span><br><span class="line"><span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line"><span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ResultStage</span>(id, rdd, func, partitions, parents, jobId, callSite)</span><br><span class="line">stageIdToStage(id) = stage</span><br><span class="line">updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line">stage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getOrCreateParentStages</span></span>(rdd: <span class="type">RDD</span>[_], firstJobId: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Stage</span>] = &#123;</span><br><span class="line">getShuffleDependencies(rdd).map &#123; shuffleDep =&gt;</span><br><span class="line">  getOrCreateShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">&#125;.toList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">getShuffleDependencies</span></span>(</span><br><span class="line">  rdd: <span class="type">RDD</span>[_]): <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]] = &#123;</span><br><span class="line"><span class="keyword">val</span> parents = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]]</span><br><span class="line"><span class="keyword">val</span> visited = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">RDD</span>[_]]</span><br><span class="line"><span class="keyword">val</span> waitingForVisit = <span class="keyword">new</span> <span class="type">Stack</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">waitingForVisit.push(rdd)</span><br><span class="line"><span class="keyword">while</span> (waitingForVisit.nonEmpty) &#123;</span><br><span class="line">  <span class="keyword">val</span> toVisit = waitingForVisit.pop()</span><br><span class="line">  <span class="keyword">if</span> (!visited(toVisit)) &#123;</span><br><span class="line">    visited += toVisit</span><br><span class="line">    toVisit.dependencies.foreach &#123;</span><br><span class="line">      <span class="keyword">case</span> shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _] =&gt;</span><br><span class="line">        parents += shuffleDep</span><br><span class="line">      <span class="keyword">case</span> dependency =&gt;</span><br><span class="line">        waitingForVisit.push(dependency.rdd)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">parents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RDD任务切分</strong></p><p>RDD任务切分中间分为：Application、Job、Stage和Task</p><ul><li><p>Application：初始化一个SparkContext即生成一个Application；</p></li><li><p>Job：一个Action算子就会生成一个Job；</p></li><li><p>Stage：Stage等于宽依赖(ShuffleDependency)的个数加1；</p></li><li><p>Task：一个Stage阶段中，最后一个RDD的分区个数就是Task的个数。</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">  stage <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">      partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">        <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">        <span class="keyword">val</span> part = stage.rdd.partitions(id)</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">          taskBinary, part, locs, stage.latestInfo.taskMetrics, properties, <span class="type">Option</span>(jobId),</span><br><span class="line">          <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">      partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">        <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">        <span class="keyword">val</span> part = stage.rdd.partitions(p)</span><br><span class="line">        <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">          taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics,</span><br><span class="line">          <span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> partitionsToCompute: <span class="type">Seq</span>[<span class="type">Int</span>] = stage.findMissingPartitions()</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findMissingPartitions</span></span>(): <span class="type">Seq</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">mapOutputTrackerMaster</span><br><span class="line">  .findMissingPartitions(shuffleDep.shuffleId)</span><br><span class="line">  .getOrElse(<span class="number">0</span> until numPartitions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-7-RDD持久化"><a href="#1-4-7-RDD持久化" class="headerlink" title="1.4.7 RDD持久化"></a>1.4.7 RDD持久化</h4><p><strong>RDD Cache缓存</strong></p><p>​RDD通过Cache或者Persist方法将前面的计算结果缓存，默认情况下会把数据以缓存在JVM的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的action算子时，该RDD将会被缓存在计算节点的内存中，并供后面重用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache操作会增加血缘关系，不改变原有的血缘关系</span></span><br><span class="line"><span class="comment">// 将血缘关系修改，添加一个和缓存相关的依赖关系</span></span><br><span class="line">println(wordToOneRdd.toDebugString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据缓存。</span></span><br><span class="line">wordToOneRdd.cache()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以更改存储级别</span></span><br><span class="line"><span class="comment">//mapRdd.persist(StorageLevel.MEMORY_AND_DISK_2)</span></span><br></pre></td></tr></table></figure><p>​存储级别</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StorageLevel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">NONE</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">DISK_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">DISK_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">OFF_HEAP</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">1</span>) <span class="comment">// 堆外内存，就是不受jvm管理的内存，是主动向操作系统申请的内存  </span></span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1662643880039.png" alt="1662643880039"></p><p>​缓存有可能丢失，或者存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。</p><p>​Spark会自动对一些Shuffle操作的中间数据做持久化操作(比如：reduceByKey)。这样做的目的是为了当一个节点Shuffle失败了避免重新计算整个输入。但是，在实际使用的时候，如果想重用数据，仍然建议调用persist或cache。<strong>cache内部使用的其实也是persist函数</strong></p><p>​<strong>但是持久化的文件只能自己使用，使用完毕之后就会自动删除，因此如果有其它的app想要使用持久化的文件不能使用persist函数。此功能可以使用checkpoint操作。</strong></p><p>​所谓的检查点其实就是通过将RDD中间结果写入磁盘</p><p>​由于血缘依赖过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果检查点之后有节点出现问题，可以从检查点开始重做血缘，减少了开销。对RDD进行checkpoint操作并不会马上被执行，必须执行Action操作才能触发。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置检查点路径</span></span><br><span class="line">sc.setCheckpointDir(<span class="string">&quot;./checkpoint1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个RDD，读取指定位置文件:hello atguigu atguigu</span></span><br><span class="line"><span class="keyword">val</span> lineRdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">val</span> wordRdd: <span class="type">RDD</span>[<span class="type">String</span>] = lineRdd.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> wordToOneRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = wordRdd.map &#123;</span><br><span class="line">    word =&gt; &#123;</span><br><span class="line">        (word, <span class="type">System</span>.currentTimeMillis())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加缓存,避免再重新跑一个job做checkpoint</span></span><br><span class="line">wordToOneRdd.cache()</span><br><span class="line"><span class="comment">// 数据检查点：针对wordToOneRdd做检查点计算</span></span><br><span class="line">wordToOneRdd.checkpoint()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发执行逻辑</span></span><br><span class="line">wordToOneRdd.collect().foreach(println)</span><br></pre></td></tr></table></figure><p><strong>缓存和检查点区别</strong></p><ul><li><p>Cache缓存只是将数据保存起来，不切断血缘依赖。Checkpoint检查点切断血缘依赖。</p></li><li><p>Cache缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint的数据通常存储在HDFS等容错、高可用的文件系统，可靠性高。</p></li><li><p>检查点为了数据的安全，会重新再执行一遍作业，所以会执行两次，但是这样效率比较低，因此建议checkpoint操作和cache操作一同使用，这样checkpoint的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD。</p></li></ul><h4 id="1-4-8-RDD分区器"><a href="#1-4-8-RDD分区器" class="headerlink" title="1.4.8 RDD分区器"></a>1.4.8 RDD分区器</h4><p>  Spark目前支持Hash分区和Range分区，和用户自定义分区。Hash分区为当前的默认分区。分区器直接决定了RDD中分区的个数、RDD中每条数据经过Shuffle后进入哪个分区，进而决定了Reduce的个数。</p><ul><li><p>只有Key-Value类型的RDD才有分区器，非Key-Value类型的RDD分区的值是None</p></li><li><p>每个RDD的分区ID范围：0 ~ (numPartitions - 1)，决定这个值是属于那个分区的。</p></li></ul><ol><li><strong>Hash分区</strong>：对于给定的key，计算其hashCode,并除以分区个数取余</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>(<span class="params">partitions: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  require(partitions &gt;= <span class="number">0</span>, <span class="string">s&quot;Number of partitions (<span class="subst">$partitions</span>) cannot be negative.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = partitions</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = key <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Utils</span>.nonNegativeMod(key.hashCode, numPartitions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> h: <span class="type">HashPartitioner</span> =&gt;</span><br><span class="line">      h.numPartitions == numPartitions</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>: <span class="type">Int</span> = numPartitions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Range分区</strong>：将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而且分区间有序</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangePartitioner</span>[<span class="type">K</span> : <span class="type">Ordering</span> : <span class="type">ClassTag</span>, <span class="type">V</span>](<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    partitions: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    rdd: <span class="type">RDD</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]],</span></span></span><br><span class="line"><span class="params"><span class="class">    private var ascending: <span class="type">Boolean</span> = true</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We allow partitions = 0, which happens when sorting an empty RDD under the default settings.</span></span><br><span class="line">  require(partitions &gt;= <span class="number">0</span>, <span class="string">s&quot;Number of partitions cannot be negative but found <span class="subst">$partitions</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">K</span>]]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of upper bounds for the first (partitions - 1) partitions</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> rangeBounds: <span class="type">Array</span>[<span class="type">K</span>] = &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = rangeBounds.length + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> binarySearch: ((<span class="type">Array</span>[<span class="type">K</span>], <span class="type">K</span>) =&gt; <span class="type">Int</span>) = <span class="type">CollectionsUtils</span>.makeBinarySearch[<span class="type">K</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> k = key.asInstanceOf[<span class="type">K</span>]</span><br><span class="line">    <span class="keyword">var</span> partition = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (rangeBounds.length &lt;= <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// If we have less than 128 partitions naive search</span></span><br><span class="line">      <span class="keyword">while</span> (partition &lt; rangeBounds.length &amp;&amp; ordering.gt(k, rangeBounds(partition))) &#123;</span><br><span class="line">        partition += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Determine which binary search method to use only once.</span></span><br><span class="line">      partition = binarySearch(rangeBounds, k)</span><br><span class="line">      <span class="comment">// binarySearch either returns the match location or -[insertion point]-1</span></span><br><span class="line">      <span class="keyword">if</span> (partition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        partition = -partition<span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (partition &gt; rangeBounds.length) &#123;</span><br><span class="line">        partition = rangeBounds.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ascending) &#123;</span><br><span class="line">      partition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rangeBounds.length - partition</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@throws</span>(classOf[<span class="type">IOException</span>])</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">writeObject</span></span>(out: <span class="type">ObjectOutputStream</span>): <span class="type">Unit</span> = <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@throws</span>(classOf[<span class="type">IOException</span>])</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readObject</span></span>(in: <span class="type">ObjectInputStream</span>): <span class="type">Unit</span> = <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何定义一个自己的分区器</strong></p><p>自定义分区器</p><ol><li>继承Partitioner</li><li>重写方法</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.rdd.part</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">Partitioner</span>, <span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Part</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = sc.makeRDD(</span><br><span class="line">            <span class="type">List</span>(</span><br><span class="line">                (<span class="string">&quot;nba&quot;</span>, <span class="string">&quot;xxxxxx&quot;</span>),</span><br><span class="line">                (<span class="string">&quot;cba&quot;</span>, <span class="string">&quot;11111&quot;</span>),</span><br><span class="line">                (<span class="string">&quot;nba&quot;</span>, <span class="string">&quot;yyyyy&quot;</span>),</span><br><span class="line">                (<span class="string">&quot;wnba&quot;</span>, <span class="string">&quot;22222&quot;</span>)</span><br><span class="line">            ),<span class="number">2</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rdd2: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = lines.partitionBy(<span class="keyword">new</span> <span class="type">MyPartitioner</span>())</span><br><span class="line"></span><br><span class="line">        rdd2.saveAsTextFile(<span class="string">&quot;output&quot;</span>)</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义分区器</span></span><br><span class="line">    <span class="comment">// 1. 继承Partitioner</span></span><br><span class="line">    <span class="comment">// 2. 重写方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 分区数量</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 根据数据的key返回所在的分区编号，从0开始</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            key <span class="keyword">match</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;nba&quot;</span> =&gt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;cba&quot;</span> =&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;wnba&quot;</span> =&gt; <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​定义一个自己的分区器需要重写四个方法，其中有两个方法的目的主要是为了防止前一次的RDD和后一次的RDD做了相同的shuffle分组操作，这样会极大的耗费性能，因此重写equals方法之后，会进行判断，如果两次分区器相等，那么就不再执行shuffle此操作，这样可以提升性能。这两个方法非必要，但建议重写。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.rdd.part</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">HashPartitioner</span>, <span class="type">Partitioner</span>, <span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_Part</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = sc.makeRDD(</span><br><span class="line">            <span class="type">List</span>(</span><br><span class="line">                (<span class="string">&quot;nba&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                (<span class="string">&quot;cba&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                (<span class="string">&quot;nba&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                (<span class="string">&quot;wnba&quot;</span>, <span class="number">1</span>)</span><br><span class="line">            ),<span class="number">2</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment">//        val rdd1: RDD[(String, Int)] = lines.reduceByKey(_ + _)</span></span><br><span class="line"><span class="comment">//        val rdd2: RDD[(String, Int)] = rdd1.reduceByKey(_ + _)</span></span><br><span class="line">         <span class="keyword">val</span> rdd1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = lines.partitionBy(<span class="keyword">new</span> <span class="type">MyPartitioner</span>())</span><br><span class="line">        <span class="comment">// 当rdd1有分区器的时候，会判断本次和前一次的分区器是否一样，如果一样就没有必要再进行shuffle操作</span></span><br><span class="line">         <span class="keyword">val</span> rdd2: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd1.partitionBy(<span class="keyword">new</span> <span class="type">MyPartitioner</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义分区器</span></span><br><span class="line">    <span class="comment">// 1. 继承Partitioner</span></span><br><span class="line">    <span class="comment">// 2. 重写方法(2 + 2)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 分区数量</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 根据数据的key返回所在的分区编号，从0开始</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            key <span class="keyword">match</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;nba&quot;</span> =&gt; <span class="number">0</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;cba&quot;</span> =&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;wnba&quot;</span> =&gt; <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> h: <span class="type">MyPartitioner</span> =&gt;</span><br><span class="line">                h.numPartitions == numPartitions</span><br><span class="line">            <span class="keyword">case</span> _ =&gt;</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>: <span class="type">Int</span> = numPartitions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-9-RDD文件读取与保存"><a href="#1-4-9-RDD文件读取与保存" class="headerlink" title="1.4.9 RDD文件读取与保存"></a>1.4.9 RDD文件读取与保存</h4><p>​Spark的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。</p><ol><li><p>文件格式分为：text文件、csv文件、sequence文件以及Object文件；</p></li><li><p>文件系统分为：本地文件系统、HDFS、HBASE以及数据库</p></li></ol><p>  <strong>text文件</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取输入文件</span></span><br><span class="line"><span class="keyword">val</span> inputRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;input/1.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">inputRDD.saveAsTextFile(<span class="string">&quot;output&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>sequence文件</strong></p><p>​SequenceFile文件是<a href="http://lib.csdn.net/base/hadoop">Hadoop</a>用来存储二进制形式的key-value对而设计的一种平面文件(Flat File)。在SparkContext中，可以调用sequenceFile[keyClass,valueClass](path)。</p><p>​读取的时候需要注意要指定key和value的类型是什么</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据为SequenceFile</span></span><br><span class="line">dataRDD.saveAsSequenceFile(<span class="string">&quot;output&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取SequenceFile文件</span></span><br><span class="line">sc.sequenceFile[<span class="type">Int</span>,<span class="type">Int</span>](<span class="string">&quot;output&quot;</span>).collect().foreach(println)</span><br></pre></td></tr></table></figure><p><strong>object文件</strong></p><p>​对象文件是将对象序列化后保存的文件，采用Java的序列化机制。可以通过objectFile<a href="path">T: ClassTag</a>函数接收一个路径，读取对象文件，返回对应的RDD，也可以通过调用saveAsObjectFile()实现对对象文件的输出。因为是序列化所以要指定类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">dataRDD.saveAsObjectFile(<span class="string">&quot;output&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">sc.objectFile[<span class="type">Int</span>](<span class="string">&quot;output&quot;</span>).collect().foreach(println)</span><br></pre></td></tr></table></figure><h2 id="2-累加器"><a href="#2-累加器" class="headerlink" title="2. 累加器"></a>2. 累加器</h2><p><strong>实现原理</strong></p><p>​累加器用来把Executor端变量信息聚合到Driver端。在Driver程序中定义的变量，在Executor端的每个Task都会得到这个变量的一份新的副本，每个task更新这些副本的值后，传回Driver端进行merge。</p><p><strong>默认累加器</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 声明累加器</span></span><br><span class="line"><span class="keyword">var</span> sum = sc.longAccumulator(<span class="string">&quot;sum&quot;</span>);</span><br><span class="line">rdd.foreach(</span><br><span class="line">  num =&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用累加器</span></span><br><span class="line">    sum.add(num)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获取累加器的值</span></span><br><span class="line">println(<span class="string">&quot;sum = &quot;</span> + sum.value)</span><br></pre></td></tr></table></figure><p><strong>自定义累加器</strong></p><p>实现wordcount</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.rdd.acc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_Acc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rdd = sc.makeRDD(</span><br><span class="line">            <span class="type">List</span>(</span><br><span class="line">                <span class="string">&quot;scala&quot;</span>,</span><br><span class="line">                <span class="string">&quot;scala&quot;</span>,</span><br><span class="line">                <span class="string">&quot;scala&quot;</span>,</span><br><span class="line">                <span class="string">&quot;scala&quot;</span>,</span><br><span class="line">                <span class="string">&quot;scala&quot;</span>,</span><br><span class="line">                <span class="string">&quot;scala&quot;</span>,</span><br><span class="line">                <span class="string">&quot;spark&quot;</span>,</span><br><span class="line">                <span class="string">&quot;spark&quot;</span>,</span><br><span class="line">                <span class="string">&quot;spark&quot;</span>,</span><br><span class="line">                <span class="string">&quot;spark&quot;</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 创建累加器</span></span><br><span class="line">        <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">WordCountAccumulator</span>()</span><br><span class="line">        <span class="comment">// TODO 向Spark进行注册</span></span><br><span class="line">        sc.register(acc, <span class="string">&quot;wordCount&quot;</span>)</span><br><span class="line"></span><br><span class="line">        rdd.foreach(</span><br><span class="line">            word =&gt; &#123;</span><br><span class="line">                <span class="comment">// TODO 将单词放入到累加器中</span></span><br><span class="line">                acc.add(word)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 获取累加器的累加结果</span></span><br><span class="line">        println(acc.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义数据累加器</span></span><br><span class="line">    <span class="comment">// 1. 继承AccumulatorV2</span></span><br><span class="line">    <span class="comment">// 2. 定义泛型</span></span><br><span class="line">    <span class="comment">//    IN : String</span></span><br><span class="line">    <span class="comment">//    OUT : Map[K, V]</span></span><br><span class="line">    <span class="comment">// 3. 重写方法（3 + 3）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WordCountAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]] </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> wcMap = mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断累加器是否为初始状态</span></span><br><span class="line">        <span class="comment">// copyAndReset must return a zero value copy</span></span><br><span class="line">        <span class="comment">// TODO 3. true</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">            wcMap.isEmpty</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 1.</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]] = &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">WordCountAccumulator</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置累加器</span></span><br><span class="line">        <span class="comment">// TODO 2.</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            wcMap.clear()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从外部向累加器中添加数据</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> oldCnt = wcMap.getOrElse(word, <span class="number">0</span>)</span><br><span class="line">            wcMap.update(word, oldCnt + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个累加器的结果</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">            other.value.foreach &#123;</span><br><span class="line">                <span class="keyword">case</span> (word, cnt) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> oldCnt = wcMap.getOrElse(word, <span class="number">0</span>)</span><br><span class="line">                    wcMap.update( word, oldCnt + cnt )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果返回到外部</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = wcMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-广播变量"><a href="#3-广播变量" class="headerlink" title="3. 广播变量"></a>3. 广播变量</h2><p>​广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个或多个Spark操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，广播变量用起来都很顺手。在多个并行操作中使用同一个变量，但是 Spark会为每个任务分别发送。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>( (<span class="string">&quot;a&quot;</span>,<span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">4</span>) ),<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>( (<span class="string">&quot;a&quot;</span>,<span class="number">4</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">5</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">6</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">7</span>) )</span><br><span class="line"><span class="comment">// 声明广播变量</span></span><br><span class="line"><span class="keyword">val</span> broadcast: <span class="type">Broadcast</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = sc.broadcast(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.map &#123;</span><br><span class="line">  <span class="keyword">case</span> (key, num) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用广播变量</span></span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- broadcast.value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        num2 = v</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (key, (num, num2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RDD </tag>
            
            <tag> 行动算子 </tag>
            
            <tag> 转换算子 </tag>
            
            <tag> map </tag>
            
            <tag> groupBy </tag>
            
            <tag> shuffle </tag>
            
            <tag> RDD的分区策略 </tag>
            
            <tag> RDD的创建 </tag>
            
            <tag> flatMap </tag>
            
            <tag> glom </tag>
            
            <tag> aggregateByKey </tag>
            
            <tag> reduceByKey </tag>
            
            <tag> combineByKey </tag>
            
            <tag> foldByKey </tag>
            
            <tag> 血缘关系 </tag>
            
            <tag> presist </tag>
            
            <tag> cache </tag>
            
            <tag> checkpoint </tag>
            
            <tag> 持久化 </tag>
            
            <tag> 依赖关系 </tag>
            
            <tag> 分区器 </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark运行架构</title>
      <link href="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-运行架构"><a href="#1-运行架构" class="headerlink" title="1. 运行架构"></a>1. 运行架构</h2><p>​Spark框架的核心是一个计算引擎，整体来说，它采用了标准 master-slave 的结构。</p><p>​如下图所示，它展示了一个 Spark执行时的基本结构。图形中的Driver表示master，负责管理整个集群中的作业任务调度。图形中的Executor 则是 slave，负责实际执行任务。</p><p><img src="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/1662462686546.png" alt="1662462686546"></p><h2 id="2-核心组件"><a href="#2-核心组件" class="headerlink" title="2.核心组件"></a>2.核心组件</h2><p>Spark有两个核心组件Driver和Executor</p><h3 id="2-1-Driver"><a href="#2-1-Driver" class="headerlink" title="2.1 Driver"></a>2.1 Driver</h3><p>​Spark驱动器节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：</p><p>Ø  将用户程序转化为作业（job）</p><p>Ø  在Executor之间调度任务(task)</p><p>Ø  跟踪Executor的执行情况</p><p>Ø  通过UI展示查询运行情况</p><p>​实际上，我们无法准确地描述Driver的定义，因为在整个的编程过程中没有看到任何有关Driver的字眼。所以简单理解，所谓的Driver就是驱使整个应用运行起来的程序，也称之为Driver类。</p><h3 id="2-2-Executor"><a href="#2-2-Executor" class="headerlink" title="2.2 Executor"></a>2.2 Executor</h3><p>​Spark Executor是集群中工作节点（Worker）中的一个JVM进程，负责在 Spark 作业中运行具体任务（Task），任务彼此之间相互独立。Spark 应用启动时，Executor节点被同时启动，并且始终伴随着整个 Spark 应用的生命周期而存在。如果有Executor节点发生了故障或崩溃，Spark 应用也可以继续执行，会将出错节点上的任务调度到其他Executor节点上继续运行。</p><p>​Executor有两个核心功能：</p><p>Ø  负责运行组成Spark应用的任务，并将结果返回给驱动器进程</p><p>Ø  它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD 是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p><h3 id="2-3-Master-以及Worker"><a href="#2-3-Master-以及Worker" class="headerlink" title="2.3 Master 以及Worker"></a>2.3 Master 以及Worker</h3><p>​Spark集群的独立部署环境中，不需要依赖其他的资源调度框架，自身就实现了资源调度的功能，所以环境中还有其他两个核心组件：Master和Worker，这里的Master是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责，类似于Yarn环境中的RM, 而Worker呢，也是进程，一个Worker运行在集群中的一台服务器上，由Master分配资源对数据进行并行的处理和计算，类似于Yarn环境中NM。</p><h3 id="2-4-ApplicationMaster"><a href="#2-4-ApplicationMaster" class="headerlink" title="2.4 ApplicationMaster"></a>2.4 ApplicationMaster</h3><p>​Hadoop用户向YARN集群提交应用程序时,提交程序中应该包含ApplicationMaster，用于向资源调度器申请执行任务的资源容器Container，运行用户自己的程序任务job，监控整个任务的执行，跟踪整个任务的状态，处理任务失败等异常情况。</p><p>​说的简单点就是，ResourceManager（资源）和Driver（计算）之间的解耦合靠的就是ApplicationMaster。</p><h2 id="3-核心概念"><a href="#3-核心概念" class="headerlink" title="3. 核心概念"></a>3. 核心概念</h2><h3 id="3-1-Executor以及core"><a href="#3-1-Executor以及core" class="headerlink" title="3.1 Executor以及core"></a>3.1 Executor以及core</h3><p>​其中Executor其实我们可以把他理解成一台虚拟机</p><p>​Spark Executor是集群中运行在工作节点（Worker）中的一个JVM进程，是整个集群中的专门用于计算的节点。在提交应用中，可以提供参数指定计算节点的个数，以及对应的资源。这里的资源一般指的是工作节点Executor的内存大小和使用的虚拟CPU核（Core）数量。</p><p>​应用程序相关启动参数如下：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>–num-executors</td><td>配置Executor的数量</td></tr><tr><td>–executor-memory</td><td>配置每个Executor的内存大小</td></tr><tr><td>–executor-cores</td><td>配置每个Executor的虚拟CPU   core数量</td></tr></tbody></table><h3 id="3-2-并行度"><a href="#3-2-并行度" class="headerlink" title="3.2 并行度"></a>3.2 并行度</h3><p>​在分布式计算框架中一般都是多个任务同时执行，由于任务分布在不同的计算节点进行计算，所以能够真正地实现多任务并行执行，记住，这里是并行，而不是并发。这里我们将整个集群并行执行任务的数量称之为并行度。那么一个作业到底并行度是多少呢？这个取决于框架的默认配置。应用程序也可以在运行过程中动态修改。</p><h3 id="3-3-有向无环图（DAG）"><a href="#3-3-有向无环图（DAG）" class="headerlink" title="3.3 有向无环图（DAG）"></a>3.3 有向无环图（DAG）</h3><p><img src="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/1662463069720.png" alt="1662463069720"></p><p>​大数据计算引擎框架我们根据使用方式的不同一般会分为四类，其中第一类就是Hadoop所承载的MapReduce,它将计算分为两个阶段，分别为 Map阶段 和 Reduce阶段。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job 的串联，以完成一个完整的算法，例如迭代计算。 由于这样的弊端，催生了支持 DAG 框架的产生。因此，支持 DAG 的框架被划分为第二代计算引擎。如 Tez 以及更上层的 Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。接下来就是以 Spark 为代表的第三代的计算引擎。第三代计算引擎的特点主要是 Job 内部的 DAG 支持（不跨越 Job），以及实时计算。</p><p>​这里所谓的有向无环图，并不是真正意义的图形，而是由Spark程序直接映射成的数据流的高级抽象模型。简单理解就是将整个程序计算的执行过程用图形表示出来,这样更直观，更便于理解，可以用于表示程序的拓扑结构。</p><p>​DAG（Directed Acyclic Graph）有向无环图是由点和线组成的拓扑图形，该图形具有方向，不会闭环。</p><h3 id="3-4-提交流程"><a href="#3-4-提交流程" class="headerlink" title="3.4 提交流程"></a>3.4 提交流程</h3><p>​所谓的提交流程，其实就是我们开发人员根据需求写的应用程序通过Spark客户端提交给Spark运行环境执行计算的流程。在不同的部署环境中，这个提交过程基本相同，但是又有细微的区别，我们这里不进行详细的比较，但是因为国内工作中，将Spark引用部署到Yarn环境中会更多一些，所以本课程中的提交流程是基于Yarn环境的。</p><p><img src="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/1662463151910.png" alt="1662463151910"></p><p>​Spark应用程序提交到Yarn环境中执行的时候，一般会有两种部署执行的方式：Client和Cluster。两种模式主要区别在于：Driver程序的运行节点位置。</p><h2 id="4-提交流程"><a href="#4-提交流程" class="headerlink" title="4. 提交流程"></a>4. 提交流程</h2><h3 id="4-1-Client"><a href="#4-1-Client" class="headerlink" title="4.1 Client"></a>4.1 Client</h3><p>​Client模式将用于监控和调度的Driver模块在客户端执行，而不是在Yarn中，所以一般用于测试。</p><p>Ø  Driver在任务提交的本地机器上运行</p><p>Ø  Driver启动后会和ResourceManager通讯申请启动ApplicationMaster</p><p>Ø  ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，负责向ResourceManager申请Executor内存</p><p>Ø  ResourceManager接到ApplicationMaster的资源申请后会分配container，然后ApplicationMaster在资源分配指定的NodeManager上启动Executor进程</p><p>Ø  Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数</p><p>Ø  之后执行到Action算子时，触发一个Job，并根据宽依赖开始划分stage，每个stage生成对应的TaskSet，之后将task分发到各个Executor上执行。</p><h3 id="4-2-Cluster"><a href="#4-2-Cluster" class="headerlink" title="4.2 Cluster"></a>4.2 Cluster</h3><p>​Cluster模式将用于监控和调度的Driver模块启动在Yarn集群资源中执行。一般应用于实际生产环境。</p><p>Ø  在YARN Cluster模式下，任务提交后会和ResourceManager通讯申请启动ApplicationMaster，</p><p>Ø  随后ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，此时的ApplicationMaster就是Driver。</p><p>Ø  Driver启动后向ResourceManager申请Executor内存，ResourceManager接到ApplicationMaster的资源申请后会分配container，然后在合适的NodeManager上启动Executor进程</p><p>Ø  Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数，</p><p>Ø  之后执行到Action算子时，触发一个Job，并根据宽依赖开始划分stage，每个stage生成对应的TaskSet，之后将task分发到各个Executor上执行。</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> cluster </tag>
            
            <tag> Driver </tag>
            
            <tag> Executor </tag>
            
            <tag> DAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark运行环境</title>
      <link href="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Local模式"><a href="#1-Local模式" class="headerlink" title="1. Local模式"></a>1. Local模式</h2><p>​这里的local模式指的并不是我们在IDEA中的运行环境，在IDEA中本身并不存在spark环境，在每一次运行的时候创建，运行结束环境就释放了。这种环境只是用来开发测试使用，称为开发环境。</p><h3 id="1-1-解压缩文件"><a href="#1-1-解压缩文件" class="headerlink" title="1.1 解压缩文件"></a>1.1 解压缩文件</h3><p>​将spark-3.0.0-bin-hadoop3.2.tgz文件上传到Linux并解压缩，放置在指定位置，路径中不要包含中文或空格，课件后续如果涉及到解压缩操作，不再强调。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module </span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-local</span><br></pre></td></tr></table></figure><h3 id="1-2-Local环境"><a href="#1-2-Local环境" class="headerlink" title="1.2 Local环境"></a>1.2 Local环境</h3><p>进入解压目录后，使用如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-shell</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662455754090.png" alt="1662455754090"></p><h3 id="1-3-提交应用"><a href="#1-3-提交应用" class="headerlink" title="1.3 提交应用"></a>1.3 提交应用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master local[2] \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure><ul><li>–class表示要执行程序的主类，此处可以更换为咱们自己写的应用程序</li><li>–master local[2] 部署模式，默认为本地模式，数字表示分配的虚拟CPU核数量</li><li>spark-examples_2.12-3.0.0.jar 运行的应用类所在的jar包，实际使用时，可以设定为咱们自己打的jar包</li><li>数字10表示程序的入口参数，用于设定当前应用的任务数量</li></ul><h2 id="2-Standalone模式"><a href="#2-Standalone模式" class="headerlink" title="2. Standalone模式"></a>2. Standalone模式</h2><p>​local本地模式毕竟只是用来进行练习演示的，真实工作中还是要将应用提交到对应的集群中去执行，这里我们来看看只使用Spark自身节点运行的集群模式，也就是我们所谓的独立部署（Standalone）模式。Spark的Standalone模式体现了经典的master-slave模式。</p><p>集群规划：</p><table><thead><tr><th></th><th>Linux1</th><th>Linux2</th><th>Linux3</th></tr></thead><tbody><tr><td>Spark</td><td>Worker    Master</td><td>Worker</td><td>Worker</td></tr></tbody></table><h3 id="2-1-解压缩文件"><a href="#2-1-解压缩文件" class="headerlink" title="2.1 解压缩文件"></a>2.1 解压缩文件</h3><p>​将spark-3.0.0-bin-hadoop3.2.tgz文件上传到Linux并解压缩在指定位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module </span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-standalone</span><br></pre></td></tr></table></figure><h3 id="2-2-修改配置文件"><a href="#2-2-修改配置文件" class="headerlink" title="2.2 修改配置文件"></a>2.2 修改配置文件</h3><ol><li>进入解压缩后路径的conf目录，修改slaves.template文件名为slaves</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv slaves.template slaves</span><br></pre></td></tr></table></figure><ol start="2"><li>修改slaves文件，添加worker节点</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux1</span><br><span class="line">linux2</span><br><span class="line">linux3</span><br></pre></td></tr></table></figure><ol start="3"><li>修改spark-env.sh.template文件名为spark-env.sh</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure><ol start="4"><li>修改spark-env.sh文件，添加JAVA_HOME环境变量和集群对应的master节点</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">SPARK_MASTER_HOST=linux1</span><br><span class="line">SPARK_MASTER_PORT=7077</span><br></pre></td></tr></table></figure><ol start="5"><li>r然后把spark传送到其它worker节点上</li></ol><h3 id="2-3-启动集群"><a href="#2-3-启动集群" class="headerlink" title="2.3 启动集群"></a>2.3 启动集群</h3><p>集群启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662456316655.png" alt="1662456316655"></p><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662456324286.png" alt="1662456324286"></p><h3 id="2-4-提交应用"><a href="#2-4-提交应用" class="headerlink" title="2.4 提交应用"></a>2.4 提交应用</h3><p>提交应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://hadoop102:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure><ol><li>–class表示要执行程序的主类</li><li>–master spark:&#x2F;&#x2F;linux1:7077 独立部署模式，连接到Spark集群</li><li>spark-examples_2.12-3.0.0.jar 运行类所在的jar包</li><li>数字10表示程序的入口参数，用于设定当前应用的任务数量</li></ol><p>执行任务时，会产生多个Java进程</p><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662456437706.png" alt="1662456437706"></p><p>执行任务时，默认采用服务器集群节点的总核数，每个节点内存1024M</p><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662456456803.png" alt="1662456456803"></p><h3 id="2-5-提交参数说明"><a href="#2-5-提交参数说明" class="headerlink" title="2.5 提交参数说明"></a>2.5 提交参数说明</h3><p>​在提交应用中，一般会同时一些提交参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class &lt;main-class&gt;</span><br><span class="line">--master &lt;master-url&gt; \</span><br><span class="line">... # other options</span><br><span class="line">&lt;application-jar&gt; \</span><br><span class="line">[application-arguments]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th><th>可选值举例</th></tr></thead><tbody><tr><td>–class</td><td>Spark程序中包含主函数的类</td><td></td></tr><tr><td>–master</td><td>Spark程序运行的模式(环境)</td><td>模式：local[*]、spark:&#x2F;&#x2F;linux1:7077、   Yarn</td></tr><tr><td>–executor-memory   1G</td><td>指定每个executor可用内存为1G</td><td></td></tr><tr><td>–total-executor-cores   2</td><td>指定所有executor使用的cpu核数为2个</td><td></td></tr><tr><td>–executor-cores</td><td>指定每个executor使用的cpu核数</td><td></td></tr><tr><td>application-jar</td><td>打包好的应用jar，包含依赖。这个URL在集群中全局可见。 比如hdfs:&#x2F;&#x2F; 共享存储系统，如果是file:&#x2F;&#x2F;   path，那么所有的节点的path都包含同样的jar</td><td></td></tr><tr><td>application-arguments</td><td>传给main()方法的参数</td><td></td></tr></tbody></table><h3 id="2-6-配置历史服务"><a href="#2-6-配置历史服务" class="headerlink" title="2.6 配置历史服务"></a>2.6 配置历史服务</h3><p>​由于spark-shell停止掉后，集群监控linux1:4040页面就看不到历史任务的运行情况，所以开发时都配置历史服务器记录任务运行情况。</p><ol><li>修改spark-defaults.conf.template文件名为spark-defaults.conf</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-defaults.conf.template spark-defaults.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>修改spark-default.conf文件，配置日志存储路径</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.eventLog.enabled           true</span><br><span class="line">spark.eventLog.dir               hdfs://hadoop102:8020/directory</span><br></pre></td></tr></table></figure><p>注意：需要启动hadoop集群，HDFS上的directory目录需要提前存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">hadoop fs -mkdir /directory</span><br></pre></td></tr></table></figure><ol start="3"><li>修改spark-env.sh文件, 添加日志配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HISTORY_OPTS=&quot;</span><br><span class="line">-Dspark.history.ui.port=18080 </span><br><span class="line">-Dspark.history.fs.logDirectory=hdfs://hadoop102:8020/directory </span><br><span class="line">-Dspark.history.retainedApplications=30&quot;</span><br></pre></td></tr></table></figure><ul><li><p>参数1含义：WEB UI访问的端口号为18080</p></li><li><p>参数2含义：指定历史服务器日志存储路径</p></li><li><p>参数3含义：指定保存Application历史记录的个数，如果超过这个值，旧的应用程序信息将被删除，这个是内存中的应用数，而不是页面上显示的应用数。</p></li></ul><ol start="4"><li><p>分发配置文件</p></li><li><p>重新启动集群和历史服务</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure><ol start="6"><li>重新执行任务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="3-Yarn模式"><a href="#3-Yarn模式" class="headerlink" title="3. Yarn模式"></a>3. Yarn模式</h2><p>​独立部署（Standalone）模式由Spark自身提供计算资源，无需其他框架提供资源。这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但是你也要记住，Spark主要是计算框架，而不是资源调度框架，所以本身提供的资源调度并不是它的强项，所以还是和其他专业的资源调度框架集成会更靠谱一些。所以接下来我们来学习在强大的Yarn环境下Spark是如何工作的（其实是因为在国内工作中，Yarn使用的非常多）。</p><h3 id="3-1-解压缩文件"><a href="#3-1-解压缩文件" class="headerlink" title="3.1 解压缩文件"></a>3.1 解压缩文件</h3><p>​将spark-3.0.0-bin-hadoop3.2.tgz文件上传到Linux并解压缩在指定位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module </span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-standalone</span><br></pre></td></tr></table></figure><h3 id="3-2-修改配置文件"><a href="#3-2-修改配置文件" class="headerlink" title="3.2 修改配置文件"></a>3.2 修改配置文件</h3><ol><li><p>修改hadoop配置文件&#x2F;opt&#x2F;module&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;yarn-site.xml, 并分发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改conf&#x2F;spark-env.sh，添加JAVA_HOME和YARN_CONF_DIR配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">。。。</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_212</span><br><span class="line">YARN_CONF_DIR=/opt/module/hadoop-3.1.3/etc/hadoop</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-启动HDFS以及YARN集群"><a href="#3-3-启动HDFS以及YARN集群" class="headerlink" title="3.3 启动HDFS以及YARN集群"></a>3.3 启动HDFS以及YARN集群</h3><h3 id="3-4-提交应用"><a href="#3-4-提交应用" class="headerlink" title="3.4 提交应用"></a>3.4 提交应用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>​上述参数–deploy-mode 的参数值为cluster，这个值代表集群的意思</p><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662458813213.png" alt="1662458813213"></p><h3 id="3-5-配置历史服务器"><a href="#3-5-配置历史服务器" class="headerlink" title="3.5 配置历史服务器"></a>3.5 配置历史服务器</h3><p>​这部分配置历史服务器的步骤和standalone的步骤是一样的。</p><h2 id="4-K8S以及Mesos模式"><a href="#4-K8S以及Mesos模式" class="headerlink" title="4. K8S以及Mesos模式"></a>4. K8S以及Mesos模式</h2><p>​<strong>Yarn就是模仿的Mesos模式</strong></p><p>​Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核,在Twitter得到广泛使用,管理着Twitter超过30,0000台服务器上的应用部署，但是在国内，依然使用着传统的Hadoop大数据框架，所以国内使用Mesos框架的并不多，但是原理其实都差不多，这里我们就不做过多讲解了。</p><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662459085316.png" alt="1662459085316"></p><p>​容器化部署是目前业界很流行的一项技术，基于Docker镜像运行能够让用户更加方便地对应用进行管理和运维。容器管理工具中最为流行的就是Kubernetes（k8s），而Spark也在最近的版本中支持了k8s部署模式。这里我们也不做过多的讲解。给个链接大家自己感受一下：<a href="https://spark.apache.org/docs/latest/running-on-kubernetes.html">https://spark.apache.org/docs/latest/running-on-kubernetes.html</a></p><p><img src="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/1662459137194.png" alt="1662459137194"></p><h2 id="5-Windows模式"><a href="#5-Windows模式" class="headerlink" title="5. Windows模式"></a>5. Windows模式</h2><p>​在同学们自己学习时，每次都需要启动虚拟机，启动集群，这是一个比较繁琐的过程，并且会占大量的系统资源，导致系统执行变慢，不仅仅影响学习效果，也影响学习进度，Spark非常暖心地提供了可以在windows系统下启动本地集群的方式，这样，在不使用虚拟机的情况下，也能学习Spark的基本使用</p>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> yarn </tag>
            
            <tag> standalone </tag>
            
            <tag> local </tag>
            
            <tag> windows </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark为什么要学</title>
      <link href="/2022/09/05/Spark/spark_wordcount/"/>
      <url>/2022/09/05/Spark/spark_wordcount/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么要学习Spark"><a href="#1-为什么要学习Spark" class="headerlink" title="1. 为什么要学习Spark"></a>1. 为什么要学习Spark</h2><h3 id="1-1-Hadoop的缺点"><a href="#1-1-Hadoop的缺点" class="headerlink" title="1.1 Hadoop的缺点"></a>1.1 Hadoop的缺点</h3><p>主要是因为Hadoop有很多的缺点。有着很大的局限性</p><ol><li><p>NameNode是单点的，容易出现单点故障问题，制约了集群的发展</p></li><li><p>nameNode单点，受到硬件的制约，制约了集群的发展</p></li><li><p>MR速度太慢，主要是由于设计理念的问题</p><p>MR就是用于单一数据计算，当前数据挖掘和数据迭代计算不适用，而且每一次都落盘操作，都极大减少了性能</p></li><li><p>MR框架和Hadoop耦合性太强了，无法分离</p></li></ol><p>因此最终出现了很多的框架，Spark以及Flink、Hive等框架</p><h3 id="1-2-Spark的优点及介绍"><a href="#1-2-Spark的优点及介绍" class="headerlink" title="1.2 Spark的优点及介绍"></a>1.2 Spark的优点及介绍</h3><ol><li>Spark基于MR框架，但是优化了其中的计算过程，使用内存来代替计算结果</li><li>Spark基于Scala开发，更适合迭代计算和数据挖掘计算</li><li>Spark中计算模型非常丰富，hadoop中只有map和reduce，过于单调，很多东西很难去实现，但是spark中存在很多的算子（map、filter、groupBy等等）。</li></ol><h3 id="1-3-Spark-On-Yarn"><a href="#1-3-Spark-On-Yarn" class="headerlink" title="1.3 Spark On Yarn"></a>1.3 Spark On Yarn</h3><p><img src="/2022/09/05/Spark/spark_wordcount/1662390136020.png" alt="1662390136020"></p><h2 id="2-Spark-的wordcount案例实现"><a href="#2-Spark-的wordcount案例实现" class="headerlink" title="2. Spark 的wordcount案例实现"></a>2. Spark 的wordcount案例实现</h2><p><strong>简易版wordCount</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiang.bigdata.spark.wordcount</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">spark01_wordcount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1. 获取Spark的连接（环境）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;wordCount&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lines = sc.textFile(<span class="string">&quot;data/data1.txt&quot;</span>)</span><br><span class="line">    lines</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .groupBy(word=&gt;word)</span><br><span class="line">      .mapValues(_.size)</span><br><span class="line">      .foreach(println(_))</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> wordCont </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala概述</title>
      <link href="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Scala入门"><a href="#1-Scala入门" class="headerlink" title="1. Scala入门"></a>1. Scala入门</h2><h3 id="1-1-为什么要学习Scala"><a href="#1-1-为什么要学习Scala" class="headerlink" title="1.1 为什么要学习Scala"></a>1.1 为什么要学习Scala</h3><p>​在之前的学习中，我们已经学习了很长时间的Java语言，为什么此时要学习一门新的语言呢？主要基于以下几个原因：</p><ol><li><p>大数据主要的批处理计算引擎框架Spark是基于Scala语言开发的</p></li><li><p>大数据主要的流式计算引擎框架Flink也提供了Scala相应的API</p></li><li><p>大数据领域中函数式编程的开发效率更高，更直观，更容易理解</p></li></ol><h2 id="2-变量和数据类型"><a href="#2-变量和数据类型" class="headerlink" title="2. 变量和数据类型"></a>2. 变量和数据类型</h2><h3 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h3><p>其实注释跟java一样</p><p><strong>单行注释：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaComment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 单行注释</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多行注释：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaComment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           多行注释</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文档注释：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * doc注释</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaComment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><p>​变量是一种使用方便的占位符，用于引用计算机内存地址，变量创建后会占用一定的内存空间。基于变量的数据类型，操作系统会进行内存分配并且决定什么将被储存在保留内存中。因此，通过给变量分配不同的数据类型，你可以在这些变量中存储整数，小数或者字母。</p><h4 id="2-2-1-语法声明"><a href="#2-2-1-语法声明" class="headerlink" title="2.2.1 语法声明"></a>2.2.1 语法声明</h4><p><strong>在Scala之中变量的类型在变量名之后等号之前声明。</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaVariable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// var | val 变量名 ：变量类型 = 变量值</span></span><br><span class="line">        <span class="comment">// 用户名称</span></span><br><span class="line">        <span class="keyword">var</span> username : <span class="type">String</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        <span class="comment">// 用户密码</span></span><br><span class="line">        <span class="keyword">val</span> userpswd : <span class="type">String</span> = <span class="string">&quot;000000&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​变量的类型如果能够通过变量值推断出来，那么可以省略类型声明，这里的省略，并不是不声明，而是由Scala编译器在编译时自动声明编译的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaVariable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 因为变量值为字符串，又因为Scala是静态类型语言，所以即使不声明类型</span></span><br><span class="line">        <span class="comment">// Scala也能在编译时正确的判断出变量的类型，这体现了Scala语言的简洁特性。</span></span><br><span class="line">        <span class="keyword">var</span> username = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        <span class="keyword">val</span> userpswd = <span class="string">&quot;000000&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-变量的初始化"><a href="#2-2-2-变量的初始化" class="headerlink" title="2.2.2 变量的初始化"></a>2.2.2 变量的初始化</h4><p>​Java语法中变量在使用前进行初始化就可以，但是Scala语法中是不允许的，必须显示进行初始化操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaVariable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> username <span class="comment">// Error</span></span><br><span class="line">        <span class="keyword">val</span> username = <span class="string">&quot;zhangsan&quot;</span> <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-可变变量"><a href="#2-2-3-可变变量" class="headerlink" title="2.2.3 可变变量"></a>2.2.3 可变变量</h4><p>​值可以改变的变量，称之为可变变量，但是变量类型无法发生改变, Scala中可变变量使用关键字var进行声明</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaVariable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 用户名称</span></span><br><span class="line">        <span class="keyword">var</span> username : <span class="type">String</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        username = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line">        username = <span class="literal">true</span> <span class="comment">// Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-不可变变量"><a href="#2-2-4-不可变变量" class="headerlink" title="2.2.4 不可变变量"></a>2.2.4 不可变变量</h4><p>​值一旦初始化后无法改变的变量，称之为不可变变量。Scala中不可变变量使用关键字val进行声明, 类似于Java语言中的final关键字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaVariable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 用户名称</span></span><br><span class="line">        <span class="keyword">val</span> username : <span class="type">String</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        username = <span class="string">&quot;lisi&quot;</span> <span class="comment">// Error</span></span><br><span class="line">        username = <span class="literal">true</span> <span class="comment">// Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-标识符"><a href="#2-3-标识符" class="headerlink" title="2.3 标识符"></a>2.3 标识符</h3><p>​Scala 可以使用两种形式的标志符，字符数字和符号。</p><ol><li><p>字符数字使用字母或是下划线开头，后面可以接字母或是数字，符号”$”在 Scala 中也看作为字母。然以”$”开头的标识符为保留的 Scala 编译器产生的标志符使用，应用程序应该避免使用”$”开始的标识符，以免造成冲突。(下划线开头的变量是为了给函数式编程最简化的时候使用的)</p></li><li><p>Scala 的命名规范采用和 Java 类似的 camel 命名规范，首字符小写，比如 toString。类名的首字符还是使用大写。此外也应该避免使用以下划线结尾的标志符以避免冲突。</p></li><li><p>Scala 内部实现时会使用转义的标志符，比如:-&gt; 使用 $colon$minus$greater 来表示这个符号。</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和Java一样的标识符命名规则</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;zhangsan&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> name1 = <span class="string">&quot;zhangsan0&quot;</span>   <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val 1name = &quot;zhangsan0&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> name$ = <span class="string">&quot;zhangsan1&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> $name = <span class="string">&quot;zhangsan2&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> name_ = <span class="string">&quot;zhangsan3&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> _name = <span class="string">&quot;zhangsan4&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> $ = <span class="string">&quot;zhangsan5&quot;</span>     <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> _ = <span class="string">&quot;zhangsan6&quot;</span>     <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val 1 = &quot;zhangsan6&quot;     // Error</span></span><br><span class="line"><span class="comment">//val true = &quot;zhangsan6&quot;  // Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和Java不一样的标识符命名规则</span></span><br><span class="line"><span class="keyword">val</span> + = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> - = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> * = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> / = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> ! = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val @ = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> @@ = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val # = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> ## = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> % = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> ^ = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> &amp; = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val ( = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val ( = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val ) = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val = = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> == = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val [ = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val ] = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val : = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> :: = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val ; = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val &#x27; = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="comment">//val &quot; = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> <span class="string">&quot;&quot;</span> = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> &lt; = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> &gt; = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> ? = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> | = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> \ = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">//val ` = &quot;lisi&quot; // Error</span></span><br><span class="line"><span class="keyword">val</span> ~ = <span class="string">&quot;lisi&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> :-&gt; = <span class="string">&quot;wangwu&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">val</span> :-&lt; = <span class="string">&quot;wangwu&quot;</span> <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// 切记，能声明和能使用是两回事</span></span><br></pre></td></tr></table></figure><p>​Scala 中的标识符也不能是<strong>关键字</strong>或<strong>保留字</strong>，那么Scala中有多少关键字或保留字呢？</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662171736524.png" alt="1662171736524"></p><h3 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4  字符串"></a>2.4  字符串</h3><p>​在 Scala 中，字符串的类型实际上就是 Java中的 String类，它本身是没有 String 类的。</p><p>​在 Scala 中，String 是一个不可变的字符串对象，所以该对象不可被修改。这就意味着你如果修改字符串就会产生一个新的字符串对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> name : <span class="type">String</span> = <span class="string">&quot;scala&quot;</span></span><br><span class="line">        <span class="keyword">val</span> subname : <span class="type">String</span> = name.substring(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串的连接</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 字符串连接</span></span><br><span class="line">        println(<span class="string">&quot;Hello &quot;</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传值字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object ScalaString &#123;</span><br><span class="line">    def main(args: Array[String]): Unit = &#123;</span><br><span class="line">        // 传值字符串(格式化字符串)</span><br><span class="line">        printf(&quot;name=%s\n&quot;, name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插值字符串</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 插值字符串</span></span><br><span class="line">        <span class="comment">// 将变量值插入到字符串</span></span><br><span class="line">        println(<span class="string">s&quot;name=<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多行字符串</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 多行格式化字符串</span></span><br><span class="line">        <span class="comment">// 在封装JSON或SQL时比较常用</span></span><br><span class="line">        <span class="comment">// | 默认顶格符</span></span><br><span class="line">        println(</span><br><span class="line">                    <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                      | Hello</span></span><br><span class="line"><span class="string">                      | $&#123;name&#125;</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-输入输出"><a href="#2-5-输入输出" class="headerlink" title="2.5 输入输出"></a>2.5 输入输出</h3><p><strong>输入</strong></p><p><strong>控制台中输入</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaIn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 标准化屏幕输入</span></span><br><span class="line">        <span class="keyword">val</span> age : <span class="type">Int</span> = scala.io.<span class="type">StdIn</span>.readInt()</span><br><span class="line">        println(age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件中获取输入</strong></p><p>​<strong>在这里要格外注意的一个点是：IDEA的基准路径是项目的根路径</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaIn</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 请注意文件路径的位置</span></span><br><span class="line">        scala.io.<span class="type">Source</span>.fromFile(<span class="string">&quot;input/user.json&quot;</span>).foreach(</span><br><span class="line">            line =&gt; &#123;</span><br><span class="line">                print(line)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">scala.io.<span class="type">Source</span>.fromFile(<span class="string">&quot;input/user.json&quot;</span>).getLines()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>输出</strong></p><p>Scala进行文件写操作，用的都是 java中的I&#x2F;O类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;output/test.txt&quot;</span> ))</span><br><span class="line">      writer.write(<span class="string">&quot;Hello Scala&quot;</span>)</span><br><span class="line">      writer.close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-数据类型"><a href="#2-6-数据类型" class="headerlink" title="2.6 数据类型"></a>2.6 数据类型</h3><h4 id="2-6-1-Java数据类型"><a href="#2-6-1-Java数据类型" class="headerlink" title="2.6.1 Java数据类型"></a>2.6.1 Java数据类型</h4><p>Java的数据类型包含基本类型和引用类型</p><ul><li>基本类型：byte,short,char,int,long,float,double,boolean</li><li>引用类型：Object，数组，字符串，包装类，集合，POJO对象等</li></ul><h4 id="2-6-2-Scala数据类型"><a href="#2-6-2-Scala数据类型" class="headerlink" title="2.6.2 Scala数据类型"></a>2.6.2 Scala数据类型</h4><p>​Scala是完全面向对象的语言，所以不存在基本数据类型的概念，有的只是任意值对象类型（AnyVal）和任意引用对象类型(AnyRef)</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662173261301.png" alt="1662173261301"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662173289280.png" alt="1662173289280"></p><p><strong>其中unit相当于java中的void类型，如果打印这个unit，会在控制台输出一对小括号</strong></p><p><strong>Nothing是Scala语言中特殊的类型，用于统一方法的异常和正常的返回</strong></p><h3 id="2-7-类型转换"><a href="#2-7-类型转换" class="headerlink" title="2.7 类型转换"></a>2.7 类型转换</h3><p><strong>自动类型转换</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaDataType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> b : <span class="type">Byte</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> s : <span class="type">Short</span> = b</span><br><span class="line">        <span class="keyword">val</span> i : <span class="type">Int</span> = s</span><br><span class="line">        <span class="keyword">val</span> lon : <span class="type">Long</span> = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强制类型转换</strong></p><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)a</span><br></pre></td></tr></table></figure><p>Scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a : <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="type">Var</span> b : <span class="type">Byte</span> = a.toByte</span><br><span class="line"><span class="comment">// 基本上Scala的AnyVal类型之间都提供了相应转换的方法。</span></span><br></pre></td></tr></table></figure><p><strong>字符串类型转换</strong></p><p>Scala是完全面向对象的语言，所有的类型都提供了toString方法，可以直接转换为字符串</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lon.toString</span><br></pre></td></tr></table></figure><p>任意类型都提供了和字符串进行拼接的方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;hello &quot;</span> + i</span><br></pre></td></tr></table></figure><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p><strong>算数运算符</strong></p><p>​假定变量A为10，B为20</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662177203231.png" alt="1662177203231"></p><p><strong>关系运算符</strong></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662177232207.png" alt="1662177232207"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662177373542.png" alt="1662177373542"></p><p>目前的理解：</p><p>​第一行其实是和第二行一样的，scala会把等于等于号自动调用equals方法，而第三行则是相当于java中的&#x3D;&#x3D;，就是比较地址，因此只有第三行返回false</p><p><strong>赋值运算符</strong></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662179792587.png" alt="1662179792587"></p><p>在Scala中取消了++ 、–运算符</p><p><strong>逻辑运算符</strong></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662179824788.png" alt="1662179824788"></p><p><strong>位运算符</strong></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662179946296.png" alt="1662179946296"></p><p><strong>运算符本质</strong></p><p>​在Scala中其实是没有运算符的，所有的运算符都是方法</p><ul><li><p>Scala是完全面向对象的语言，所以数字其实也是对象</p></li><li><p>当调用对象的方法时，点.可以省略</p></li><li><p>如果函数参数只有一个，或者没有参数，()可以省略</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaOper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> i : <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> j : <span class="type">Int</span> = i.+(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> k : <span class="type">Int</span> = j +(<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">val</span> m : <span class="type">Int</span> = k + <span class="number">30</span></span><br><span class="line">        println(m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4. 流程控制"></a>4. 流程控制</h2><h3 id="4-1-for循环"><a href="#4-1-for循环" class="headerlink" title="4.1 for循环"></a>4.1 for循环</h3><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( 循环变量 &lt;- 数据集 ) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这里的数据集可以是任意类型的数据集合，如字符串，集合，数组等，这里我们还没有讲到集合，数组语法，请大家不要着急，先能演示例子，后面咱们详细讲。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) ) &#123; <span class="comment">// 范围集合</span></span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">5</span> ) &#123; <span class="comment">// 包含5</span></span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> until <span class="number">5</span> ) &#123; <span class="comment">// 不包含5</span></span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环守卫</strong></p><p>​循环时可以增加条件来决定是否继续循环体的执行,这里的判断条件我们称之为循环守卫</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> i != <span class="number">3</span>  ) &#123;</span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环步长</strong></p><p>​scala的集合也可以设定循环的增长幅度，也就是所谓的步长step</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>) ) &#123;</span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">5</span> by <span class="number">2</span> ) &#123;</span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环嵌套</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>); j &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">4</span>) ) &#123;</span><br><span class="line">            println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;,j = &quot;</span> + j )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( j &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">4</span>) ) &#123;</span><br><span class="line">                println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;,j = &quot;</span> + j )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环返回值</strong></p><p>​Scala所有的表达式都是有返回值的。但是这里的返回值并不一定都是有值的哟。</p><p>​如果希望for循环表达式的返回值有具体的值，需要使用关键字yield</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) ) <span class="keyword">yield</span> &#123;</span><br><span class="line">            i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662181090945.png" alt="1662181090945"></p><h3 id="4-2-While循环"><a href="#4-2-While循环" class="headerlink" title="4.2 While循环"></a>4.2 While循环</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> ( i &lt; <span class="number">5</span> ) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">5</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125; <span class="keyword">while</span> ( i &lt; <span class="number">5</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-循环中断"><a href="#4-3-循环中断" class="headerlink" title="4.3 循环中断"></a>4.3 循环中断</h3><p>​Scala是完全面向对象的语言，所以无法使用break，continue关键字这样的方式来中断，或继续循环逻辑，而是采用了函数式编程的方式代替了循环语法中的break和continue</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        scala.util.control.<span class="type">Breaks</span>.breakable &#123;</span><br><span class="line">            <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">5</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i == <span class="number">3</span> ) &#123;</span><br><span class="line">                    scala.util.control.<span class="type">Breaks</span>.<span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                println(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-基础函数编程"><a href="#5-基础函数编程" class="headerlink" title="5. 基础函数编程"></a>5. 基础函数编程</h2><h3 id="5-1-基本语法"><a href="#5-1-基本语法" class="headerlink" title="5.1 基本语法"></a>5.1 基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="function"><span class="keyword">def</span> <span class="title">函数名</span> </span>( 参数列表 ) [:返回值类型] = &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>( s : <span class="type">String</span> ) : <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-函数-amp-方法"><a href="#5-2-函数-amp-方法" class="headerlink" title="5.2 函数&amp;方法"></a>5.2 函数&amp;方法</h3><ul><li><p>Scala 中存在方法与函数两个不同的概念，二者在语义上的区别很小。scala 方法是类的一部分，而函数是一个对象，可以赋值给一个变量。换句话来说在类中定义的函数即是方法。scala 中的方法跟 Java 的类似，方法是组成类的一部分。scala 中的函数则是一个完整的对象。</p></li><li><p>Scala中的方法和函数从语法概念上来讲，一般不好区分，所以简单的理解就是：方法也是函数。只不过类中声明的函数称之为方法，其他场合声明的就是函数了。类中的方法是有重载和重写的。<strong>而函数可就没有重载和重写的概念</strong>了，<strong>但是函数可以嵌套声明使用，方法就没有这个能力</strong>了。</p></li></ul><p>函数不强调属于谁，只是功能的封装，函数的本质上其实也是一个方法，编译成java字节码文件的时候，会在当前类中添加一个方法，不过会增加private static final 这几个关键字，因此他的作用范围比较小，而且不可以被重载。</p><p>方法也是功能的封装，但是更强调属于谁</p><h3 id="5-3-函数定义"><a href="#5-3-函数定义" class="headerlink" title="5.3 函数定义"></a>5.3 函数定义</h3><p><strong>无参，无返回值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(<span class="string">&quot;函数体&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数定义的时候没有参数，调用函数的时候可以把括号删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object ScalaFunction &#123;</span><br><span class="line">    def main(args: Array[String]): Unit = &#123;</span><br><span class="line">        def fun1(): Unit = &#123;</span><br><span class="line">            println(&quot;函数体&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        fun1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无参，有返回值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        println( fun2() )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有参，无返回值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>( name:<span class="type">String</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name )</span><br><span class="line">        &#125;</span><br><span class="line">        fun3(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有参有返回值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun4</span></span>(name:<span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="string">&quot;Hello &quot;</span> + name</span><br><span class="line">        &#125;</span><br><span class="line">        println( fun4(<span class="string">&quot;zhangsan&quot;</span>) )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多参，无返回值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(hello:<span class="type">String</span>, name:<span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( hello + <span class="string">&quot; &quot;</span> + name )</span><br><span class="line">        &#125;</span><br><span class="line">        fun5(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多参，有返回值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun6</span></span>(hello:<span class="type">String</span>, name:<span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">            hello + <span class="string">&quot; &quot;</span> + name</span><br><span class="line">        &#125;</span><br><span class="line">        println( fun6(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-函数参数"><a href="#5-4-函数参数" class="headerlink" title="5.4 函数参数"></a>5.4 函数参数</h3><p><strong>可变参数</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun7</span></span>(names:<span class="type">String</span>*): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(names)</span><br><span class="line">        &#125;</span><br><span class="line">        fun7()</span><br><span class="line">        fun7( <span class="string">&quot;zhangsan&quot;</span> )</span><br><span class="line">        fun7( <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可变参数不能放置在参数列表的前面，一般放置在参数列表的最后</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// Error</span></span><br><span class="line">        <span class="comment">//def fun77(names:String*, name:String): Unit = &#123;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun777</span></span>( name:<span class="type">String</span>, names:<span class="type">String</span>* ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name )</span><br><span class="line">            println( names )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数默认值</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun8</span></span>( name:<span class="type">String</span>, password:<span class="type">String</span> = <span class="string">&quot;000000&quot;</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name + <span class="string">&quot;,&quot;</span> + password )</span><br><span class="line">        &#125;</span><br><span class="line">        fun8(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123123&quot;</span>)</span><br><span class="line">        fun8(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带名参数</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun9</span></span>( password:<span class="type">String</span> = <span class="string">&quot;000000&quot;</span>, name:<span class="type">String</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name + <span class="string">&quot;,&quot;</span> + password )</span><br><span class="line">        &#125;</span><br><span class="line">        fun9(<span class="string">&quot;123123&quot;</span>, <span class="string">&quot;zhangsan&quot;</span> )</span><br><span class="line">        fun9(name=<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-函数至简原则（重点）"><a href="#5-5-函数至简原则（重点）" class="headerlink" title="5.5 函数至简原则（重点）"></a>5.5 函数至简原则（重点）</h3><p>​所谓的至简原则，其实就是Scala的作者为了开发人员能够大幅度提高开发效率。通过编译器的动态判定功能，帮助我们将函数声明中能简化的地方全部都进行了简化。也就是说将函数声明中那些能省的地方全部都省掉。所以这里的至简原则，简单来说就是：能省则省。</p><p><strong>省略return关键字</strong></p><p>函数会把最后一行代码的执行结果作为函数的返回值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun11</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>省略花括号</strong></p><p>如果逻辑代码只有一行，那么花括号可以省略</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(): <span class="type">String</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>省略返回值类型</strong></p><p>函数根据返回数据，判断出返回值类型，那么返回值类型可以省略</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>() = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>省略参数列表</strong></p><p>如果函数的参数列表没有声明任何的参数，那么参数列表可以删除</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun4</span> </span>= <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        fun4<span class="comment">// OK</span></span><br><span class="line">        fun4()<span class="comment">//(ERROR)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>省略等号</strong></p><p>​如果函数体中有明确的return语句，那么返回值类型不能省略</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(fun5())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果函数体返回值类型明确为Unit,那么函数体中即使有return关键字也不起作用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(fun5())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果函数体返回值类型声明为Unit,但是又想省略，那么此时就必须连同等号一起省略</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(fun5())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>省略名称和关键字（称为匿名函数）</strong></p><p>省略的同时需要把返回值类型也删除，同时再等号的后面增加一个箭头</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-高阶函数编程"><a href="#6-高阶函数编程" class="headerlink" title="6. 高阶函数编程"></a>6. 高阶函数编程</h2><p>​所谓的高阶函数，其实就是把函数当作一个类型去使用，而不是当作特定的语法结构。</p><h3 id="6-1-函数作为值"><a href="#6-1-函数作为值" class="headerlink" title="6.1 函数作为值"></a>6.1 函数作为值</h3><p>如果我们要把一个函数作为整体，而不是执行结果赋值给变量，那么需要采用特殊符号：下划线</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> a = fun1     <span class="comment">//这行代码是把fun1函数的返回结果赋值给了a变量</span></span><br><span class="line">        <span class="keyword">val</span> b = fun1 _   <span class="comment">//这行代码是把fun1当作一个对象赋值给了b变量</span></span><br><span class="line">        <span class="keyword">val</span> c : ()=&gt;<span class="type">Unit</span> = fun1    <span class="comment">//这行代码指定了c的类型，因此也是把fun1当作一个对象赋值给了c变量</span></span><br><span class="line">        println(a) </span><br><span class="line">        println(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-函数作为参数"><a href="#6-2-函数作为参数" class="headerlink" title="6.2 函数作为参数"></a>6.2 函数作为参数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>( i:<span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun22</span></span>( f : <span class="type">Int</span> =&gt; <span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            f(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(fun22(fun2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-函数作为返回值"><a href="#6-3-函数作为返回值" class="headerlink" title="6.3 函数作为返回值"></a>6.3 函数作为返回值</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>( i:<span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun33</span></span>( ) = &#123;</span><br><span class="line">            fun3 _</span><br><span class="line">        &#125;</span><br><span class="line">        println(fun33()(<span class="number">10</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-匿名函数"><a href="#6-4-匿名函数" class="headerlink" title="6.4 匿名函数"></a>6.4 匿名函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun4</span></span>( f:<span class="type">Int</span> =&gt; <span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            f(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(fun4((x:<span class="type">Int</span>)=&gt;&#123;x * <span class="number">20</span>&#125;))</span><br><span class="line">        println(fun4((x)=&gt;&#123;x * <span class="number">20</span>&#125;))</span><br><span class="line">        println(fun4((x)=&gt;x * <span class="number">20</span>))</span><br><span class="line">        println(fun4(x=&gt;x * <span class="number">20</span>))</span><br><span class="line">        println(fun4(_ * <span class="number">20</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662195343430.png" alt="1662195343430"></p><h3 id="6-5-控制抽象"><a href="#6-5-控制抽象" class="headerlink" title="6.5 控制抽象"></a>6.5 控制抽象</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun7</span></span>(op: =&gt; <span class="type">Unit</span>) = &#123;</span><br><span class="line">            op</span><br><span class="line">        &#125;</span><br><span class="line">        fun7&#123;</span><br><span class="line">            println(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以采用控制抽象设计语法，我们自己不常使用，语法框架使用的比较多</p><p>Scala的Breaks.breakable就是采用的控制抽象设计语法</p><h3 id="6-6-闭包"><a href="#6-6-闭包" class="headerlink" title="6.6 闭包"></a>6.6 闭包</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>() = &#123;</span><br><span class="line">            <span class="keyword">val</span> i = <span class="number">20</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">fun55</span></span>() = &#123;</span><br><span class="line">                i * <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            fun55 _</span><br><span class="line">        &#125;</span><br><span class="line">        fun5()()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一个函数使用了外部的变量，把这个变量包含到了它的内部来使用，改变了这个变量的生命周期</p><p>将当前的代码形成了一个闭合的环境，这个环境称之为闭包环境，简称为闭包</p><p> <img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662220084225.png" alt="1662220084225"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662220154275.png" alt="1662220154275"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662220430708.png" alt="1662220430708"></p><p>​</p><p>​本质上，就是在内部函数增加了形参个数，从而把外部的变量延长了声明周期，因此内部函数也可以使用外部变量。</p><p><strong>闭包形成的三种情况：</strong></p><ol><li>内部函数在外部使用的时候会产生闭包</li><li>将函数作为对象使用，会产生闭包</li><li>所有的匿名函数都会产生闭包</li></ol><h3 id="6-7-函数柯里化"><a href="#6-7-函数柯里化" class="headerlink" title="6.7 函数柯里化"></a>6.7 函数柯里化</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun6</span></span>(i:<span class="type">Int</span>)(j:<span class="type">Int</span>) = &#123;</span><br><span class="line">            i * j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-递归函数"><a href="#6-8-递归函数" class="headerlink" title="6.8 递归函数"></a>6.8 递归函数</h3><ol><li>Scala 中要求递归函数必须明确声明返回值类型</li><li>函数内部需要调用自身</li><li>一定要有跳出递归的逻辑</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun8</span></span>(j:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="keyword">if</span> ( j &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j * fun8(j<span class="number">-1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(fun8(<span class="number">5</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈内存溢出：</strong> 每一个线程都会有一个栈，当线程过多的时候，就会导致内存不够，从而出现栈内存溢出的错误</p><p><strong>栈滚动错误：</strong>每一个方法都会压栈，当递归使用函数的时候，如果不断的把函数压栈，当数目过多的时候，就是出现这个错误。</p><h3 id="6-9-惰性函数"><a href="#6-9-惰性函数" class="headerlink" title="6.9 惰性函数"></a>6.9 惰性函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun9</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            println(<span class="string">&quot;function...&quot;</span>)</span><br><span class="line">            <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">lazy</span> <span class="keyword">val</span> a = fun9()</span><br><span class="line">        println(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-面向对象编程"><a href="#7-面向对象编程" class="headerlink" title="7. 面向对象编程"></a>7. 面向对象编程</h2><h3 id="7-1-基础面向对象编程"><a href="#7-1-基础面向对象编程" class="headerlink" title="7.1 基础面向对象编程"></a>7.1 基础面向对象编程</h3><h4 id="7-1-1-包"><a href="#7-1-1-包" class="headerlink" title="7.1.1 包"></a>7.1.1 包</h4><p>​Scala中基本的package包语法和Java完全一致</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala</span><br></pre></td></tr></table></figure><p>Java中package包的语法比较单一，Scala对此进行扩展</p><ul><li><p>Scala中的包和类的物理路径没有关系</p></li><li><p>package关键字可以嵌套声明使用</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com</span><br><span class="line"><span class="keyword">package</span> atguigu &#123;</span><br><span class="line">    <span class="keyword">package</span> bigdata &#123;</span><br><span class="line">        <span class="keyword">package</span> scala &#123;</span><br><span class="line">            <span class="class"><span class="keyword">object</span> <span class="title">ScalaPackage</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">                    println(<span class="string">&quot;test...&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一个源码文件中子包可以直接访问父包中的内容，而无需import</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com</span><br><span class="line"><span class="keyword">package</span> atguigu &#123;</span><br><span class="line">    <span class="keyword">package</span> bigdata &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">package</span> scala &#123;</span><br><span class="line">            <span class="class"><span class="keyword">object</span> <span class="title">ScalaPackage</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Test</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Scala中package也可以看作对象，并声明属性和函数</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com</span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">atguigu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name : <span class="type">String</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println( name )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> atguigu &#123;</span><br><span class="line">    <span class="keyword">package</span> bigdata &#123;</span><br><span class="line">        <span class="keyword">package</span> scala &#123;</span><br><span class="line">            <span class="class"><span class="keyword">object</span> <span class="title">ScalaPackage</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-2-导入"><a href="#7-1-2-导入" class="headerlink" title="7.1.2 导入"></a>7.1.2 导入</h4><p>​Scala中基本的import导入语法和Java完全一致</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> java.util._ <span class="comment">// Scala中使用下划线代替Java中的星号</span></span><br></pre></td></tr></table></figure><p>Java中import导入的语法比较单一，Scala对此进行扩展</p><ul><li>Scala中的import语法可以在任意位置使用</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImport</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">import</span> java.util.<span class="type">ArrayList</span></span><br><span class="line">        <span class="keyword">new</span>  <span class="type">ArrayList</span>()   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Scala中可以导包，而不是导类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImport</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">import</span> java.util</span><br><span class="line">        <span class="keyword">new</span> util.<span class="type">ArrayList</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Scala中可以在同一行中导入相同包中的多个类，简化代码</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">List</span>, <span class="type">ArrayList</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>Scala中可以屏蔽某个包中的类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util._</span><br><span class="line"><span class="keyword">import</span> java.sql.&#123; <span class="type">Date</span>=&gt;_, <span class="type">Array</span>=&gt;_, _ &#125;</span><br></pre></td></tr></table></figure><ul><li>Scala中可以给类起别名，简化使用(跟python有点像)</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">ArrayList</span>=&gt;<span class="type">AList</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImport</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">AList</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，Scala中会导入如下包和对象</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang._</span><br><span class="line"><span class="keyword">import</span> scala._</span><br><span class="line"><span class="keyword">import</span> scala.<span class="type">Predef</span>._</span><br></pre></td></tr></table></figure><h4 id="7-1-3-类"><a href="#7-1-3-类" class="headerlink" title="7.1.3 类"></a>7.1.3 类</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明类：访问权限 class 类名 &#123; 类主体内容 &#125; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的主体内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象：new 类名(参数列表)</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">User</span>()</span><br></pre></td></tr></table></figure><p>​Scala中一个源文件中可以声明多个公共类</p><h4 id="7-1-4-属性"><a href="#7-1-4-属性" class="headerlink" title="7.1.4 属性"></a>7.1.4 属性</h4><ol><li>属性其实就是类中的变量</li><li>在Scala之中，编译的时候，编译器会把变量编译为类的私有属性，同时提供了属性对应的set以及get方法</li><li>当在其它地方给类的属性赋值的时候，等同于调用了它公有的set方法</li><li>val声明的属性，编译的时候，会给属性添加final关键字，编译器不会提供set方法</li><li>在scala之中给某个属性添加private关键字之后，编译器会把其set和get方法添加上private修饰符</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = _ <span class="comment">// 类属性其实就是类变量</span></span><br><span class="line">    <span class="keyword">var</span> age : <span class="type">Int</span> = _ <span class="comment">// 下划线表示类的属性默认初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道在java中对于一个类有Bean规范，就是属性私有化，提供其公有的set和get方法，原因是因为反射机制，我们需要把架构设计的通用化，但是scala中给属性提供的set和get方法名字与java Bean规范中的不一致，因此不遵循bean规范，为了满足java中的Bean规范，设计了一个关键字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = _</span><br><span class="line"><span class="keyword">val</span> age : <span class="type">Int</span> = <span class="number">30</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> email : <span class="type">String</span> = _</span><br><span class="line"><span class="meta">@BeanProperty</span> <span class="keyword">var</span> address : <span class="type">String</span> = _    <span class="comment">//为了满足java的bean规范</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-5-访问权限"><a href="#7-1-5-访问权限" class="headerlink" title="7.1.5 访问权限"></a>7.1.5 访问权限</h4><p>在java中，一共有四个访问权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">private</span>           只能在本类中使用</span><br><span class="line"><span class="number">2.</span> （<span class="keyword">default</span>）        在本类中以及本包中使用</span><br><span class="line"><span class="number">3.</span> <span class="keyword">protected</span>         本类别、本包、子类中使用</span><br><span class="line"><span class="number">4.</span> <span class="keyword">public</span>            任意</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662258877616.png" alt="1662258877616"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662258979964.png" alt="1662258979964"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662259012241.png" alt="1662259012241"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662259058809.png" alt="1662259058809"></p><p>super关键字只在编译时其作用，在运行时根本没有这个关键字</p><p>在scala中去掉了一个关键字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">private</span>        同类中可以使用</span><br><span class="line"><span class="number">2.</span> <span class="keyword">private</span>[包名]   同包内可以使用</span><br><span class="line"><span class="number">3.</span> <span class="keyword">protected</span>      同类和子类（同包不能使用）</span><br><span class="line"><span class="number">4.</span> (<span class="keyword">default</span>)      公共的，相当于public关键字</span><br></pre></td></tr></table></figure><h4 id="7-1-6-方法"><a href="#7-1-6-方法" class="headerlink" title="7.1.6 方法"></a>7.1.6 方法</h4><p>在类中声明的函数，就是方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaMethod</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> user = <span class="keyword">new</span> <span class="type">User</span></span><br><span class="line">        user.login(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;000000&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span></span>( name:<span class="type">String</span>, password:<span class="type">String</span> ): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662260405624.png" alt="1662260405624"></p><p>方法的重写：</p><p>如何区分父类以及子类中相同的方法，需要采用动态绑定机制</p><p>在调用对象的成员方法过程中，把方法和对象的实际内存进行绑定，然后调用</p><h4 id="7-1-7-对象"><a href="#7-1-7-对象" class="headerlink" title="7.1.7 对象"></a>7.1.7 对象</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> | <span class="keyword">var</span> 对象名 [：类型]  = <span class="keyword">new</span> 类型()</span><br><span class="line"><span class="keyword">var</span> user : <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line"><span class="comment">//1. 反射</span></span><br><span class="line"><span class="comment">//2. new</span></span><br><span class="line"><span class="comment">//3. 反序列化</span></span><br><span class="line"><span class="comment">//4. 克隆</span></span><br></pre></td></tr></table></figure><h4 id="7-1-8-构造方法"><a href="#7-1-8-构造方法" class="headerlink" title="7.1.8 构造方法"></a>7.1.8 构造方法</h4><p>Scala是一个完全面向对象的语言，又是一个完全面向函数的语言</p><p>因此类也是一个函数：声明一个类就等同于声明了一个函数</p><p>类名的后面可以声明小括号，表示构造参数列表</p><p>如果提供了类的构造方法，那么jvm不会再给类提供无参的构造方法</p><p>在Scala中把构造方法分为了两类：主构造方法和辅助构造方法</p><p>用于完成类的初始化操作的构造方法称之为主构造方法</p><p>其它的构造方法称为辅助构造发方法，辅助构造方法的名字是this关键字，其它和普通方法一样</p><p>辅助构造方法的作用就是在完成类的初始化工作之后，做一些辅助功能，在执行之前，应当首先调用主构造方法完成类的初始化 </p><p>辅助构造方法可以重载，并且可以互相调用，但是调用的辅助构造方法应该提前声明</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="keyword">var</span> username : <span class="type">String</span> = _ </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>( name:<span class="type">String</span> ) &#123; <span class="comment">// 辅助构造函数，使用this关键字声明</span></span><br><span class="line">        <span class="keyword">this</span>() <span class="comment">// 辅助构造函数应该直接或间接调用主构造函数</span></span><br><span class="line">        username = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>( name:<span class="type">String</span>, password:<span class="type">String</span> ) &#123;</span><br><span class="line">    <span class="keyword">this</span>(name) <span class="comment">// 构造器调用其他另外的构造器，要求被调用构造器必须提前声明</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>object关键字</strong></p><p>构造方法私有化：在参数列表的前面增加private关键字</p><p>需要声明一个公共的，静态的返回本类型的方法，用于获取对象，但是Scala中不存在静态语法，所有这就构成了死锁，没有静态语法我们就没有办法使用类中的方法，不使用类的方法就没办法得到类的对象。因此Scala中采用了一种特殊的语法来代替静态语法：object</p><p> <img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662263161792.png" alt="1662263161792"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662263252806.png" alt="1662263252806"></p><h3 id="7-2-高阶面向对象编程"><a href="#7-2-高阶面向对象编程" class="headerlink" title="7.2 高阶面向对象编程"></a>7.2 高阶面向对象编程</h3><h4 id="7-2-1-继承"><a href="#7-2-1-继承" class="headerlink" title="7.2.1 继承"></a>7.2.1 继承</h4><p>​和Java一样，Scala中的继承也是单继承，且使用extends关键字。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​构造对象时需要考虑构造方法的执行顺序</p><h4 id="7-2-2-封装"><a href="#7-2-2-封装" class="headerlink" title="7.2.2 封装"></a>7.2.2 封装</h4><p>封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行访问。</p><ol><li>将属性进行私有化</li><li>提供一个公共的set方法，用于对属性赋值</li><li>提供一个公共的get方法，用于获取属性的值</li></ol><h4 id="7-2-3-抽象"><a href="#7-2-3-抽象" class="headerlink" title="7.2.3 抽象"></a>7.2.3 抽象</h4><p>​<strong>所谓的抽象，其实就是就是不完整</strong></p><p>Scala中不完整的方法就是抽象方法，不需要额外增加abstract关键字</p><p>Scala中的属性也是可以抽象的，就是只有声明，没有初始化，<strong>在编译器编译过程中，并不会声明该属性，而是会声明属性的set以及get方法，而且是抽象的</strong></p><p>在Scala中重写父类的完整方法，必须要添加override关键字</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662266884520.png" alt="1662266884520"></p><p>上图那个age属性，也需要添加override关键字，不然会报错，而且上述会执行错误，因为在Scala中的可变变量属性不允许重写。只有val不可变变量才可以重写</p><p>Scala将一个不完整的类称之为抽象类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala中如果一个方法只有声明而没有实现，那么是抽象方法，因为它不完整。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>():<span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala中如果一个属性只有声明没有初始化，那么是抽象属性，因为它不完整。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类如果继承抽象类，必须实现抽象方法或补全抽象属性，否则也必须声明为抽象的，因为依然不完整。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-4-单例对象"><a href="#7-2-4-单例对象" class="headerlink" title="7.2.4 单例对象"></a>7.2.4 单例对象</h4><ul><li><p>所谓的单例对象，就是在程序运行过程中，指定类的对象只能创建一个，而不能创建多个。这样的对象可以由特殊的设计方式获得，也可以由语言本身设计得到，比如object伴生对象</p></li><li><p>Scala语言是完全面向对象的语言，所以并没有静态的操作（即在Scala中没有静态的概念）。但是为了能够和Java语言交互（因为Java中有静态概念），就产生了一种特殊的对象来模拟类对象，该对象为单例对象。若单例对象名与类名一致，则称该单例对象这个类的伴生对象，这个类的所有“静态”内容都可以放置在它的伴生对象中声明，然后通过伴生对象名称直接调用</p></li><li><p>如果类名和伴生对象名称保持一致，那么这个类称之为伴生类。Scala编译器可以通过伴生对象的apply方法创建伴生类对象。apply方法可以重载，并传递参数，且可由Scala编译器自动识别。所以在使用时，其实是可以省略的。</p></li></ul> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; <span class="comment">// 伴生类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">User</span> </span>&#123; <span class="comment">// 伴生对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="keyword">new</span> <span class="type">User</span>() <span class="comment">// 构造伴生类对象</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> user1 = <span class="keyword">new</span> <span class="type">User</span>()<span class="comment">// 通过构造方法创建对象</span></span><br><span class="line"><span class="type">Val</span> user2 = <span class="type">User</span>.apply() <span class="comment">// 通过伴生对象的apply方法构造伴生类对象 </span></span><br><span class="line"><span class="keyword">val</span> user3 = <span class="type">User</span>() <span class="comment">// scala编译器省略apply方法，自动完成调用</span></span><br></pre></td></tr></table></figure><h4 id="7-2-5-特质"><a href="#7-2-5-特质" class="headerlink" title="7.2.5 特质"></a>7.2.5 特质</h4><p>将多个对象中的相同特征，从对象中剥离出来，形成一个独立的结构，称之为trait(特质)</p><p>如果一个对象符合这个特征，那么可以把这个特征加入到这个对象，这个加入的过程，称之为混入</p><p>如果一个类只有一个特征的时候，采用extends关键字进入混入，但是一个类有多个特征的时候，第一个特征使用extends，后面的采用with</p><p>如果一个类还有父类，那么父类使用extends，剩余的特征使用with关键字 </p><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">特质名称</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">父类（特质1）</span> <span class="keyword">with</span> <span class="title">特质2</span> <span class="keyword">with</span><span class="title">特质3</span></span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> <span class="keyword">extends</span> <span class="title">Operator</span> <span class="keyword">with</span> <span class="title">DB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态混入</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaTrait</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> mysql = <span class="keyword">new</span> <span class="type">MySQL</span> <span class="keyword">with</span> <span class="type">Operator</span></span><br><span class="line">        mysql.insert()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;insert data...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解耦合</p><p><strong>初始化叠加</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaTrait</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> mysql = <span class="keyword">new</span> <span class="type">MySQL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Operator</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;operator...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DB</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;db...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> <span class="keyword">extends</span> <span class="title">DB</span> <span class="keyword">with</span> <span class="title">Operator</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;mysql...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>功能叠加</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaTrait</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> mysql: <span class="type">MySQL</span> = <span class="keyword">new</span> <span class="type">MySQL</span></span><br><span class="line">        mysql.operData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Operate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operData</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">        println(<span class="string">&quot;操作数据。。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">DB</span> <span class="keyword">extends</span> <span class="title">Operate</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">operData</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        print(<span class="string">&quot;向数据库中。。&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.operData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Log</span> <span class="keyword">extends</span> <span class="title">Operate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">operData</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">super</span>.operData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> <span class="keyword">extends</span> <span class="title">DB</span> <span class="keyword">with</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL类实现了两个特质，但这两个特质都重写了operData这个方法，那么MySQL对象调用这个方法会执行哪一个特质中的方法呢？</p><p>Scala采用了一种功能叠加的方式</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662269247529.png" alt="1662269247529"></p><p>而且在Scala中的super并不是父特质的意思，是上一级的意思 </p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662269346887.png" alt="1662269346887"></p><p>可以通过上述这种跳过的方式，防止功能叠加 </p><h4 id="7-2-6-扩展"><a href="#7-2-6-扩展" class="headerlink" title="7.2.6 扩展"></a>7.2.6 扩展</h4><p>字符串：不可变</p><p>这个不可变指的是字符串的char数组的内存地址不可变，并不是指的其中的内容不可变，下图展示了如何改变一个字符串内部char数组的值的策略。需要通过反射机制来获取。</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662269704341.png" alt="1662269704341"></p><p> <strong>枚举类</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="type">RED</span> = <span class="type">Value</span>(<span class="number">1</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">YELLOW</span> = <span class="type">Value</span>(<span class="number">2</span>, <span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">BLUE</span> = <span class="type">Value</span>(<span class="number">3</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>应用类</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AppTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    println(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Type定义新类型</strong></p><p>使用type关键字可以定义新的数据数据类型名称，本质上就是类型的一个别名</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> v : <span class="type">S</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-集合"><a href="#8-集合" class="headerlink" title="8.集合"></a>8.集合</h2><h3 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h3><p>​Scala的集合有三大类：序列Seq、集Set、映射Map，所有的集合都扩展自Iterable特质。对于几乎所有的集合类，Scala都同时提供了可变和不可变的版本。</p><p>​可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。而不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变，所以这里的不可变并不是变量本身的值不可变，而是变量指向的那个内存地址不可变</p><p>​可变集合和不可变集合，在scala中该如何进行区分呢？我们一般可以根据集合所在包名进行区分:</p><p>scala.collection.immutable（不可变的）</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662276540357.png" alt="1662276540357"></p><p>scala.collection.mutable（可变的）</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662276750168.png" alt="1662276750168"></p><h3 id="8-2-数组"><a href="#8-2-数组" class="headerlink" title="8.2 数组"></a>8.2 数组</h3><p>​数组在严格意义上并不是集合，在Scala中给数组一个特定的类型：Array</p><p><strong>Array数组的构建、访问、遍历方法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala01_Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 数组</span></span><br><span class="line">        <span class="comment">// 数组 ：严格意义上，数组不是集合</span></span><br><span class="line">        <span class="comment">//      scala中给数组一个特定的类型：Array</span></span><br><span class="line">        <span class="comment">// TODO 构建</span></span><br><span class="line">        <span class="comment">// String[]</span></span><br><span class="line">        <span class="comment">// 构建Scala中的数组，其实等同于构造Java的数组</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line">        println(array)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问</span></span><br><span class="line">        <span class="comment">// 可以根据索引访问数组的元素</span></span><br><span class="line">        <span class="comment">//array.update(1, &quot;abc&quot;)</span></span><br><span class="line">        <span class="comment">// 中括号在scala中表示泛型，所以不能在索引操作中使用，使用小括号</span></span><br><span class="line">        array(<span class="number">1</span>) = <span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- array ) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array其它构建方法、遍历方法、访问方法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala01_Collection_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 数组</span></span><br><span class="line">        <span class="comment">// 集合分为两大类：可变集合，不可变集合</span></span><br><span class="line">        <span class="comment">// Scala默认提供的集合都是不可变。</span></span><br><span class="line"><span class="comment">//        val array = new Array[String](3)</span></span><br><span class="line"><span class="comment">//        array(0) = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//        array(1) = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//        array(2) = &quot;a&quot;</span></span><br><span class="line">        <span class="comment">// 使用集合的伴生对象构建集合，并同时初始化</span></span><br><span class="line">        <span class="keyword">val</span> array1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> array2 = <span class="type">Array</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        <span class="comment">//val array2 = Array.apply(1,2,3,4)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问</span></span><br><span class="line">        <span class="comment">//val ints: Array[Int] = array1.+:(5)</span></span><br><span class="line">        <span class="comment">// scala中如果运算符是以冒号结尾，那么运算规则为从后向前计算</span></span><br><span class="line">        <span class="keyword">val</span> ints = <span class="number">5</span> +: array1</span><br><span class="line"></span><br><span class="line">        <span class="comment">//val ints1: Array[Int] = array1.:+(5)</span></span><br><span class="line">        <span class="keyword">val</span> ints1 = array1 :+ <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> ints2 = array1 ++ array2</span><br><span class="line">        <span class="keyword">val</span> ints3 = array1 ++: array2</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(array1 eq ints)</span></span><br><span class="line">        <span class="comment">//println(array1 eq ints1)</span></span><br><span class="line">       <span class="comment">// println(ints eq ints1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 遍历</span></span><br><span class="line">        <span class="comment">//println(ints.mkString(&quot;,&quot;))</span></span><br><span class="line">        <span class="comment">//println(ints1.mkString(&quot;,&quot;))</span></span><br><span class="line">        <span class="comment">//println(ints2.mkString(&quot;,&quot;))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// foreach方法是一个循环的方法，需要传递一个参数，这个从参数的类型是函数类型</span></span><br><span class="line">        <span class="comment">//  函数类型 ： Int =&gt; U</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">foreachFunction</span></span>(num:<span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(num)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//array1.foreach(foreachFunction)</span></span><br><span class="line">        <span class="comment">//array1.foreach((num:Int)=&gt;&#123;println(num)&#125;)</span></span><br><span class="line">        <span class="comment">//array1.foreach((num:Int)=&gt;println(num))</span></span><br><span class="line">        <span class="comment">//array1.foreach((num)=&gt;println(num))</span></span><br><span class="line">        <span class="comment">//array1.foreach(num=&gt;println(num))</span></span><br><span class="line">        array1.foreach(println(_))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala01_Collection_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 数组</span></span><br><span class="line">        <span class="comment">// 多维数组</span></span><br><span class="line">        <span class="keyword">var</span> myMatrix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">        <span class="comment">//myMatrix.foreach(list=&gt;println(list.mkString(&quot;,&quot;)))</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> arr2 = <span class="type">Array</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        <span class="comment">// 合并数组</span></span><br><span class="line">        <span class="keyword">val</span> arr6: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>.concat(arr1, arr2)</span><br><span class="line">        <span class="comment">//arr6.foreach(println)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建指定范围的数组</span></span><br><span class="line">        <span class="keyword">val</span> arr7: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>.range(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">//arr7.foreach(println)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> arr8:<span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>.fill[<span class="type">Int</span>](<span class="number">5</span>)(<span class="number">-1</span>)</span><br><span class="line">        arr8.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-1-不可变数组"><a href="#8-2-1-不可变数组" class="headerlink" title="8.2.1 不可变数组"></a>8.2.1 不可变数组</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//（1）数组定义</span></span><br><span class="line">        <span class="keyword">val</span> arr01 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">        println(arr01.length) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//（2）数组赋值</span></span><br><span class="line">        <span class="comment">//（2.1）修改某个元素的值</span></span><br><span class="line">        arr01(<span class="number">3</span>) = <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">        arr01(i/<span class="number">3</span>) = <span class="number">20</span></span><br><span class="line">        <span class="comment">//（2.2）采用方法的形式修改数组的值</span></span><br><span class="line">        arr01.update(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3）遍历数组</span></span><br><span class="line">        <span class="comment">//（3.1）查看数组</span></span><br><span class="line">        println(arr01.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3.2）普通遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（3.3）简化遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printx</span></span>(elem:<span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(elem)</span><br><span class="line">        &#125;</span><br><span class="line">        arr01.foreach(printx)</span><br><span class="line">        arr01.foreach((x)=&gt;&#123;println(x)&#125;)</span><br><span class="line">        arr01.foreach(println(_))</span><br><span class="line">        arr01.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 创建数组的另外一种方式</span></span><br><span class="line">        <span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> arr2 = <span class="type">Array</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        <span class="comment">// 添加数组元素，创建新数组</span></span><br><span class="line">        <span class="keyword">val</span> arr3: <span class="type">Array</span>[<span class="type">Int</span>] = arr1 :+ <span class="number">5</span></span><br><span class="line">        println( arr1 eq arr3 ) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> arr4: <span class="type">Array</span>[<span class="type">Int</span>] = arr1 ++: arr2</span><br><span class="line">        <span class="comment">// 添加集合</span></span><br><span class="line">        <span class="keyword">val</span> arr5: <span class="type">Array</span>[<span class="type">Int</span>] = arr1 ++ arr2</span><br><span class="line"></span><br><span class="line">        arr4.foreach(println)</span><br><span class="line">        println(<span class="string">&quot;****************&quot;</span>)</span><br><span class="line">        arr5.foreach(println)</span><br><span class="line">        println(<span class="string">&quot;****************&quot;</span>)</span><br><span class="line">        <span class="comment">// 多维数组</span></span><br><span class="line">        <span class="keyword">var</span> myMatrix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">        myMatrix.foreach(list=&gt;list.foreach(println))</span><br><span class="line">        <span class="comment">// 合并数组</span></span><br><span class="line">        <span class="keyword">val</span> arr6: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>.concat(arr1, arr2)</span><br><span class="line">        arr6.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建指定范围的数组</span></span><br><span class="line">        <span class="keyword">val</span> arr7: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>.range(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        arr7.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并填充指定数量的数组</span></span><br><span class="line">        <span class="keyword">val</span> arr8:<span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>.fill[<span class="type">Int</span>](<span class="number">5</span>)(<span class="number">-1</span>)</span><br><span class="line">        arr8.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-可变数组"><a href="#8-2-2-可变数组" class="headerlink" title="8.2.2 可变数组"></a>8.2.2 可变数组</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> buffer = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]</span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        buffer.append(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 修改数据</span></span><br><span class="line">        buffer.update(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">        buffer(<span class="number">1</span>) = <span class="number">6</span></span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">val</span> i: <span class="type">Int</span> = buffer.remove(<span class="number">2</span>)</span><br><span class="line">        buffer.remove(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        println(buffer(<span class="number">3</span>))</span><br><span class="line">        <span class="comment">// 循环集合</span></span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- buffer ) &#123;</span><br><span class="line">            println(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> buffer1 = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> buffer2 = <span class="type">ArrayBuffer</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> buffer3: <span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = buffer1 += <span class="number">5</span></span><br><span class="line">        println( buffer1 eq buffer3 ) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ++ 运算符会产生新的集合数组</span></span><br><span class="line">        <span class="keyword">val</span> buffer4: <span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = buffer1 ++ buffer2</span><br><span class="line">        <span class="comment">// 使用 ++= 运算符会更新之前的集合，不会产生新的数组</span></span><br><span class="line">        <span class="keyword">val</span> buffer5: <span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = buffer1 ++= buffer2</span><br><span class="line">        println( buffer1 eq buffer4 ) <span class="comment">// false</span></span><br><span class="line">        println( buffer1 eq buffer5 ) <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-不可变数组和可变数组的转换"><a href="#8-2-3-不可变数组和可变数组的转换" class="headerlink" title="8.2.3 不可变数组和可变数组的转换"></a>8.2.3 不可变数组和可变数组的转换</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> buffer = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将不可变数组转换为可变数组</span></span><br><span class="line">        <span class="keyword">val</span> buffer1: mutable.<span class="type">Buffer</span>[<span class="type">Int</span>] = array.toBuffer</span><br><span class="line">        <span class="comment">// 将可变数组转换为不可变数组</span></span><br><span class="line">        <span class="keyword">val</span> array1: <span class="type">Array</span>[<span class="type">Int</span>] = buffer.toArray</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-常用方法"><a href="#8-2-4-常用方法" class="headerlink" title="8.2.4 常用方法"></a>8.2.4 常用方法</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala03_Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        println(array.size)</span><br><span class="line">        println(array.length)</span><br><span class="line">        println(array.isEmpty)</span><br><span class="line">        println(array.contains(<span class="number">2</span>))</span><br><span class="line">        println(array.distinct.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        println(array.reverse.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        println(array.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        array.foreach(println)</span><br><span class="line">        array.iterator</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala03_Collection_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中获取部分数据</span></span><br><span class="line">        println(array.head)</span><br><span class="line">        println(array.tail)</span><br><span class="line">        println(array.tails)</span><br><span class="line">        println(array.last)</span><br><span class="line">        println(array.init) <span class="comment">// 初始</span></span><br><span class="line">        println(array.inits)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取前几个</span></span><br><span class="line">        println(array.take(<span class="number">3</span>))</span><br><span class="line">        <span class="comment">//println(array.reverse.take(2).reverse)</span></span><br><span class="line">        println(array.takeRight(<span class="number">2</span>))</span><br><span class="line">        println(array.drop(<span class="number">1</span>))</span><br><span class="line">        println(array.dropRight(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-常用方法"><a href="#8-3-常用方法" class="headerlink" title="8.3 常用方法"></a>8.3 常用方法</h3><h4 id="8-3-1-reduce-amp-reduceLeft-amp-reduceRight"><a href="#8-3-1-reduce-amp-reduceLeft-amp-reduceRight" class="headerlink" title="8.3.1 reduce &amp; reduceLeft  &amp; reduceRight"></a>8.3.1 reduce &amp; reduceLeft  &amp; reduceRight</h4><p><strong>reduce的内部其实就是reduceLeft</strong></p><p><strong>reduceRight的底层其实也是reduceLeft，只不过先把数组翻转，然后开始从左往右计算，不过把x,y参数颠倒，详细请见下面的代码</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala03_Collection_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        println(array.sum)</span><br><span class="line">        println(array.max)</span><br><span class="line">        println(array.min)</span><br><span class="line">        println(array.product)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义数据操作的方法</span></span><br><span class="line">        <span class="comment">// 集合的数据无论是多少，最基本的数据操作其实都是两两计算。</span></span><br><span class="line">        <span class="comment">// map =&gt; reduce =&gt; 简化，规约（聚合）</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reduceFunction</span></span>(x : <span class="type">Int</span>, y : <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            x + y</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(array.reduce(reduceFunction))</span></span><br><span class="line">        <span class="comment">//println(array.reduce((x:Int, y:Int)=&gt;&#123;x + y&#125;))</span></span><br><span class="line">        <span class="comment">//println(array.reduce((x:Int, y:Int)=&gt;x + y))</span></span><br><span class="line">        <span class="comment">//println(array.reduce((x, y)=&gt;x + y))</span></span><br><span class="line">        println(array.reduce(_ - _))  <span class="comment">// -13</span></span><br><span class="line">        println(array.reduceLeft(_ - _)) <span class="comment">// -13</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1，2，3，4】</span></span><br><span class="line">        <span class="comment">//  (((1 + 2) + 3) + 4)</span></span><br><span class="line">        <span class="comment">// reversed.reduceLeft[B]((x, y) =&gt; op(y, x))</span></span><br><span class="line">        <span class="comment">// 【1，2，3，4, 5】</span></span><br><span class="line">        <span class="comment">// 【5，4，3，2，1】</span></span><br><span class="line">        <span class="comment">//  1 - (2 - (3 - (4 - 5)))</span></span><br><span class="line">        <span class="comment">// 【1，2，3，4】</span></span><br><span class="line">        <span class="comment">// (1 - (2 - (3 - 4)))</span></span><br><span class="line">        println(array.reduceRight(_ - _)) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-fold-amp-scan"><a href="#8-3-2-fold-amp-scan" class="headerlink" title="8.3.2 fold &amp; scan"></a>8.3.2 fold &amp; scan</h4><p><strong>fold的作用是把集合外的数据和集合内的数据一块做操作</strong></p><p><strong>scan的作用是两两计算的临时结果的保存</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala03_Collection_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> num = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 折叠</span></span><br><span class="line">        <span class="comment">//println(array.fold(5)(_ - _))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (((5 - 1) - 2) - 3) - 4</span></span><br><span class="line">        <span class="comment">//println(array.foldLeft(5)(_ - _))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// reversed.foldLeft(z)((x, y) =&gt; op(y, x))</span></span><br><span class="line">        <span class="comment">// 【1，2，3，4】</span></span><br><span class="line">        <span class="comment">// 【4，3，2，1】</span></span><br><span class="line">        <span class="comment">//  1 - (2  - (3 - (4 - 5)))</span></span><br><span class="line">        println(array.foldRight(<span class="number">5</span>)(_ - _))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(array.scan(5)(_ - _))</span></span><br><span class="line">        println(array.scanRight(<span class="number">5</span>)(_-_))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-3-map"><a href="#8-3-3-map" class="headerlink" title="8.3.3 map"></a>8.3.3 map</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala04_Collection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 功能函数：由集合对象提供函数执行自定义的功能</span></span><br><span class="line">        <span class="comment">//  1. map =&gt; 映射(转换) =&gt; K-&gt;V</span></span><br><span class="line">        <span class="comment">//     a =&gt; b</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// map方法需要传递一个参数，这个参数的类型为函数类型: Int =&gt; B</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mapFunction</span></span>( num:<span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            num * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(array.map(mapFunction))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        println(array.map(</span></span><br><span class="line"><span class="comment">//            (num:Int) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//                num * 2</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        ))</span></span><br><span class="line"></span><br><span class="line">        println(array.map(_*<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-4-flatMap"><a href="#8-3-4-flatMap" class="headerlink" title="8.3.4 flatMap"></a>8.3.4 flatMap</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala04_Collection_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line"><span class="comment">//        val array = ArrayBuffer(</span></span><br><span class="line"><span class="comment">//            ArrayBuffer(</span></span><br><span class="line"><span class="comment">//                ArrayBuffer(1,2),ArrayBuffer(5,6)</span></span><br><span class="line"><span class="comment">//            ), ArrayBuffer(</span></span><br><span class="line"><span class="comment">//                ArrayBuffer(3,4),ArrayBuffer(7,8)</span></span><br><span class="line"><span class="comment">//            )</span></span><br><span class="line"><span class="comment">//        )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(array.length)</span></span><br><span class="line">        <span class="comment">// 将整体拆分成个体的操作，称之为扁平化</span></span><br><span class="line">        <span class="comment">// 扁平化操作只能对最外层进行操作</span></span><br><span class="line">        <span class="comment">//println(array.flatten.flatten)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">Array</span>(</span><br><span class="line">            <span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello Hadoop&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(array.flatten.mkString(&quot;,&quot;))</span></span><br><span class="line"></span><br><span class="line">        println(array.flatMap(</span><br><span class="line">            str =&gt; &#123;</span><br><span class="line">                str.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ).mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-5-filter"><a href="#8-3-5-filter" class="headerlink" title="8.3.5 filter"></a>8.3.5 filter</h4><p>filter函数对于每一条数据进行筛选操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala04_Collection_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// filter方法可以对集合中的每一条数据进行筛选过滤</span></span><br><span class="line">        <span class="comment">// 满足条件（true）的数据保留，不满足条件(false)的数据丢弃</span></span><br><span class="line">        <span class="keyword">val</span> r = array.filter(</span><br><span class="line">            num =&gt; &#123;</span><br><span class="line">                num % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        println(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-6-groupBy"><a href="#8-3-6-groupBy" class="headerlink" title="8.3.6 groupBy"></a>8.3.6 groupBy</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala04_Collection_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line"><span class="comment">//        val array = ArrayBuffer(1,2,3,4)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // 根据指定的规则对每一条数据进行分组</span></span><br><span class="line"><span class="comment">//        val r = array.groupBy(</span></span><br><span class="line"><span class="comment">//            num =&gt; &#123;</span></span><br><span class="line"><span class="comment">////                if ( num % 2 == 0 ) &#123;</span></span><br><span class="line"><span class="comment">////                    &quot;偶数&quot;</span></span><br><span class="line"><span class="comment">////                &#125; else &#123;</span></span><br><span class="line"><span class="comment">////                    &quot;奇数&quot;</span></span><br><span class="line"><span class="comment">////                &#125;</span></span><br><span class="line"><span class="comment">//                num % 2</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        )</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        println(r)</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(</span><br><span class="line">            <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Scala&quot;</span>, <span class="string">&quot;Hadoop&quot;</span>, <span class="string">&quot;Spark&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        println(array.groupBy(_.substring(<span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-7-sortBy"><a href="#8-3-7-sortBy" class="headerlink" title="8.3.7 sortBy"></a>8.3.7 sortBy</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala04_Collection_4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 集合 - 方法</span></span><br><span class="line">        <span class="comment">//val array = ArrayBuffer(1,4,2,3)</span></span><br><span class="line">        <span class="keyword">val</span> array = <span class="type">ArrayBuffer</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;22&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序:通过指定的规则对每一条数据进行排序处理， 默认为升序</span></span><br><span class="line">        println(array.sortBy(</span><br><span class="line">            num =&gt; num.toInt</span><br><span class="line">        ))</span><br><span class="line">        println(array.sortBy(num =&gt; num.toInt)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala13_Collection_Method_7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> user1 = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">        user1.age = <span class="number">20</span></span><br><span class="line">        user1.salary = <span class="number">2000</span></span><br><span class="line">        <span class="keyword">val</span> user2 = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">        user2.age = <span class="number">30</span></span><br><span class="line">        user2.salary = <span class="number">2000</span></span><br><span class="line">        <span class="keyword">val</span> user3 = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">        user3.age = <span class="number">30</span></span><br><span class="line">        user3.salary = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> users = <span class="type">List</span>(</span><br><span class="line">            user1, user2, user3</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println(users.sortBy(_.age)(Ordering.Int.reverse))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tuple : 元组,可以默认排序，先比较第一个，如果相同，比较第二个，依此类推</span></span><br><span class="line"><span class="comment">//        println(</span></span><br><span class="line"><span class="comment">//            users.sortBy(</span></span><br><span class="line"><span class="comment">//                user =&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    ( user.age, user.salary )</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            )(Ordering.Tuple2[Int, Int]( Ordering.Int, Ordering.Int.reverse ))</span></span><br><span class="line"><span class="comment">//        )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义排序</span></span><br><span class="line">        println(users.sortWith(</span><br><span class="line">            (user1, user2) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 将你期望的结果，返回为true</span></span><br><span class="line">                <span class="comment">//user1.salary &gt; user2.salary</span></span><br><span class="line">                <span class="keyword">if</span> ( user1.age &lt; user2.age ) &#123;</span><br><span class="line">                    <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user1.age == user2.age ) &#123;</span><br><span class="line">                    user1.salary &lt; user2.salary</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> age : <span class="type">Int</span> = _</span><br><span class="line">        <span class="keyword">var</span> salary : <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">s&quot;User[<span class="subst">$&#123;age&#125;</span>, <span class="subst">$&#123;salary&#125;</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-8-sliding"><a href="#8-3-8-sliding" class="headerlink" title="8.3.8 sliding"></a>8.3.8 sliding</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala13_Collection_Method_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        <span class="comment">//println(list1.drop(1))</span></span><br><span class="line">        <span class="comment">//list1.head + list1.tail.head</span></span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="comment">// 滚动窗口</span></span><br><span class="line">        <span class="keyword">val</span> iterator: <span class="type">Iterator</span>[<span class="type">List</span>[<span class="type">Int</span>]] = list1.sliding(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext) &#123;</span><br><span class="line">            <span class="keyword">val</span> ints: <span class="type">List</span>[<span class="type">Int</span>] = iterator.next()</span><br><span class="line">            println(ints)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-Seq集合"><a href="#8-4-Seq集合" class="headerlink" title="8.4 Seq集合"></a>8.4 Seq集合</h3><h4 id="8-4-1-不可变List"><a href="#8-4-1-不可变List" class="headerlink" title="8.4.1 不可变List"></a>8.4.1 不可变List</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Seq集合</span></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        <span class="keyword">val</span> list1: <span class="type">List</span>[<span class="type">Int</span>] = list :+ <span class="number">1</span></span><br><span class="line">        println(list1 eq list)</span><br><span class="line">        list1.foreach(println)</span><br><span class="line">        <span class="keyword">val</span> list2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="number">1</span> +: list</span><br><span class="line">        list2.foreach(println)</span><br><span class="line">        println(<span class="string">&quot;*****************&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> list3: <span class="type">List</span>[<span class="type">Int</span>] = list.updated(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">        println(list eq list3)</span><br><span class="line">        <span class="type">List3</span>.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Seq集合</span></span><br><span class="line">        <span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 空集合</span></span><br><span class="line">        <span class="keyword">val</span> list2: <span class="type">List</span>[<span class="type">Nothing</span>] = <span class="type">List</span>()</span><br><span class="line">        <span class="keyword">val</span> nil  = <span class="type">Nil</span></span><br><span class="line">        println(list2 eq nil)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        <span class="keyword">val</span> list3: <span class="type">List</span>[<span class="type">Int</span>]  = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="type">Nil</span></span><br><span class="line">        <span class="keyword">val</span> list4: <span class="type">List</span>[<span class="type">Int</span>] = list1 ::: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接集合</span></span><br><span class="line">        <span class="keyword">val</span> list5: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>.concat(list3, list4)</span><br><span class="line">        list5.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个指定重复数量的元素列表</span></span><br><span class="line">        <span class="keyword">val</span> list6: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>.fill[<span class="type">String</span>](<span class="number">3</span>)(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        list6.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-2-可变List"><a href="#8-4-2-可变List" class="headerlink" title="8.4.2 可变List"></a>8.4.2 可变List</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 可变集合</span></span><br><span class="line">        <span class="keyword">val</span> buffer = <span class="keyword">new</span> <span class="type">ListBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        buffer.append(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 修改数据</span></span><br><span class="line">        buffer.update(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        buffer.remove(<span class="number">2</span>)</span><br><span class="line">        buffer.remove(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        println(buffer(<span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        buffer.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可变集合</span></span><br><span class="line">        <span class="keyword">val</span> buffer1 = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> buffer2 = <span class="type">ListBuffer</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        <span class="keyword">val</span> buffer3: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = buffer1 :+ <span class="number">5</span></span><br><span class="line">        <span class="keyword">val</span> buffer4: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = buffer1 += <span class="number">5</span></span><br><span class="line">        <span class="keyword">val</span> buffer5: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = buffer1 ++ buffer2</span><br><span class="line">        <span class="keyword">val</span> buffer6: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = buffer1 ++= buffer2</span><br><span class="line"></span><br><span class="line">        println( buffer5 eq buffer1 )</span><br><span class="line">        println( buffer6 eq buffer1 )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> buffer7: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = buffer1 - <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> buffer8: <span class="type">ListBuffer</span>[<span class="type">Int</span>] = buffer1 -= <span class="number">2</span></span><br><span class="line">        println( buffer7 eq buffer1 )</span><br><span class="line">        println( buffer8 eq buffer1 )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-3-可变集合和不可变集合的转变"><a href="#8-4-3-可变集合和不可变集合的转变" class="headerlink" title="8.4.3 可变集合和不可变集合的转变"></a>8.4.3 可变集合和不可变集合的转变</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> buffer = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 可变集合转变为不可变集合</span></span><br><span class="line">        <span class="keyword">val</span> list1: <span class="type">List</span>[<span class="type">Int</span>] = buffer.toList</span><br><span class="line">        <span class="comment">// 不可变集合转变为可变集合</span></span><br><span class="line">        <span class="keyword">val</span> buffer1: mutable.<span class="type">Buffer</span>[<span class="type">Int</span>] = list.toBuffer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-Set集合"><a href="#8-5-Set集合" class="headerlink" title="8.5 Set集合"></a>8.5 Set集合</h3><h4 id="8-5-1-不可变Set"><a href="#8-5-1-不可变Set" class="headerlink" title="8.5.1 不可变Set"></a>8.5.1 不可变Set</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set1 = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> set2 = <span class="type">Set</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        <span class="keyword">val</span> set3: <span class="type">Set</span>[<span class="type">Int</span>] = set1 + <span class="number">5</span> + <span class="number">6</span></span><br><span class="line">        <span class="keyword">val</span> set4: <span class="type">Set</span>[<span class="type">Int</span>] = set1.+(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        println( set1 eq set3 ) <span class="comment">// false</span></span><br><span class="line">        println( set1 eq set4 ) <span class="comment">// false</span></span><br><span class="line">        set4.foreach(println)</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">val</span> set5: <span class="type">Set</span>[<span class="type">Int</span>] = set1 - <span class="number">2</span> - <span class="number">3</span></span><br><span class="line">        set5.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set6: <span class="type">Set</span>[<span class="type">Int</span>] = set1 ++ set2</span><br><span class="line">        set6.foreach(println)</span><br><span class="line">        println(<span class="string">&quot;********&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> set7: <span class="type">Set</span>[<span class="type">Int</span>] = set2 ++: set1</span><br><span class="line">        set7.foreach(println)</span><br><span class="line">        println(set6 eq set7)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set1 = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> set2 = <span class="type">Set</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        <span class="keyword">val</span> set3: <span class="type">Set</span>[<span class="type">Int</span>] = set1 + <span class="number">5</span> + <span class="number">6</span></span><br><span class="line">        <span class="keyword">val</span> set4: <span class="type">Set</span>[<span class="type">Int</span>] = set1.+(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">        println( set1 eq set3 ) <span class="comment">// false</span></span><br><span class="line">        println( set1 eq set4 ) <span class="comment">// false</span></span><br><span class="line">        set4.foreach(println)</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">val</span> set5: <span class="type">Set</span>[<span class="type">Int</span>] = set1 - <span class="number">2</span> - <span class="number">3</span></span><br><span class="line">        set5.foreach(println)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set6: <span class="type">Set</span>[<span class="type">Int</span>] = set1 ++ set2</span><br><span class="line">        set6.foreach(println)</span><br><span class="line">        println(<span class="string">&quot;********&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> set7: <span class="type">Set</span>[<span class="type">Int</span>] = set2 ++: set1</span><br><span class="line">        set7.foreach(println)</span><br><span class="line">        println(set6 eq set7)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-5-2-可变set"><a href="#8-5-2-可变set" class="headerlink" title="8.5.2 可变set"></a>8.5.2 可变set</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set1 = mutable.<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> set2 = mutable.<span class="type">Set</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加数据</span></span><br><span class="line">        set1.add(<span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        set1.update(<span class="number">6</span>,<span class="literal">true</span>)</span><br><span class="line">        println(set1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        set1.update(<span class="number">3</span>,<span class="literal">false</span>)</span><br><span class="line">        println(set1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        set1.remove(<span class="number">2</span>)</span><br><span class="line">        println(set1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数据</span></span><br><span class="line">        set1.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set1 = mutable.<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> set2 = mutable.<span class="type">Set</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交集</span></span><br><span class="line">        <span class="keyword">val</span> set3: mutable.<span class="type">Set</span>[<span class="type">Int</span>] = set1 &amp; set2</span><br><span class="line">        println(set3.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        <span class="comment">// 差集</span></span><br><span class="line">        <span class="keyword">val</span> set4: mutable.<span class="type">Set</span>[<span class="type">Int</span>] = set1 &amp;~ set2</span><br><span class="line">        println(set4.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-6-Map集合"><a href="#8-6-Map集合" class="headerlink" title="8.6 Map集合"></a>8.6 Map集合</h3><p>​Map(映射)是一种可迭代的键值对（key&#x2F;value）结构。所有的值都可以通过键来获取。Map 中的键都是唯一的。</p><h4 id="8-6-1-不可变map"><a href="#8-6-1-不可变map" class="headerlink" title="8.6.1 不可变map"></a>8.6.1 不可变map</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map1 = <span class="type">Map</span>( <span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;c&quot;</span> -&gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">val</span> map2 = <span class="type">Map</span>( <span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>, <span class="string">&quot;e&quot;</span> -&gt; <span class="number">5</span>, <span class="string">&quot;f&quot;</span> -&gt; <span class="number">6</span> )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        <span class="keyword">val</span> map3 = map1 + (<span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>)</span><br><span class="line">        println(map1 eq map3) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        <span class="keyword">val</span> map4 = map3 - <span class="string">&quot;d&quot;</span></span><br><span class="line">        println(map4.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map5: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1 ++ map2</span><br><span class="line">        println(map5 eq map1)</span><br><span class="line">        println(map5.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map6: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1 ++: map2</span><br><span class="line">        println(map6 eq map1)</span><br><span class="line">        println(map6.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改数据</span></span><br><span class="line">        <span class="keyword">val</span> map7: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1.updated(<span class="string">&quot;b&quot;</span>, <span class="number">5</span>)</span><br><span class="line">        println(map7.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数据</span></span><br><span class="line">        map1.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map1 = <span class="type">Map</span>( <span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;c&quot;</span> -&gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">val</span> map2 = <span class="type">Map</span>( <span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>, <span class="string">&quot;e&quot;</span> -&gt; <span class="number">5</span>, <span class="string">&quot;f&quot;</span> -&gt; <span class="number">6</span> )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建空集合</span></span><br><span class="line">        <span class="keyword">val</span> empty: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = <span class="type">Map</span>.empty</span><br><span class="line">        println(empty)</span><br><span class="line">        <span class="comment">// 获取指定key的值</span></span><br><span class="line">        <span class="keyword">val</span> i: <span class="type">Int</span> = map1.apply(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">        println(i)</span><br><span class="line">        println(map1(<span class="string">&quot;c&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取可能存在的key值</span></span><br><span class="line">        <span class="keyword">val</span> maybeInt: <span class="type">Option</span>[<span class="type">Int</span>] = map1.get(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">        <span class="comment">// 判断key值是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ( !maybeInt.isEmpty ) &#123;</span><br><span class="line">            <span class="comment">// 获取值</span></span><br><span class="line">            println(maybeInt.get)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，获取默认值</span></span><br><span class="line">            println(maybeInt.getOrElse(<span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取可能存在的key值, 如果不存在就使用默认值</span></span><br><span class="line">        println(map1.getOrElse(<span class="string">&quot;c&quot;</span>, <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-6-2-可变map"><a href="#8-6-2-可变map" class="headerlink" title="8.6.2 可变map"></a>8.6.2 可变map</h4><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>( <span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;c&quot;</span> -&gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>( <span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>, <span class="string">&quot;e&quot;</span> -&gt; <span class="number">5</span>, <span class="string">&quot;f&quot;</span> -&gt; <span class="number">6</span> )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        map1.put(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">val</span> map3: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1 + (<span class="string">&quot;e&quot;</span> -&gt; <span class="number">4</span>)</span><br><span class="line">        println(map1 eq map3)</span><br><span class="line">        <span class="keyword">val</span> map4: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1 += (<span class="string">&quot;e&quot;</span> -&gt; <span class="number">5</span>)</span><br><span class="line">        println(map1 eq map4)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改数据</span></span><br><span class="line">        map1.update(<span class="string">&quot;e&quot;</span>,<span class="number">8</span>)</span><br><span class="line">        map1(<span class="string">&quot;e&quot;</span>) = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除数据</span></span><br><span class="line">        map1.remove(<span class="string">&quot;e&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> map5: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1 - <span class="string">&quot;e&quot;</span></span><br><span class="line">        println(map1 eq map5)</span><br><span class="line">        <span class="keyword">val</span> map6: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map1 -= <span class="string">&quot;e&quot;</span></span><br><span class="line">        println(map1 eq map6)</span><br><span class="line">        <span class="comment">// 清除集合</span></span><br><span class="line">        map1.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>( <span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;b&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;c&quot;</span> -&gt; <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>( <span class="string">&quot;d&quot;</span> -&gt; <span class="number">4</span>, <span class="string">&quot;e&quot;</span> -&gt; <span class="number">5</span>, <span class="string">&quot;f&quot;</span> -&gt; <span class="number">6</span> )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> set: <span class="type">Set</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = map1.toSet</span><br><span class="line">        <span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = map1.toList</span><br><span class="line">        <span class="keyword">val</span> seq: <span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = map1.toSeq</span><br><span class="line">        <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = map1.toArray</span><br><span class="line"></span><br><span class="line">        println(set.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        println(list.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        println(seq.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        println(array.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">        println(map1.get(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        println(map1.getOrElse(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        println(map1.keys)</span><br><span class="line">        println(map1.keySet)</span><br><span class="line">        println(map1.keysIterator)</span><br><span class="line">        println(map1.values)</span><br><span class="line">        println(map1.valuesIterator)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Option专门为了解决空指针问题来设计的</p><p>Option：选项，对象只有两个 Some, None</p><h3 id="8-7-Tuple"><a href="#8-7-Tuple" class="headerlink" title="8.7 Tuple"></a>8.7 Tuple</h3><p>​在Scala语言中，我们可以将多个无关的数据元素封装为一个整体，这个整体我们称之为：元素组合，简称元组。有时也可将元组看成容纳元素的容器，其中最多只能容纳22个</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建元组，使用小括号</span></span><br><span class="line">        <span class="keyword">val</span> tuple = (<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据顺序号访问元组的数据</span></span><br><span class="line">        println(tuple._1)</span><br><span class="line">        println(tuple._2)</span><br><span class="line">        println(tuple._3)</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        <span class="keyword">val</span> iterator: <span class="type">Iterator</span>[<span class="type">Any</span>] = tuple.productIterator</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据索引访问元素</span></span><br><span class="line">        tuple.productElement(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果元组的元素只有两个，那么我们称之为对偶元组，也称之为键值对</span></span><br><span class="line">        <span class="keyword">val</span> kv: (<span class="type">String</span>, <span class="type">Int</span>) = (<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> kv1: (<span class="type">String</span>, <span class="type">Int</span>) = <span class="string">&quot;a&quot;</span> -&gt; <span class="number">1</span></span><br><span class="line">        println( kv eq kv1 )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-8-队列"><a href="#8-8-队列" class="headerlink" title="8.8 队列"></a>8.8 队列</h3><p>​Scala也提供了队列（Queue）的数据结构，队列的特点就是先进先出。进队和出队的方法分别为enqueue和dequeue。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> que = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">String</span>]()</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        que.enqueue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> que1: mutable.<span class="type">Queue</span>[<span class="type">String</span>] = que += <span class="string">&quot;d&quot;</span></span><br><span class="line">        println(que eq que1)</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        println(que.dequeue())</span><br><span class="line">        println(que.dequeue())</span><br><span class="line">        println(que.dequeue())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-9-并行"><a href="#8-9-并行" class="headerlink" title="8.9 并行"></a>8.9 并行</h3><p>​Scala为了充分使用多核CPU，提供了并行集合（有别于前面的串行集合），用于多核环境的并行计算。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> result1 = (<span class="number">0</span> to <span class="number">100</span>).map&#123;x =&gt; <span class="type">Thread</span>.currentThread.getName&#125;</span><br><span class="line">        <span class="keyword">val</span> result2 = (<span class="number">0</span> to <span class="number">100</span>).par.map&#123;x =&gt; <span class="type">Thread</span>.currentThread.getName&#125;</span><br><span class="line"></span><br><span class="line">        println(result1)</span><br><span class="line">        println(result2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全问题</strong></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662292574283.png" alt="1662292574283"></p><p>多线程并发执行的时候，对共享内存中的共享对象的属性进行修改，导致的数据冲突问题。</p><h2 id="9-模式匹配"><a href="#9-模式匹配" class="headerlink" title="9.模式匹配"></a>9.模式匹配</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><p>​Scala中的模式匹配类似于Java中的switch语法,但是scala从语法中补充了更多的功能，可以按照指定的规则对数据或对象进行匹配, 所以更加强大。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i = <span class="number">20</span></span><br><span class="line">switch (i) &#123;</span><br><span class="line">    <span class="keyword">default</span> : </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;other number&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span> :</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span> : </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-基本语法"><a href="#9-2-基本语法" class="headerlink" title="9.2 基本语法"></a>9.2 基本语法</h3><p>​模式匹配语法中，采用match关键字声明，每个分支采用case关键字进行声明，当需要匹配时，会从第一个case分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有case都不匹配，那么会执行case _分支，类似于Java中default语句。如果不存在case _分支，那么会发生错误。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaMatch</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line">        <span class="keyword">var</span> operator: <span class="type">Char</span> = &#x27;d&#x27;</span><br><span class="line">        <span class="keyword">var</span> result = operator <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &#x27;+&#x27; =&gt; a + b</span><br><span class="line">            <span class="keyword">case</span> &#x27;-&#x27; =&gt; a - b</span><br><span class="line">            <span class="keyword">case</span> &#x27;*&#x27; =&gt; a * b</span><br><span class="line">            <span class="keyword">case</span> &#x27;/&#x27; =&gt; a / b</span><br><span class="line">            <span class="keyword">case</span> _ =&gt; <span class="string">&quot;illegal&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-匹配规则"><a href="#9-3-匹配规则" class="headerlink" title="9.3 匹配规则"></a>9.3 匹配规则</h3><h4 id="9-3-1-匹配常量"><a href="#9-3-1-匹配常量" class="headerlink" title="9.3.1 匹配常量"></a>9.3.1 匹配常量</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> =&gt; <span class="string">&quot;Int five&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> =&gt; <span class="string">&quot;String hello&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">&quot;Boolean true&quot;</span></span><br><span class="line">    <span class="keyword">case</span> &#x27;+&#x27; =&gt; <span class="string">&quot;Char +&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-2-匹配类型"><a href="#9-3-2-匹配类型" class="headerlink" title="9.3.2 匹配类型"></a>9.3.2 匹配类型</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配类型，类型前面需要增加变量名称，当需要使用该变量的时候，就可以使用这个值。这个变量就是将数据转换成为指定类型的变量</span></span><br><span class="line"><span class="comment">//Scala中的类型匹配时，是不考虑泛型的</span></span><br><span class="line"><span class="comment">//但是Array[Int] 里面的Int并不是真正的泛型，整体是一个类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i+<span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; <span class="string">&quot;String hello&quot;</span></span><br><span class="line">    <span class="keyword">case</span> m: <span class="type">List</span>[_] =&gt; <span class="string">&quot;List&quot;</span>    <span class="comment">//下划线表示任意类型都可以</span></span><br><span class="line">    <span class="keyword">case</span> c: <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">&quot;Array[Int]&quot;</span></span><br><span class="line">    <span class="keyword">case</span> someThing =&gt; <span class="string">&quot;something else &quot;</span> + someThing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-3-匹配数组"><a href="#9-3-3-匹配数组" class="headerlink" title="9.3.3 匹配数组"></a>9.3.3 匹配数组</h4><p>_代表任意值 *代表任意个数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (arr &lt;- <span class="type">Array</span>(</span><br><span class="line">    <span class="type">Array</span>(<span class="number">0</span>), </span><br><span class="line">    <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), </span><br><span class="line">    <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), </span><br><span class="line">    <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), </span><br><span class="line">    <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), </span><br><span class="line">    <span class="type">Array</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">90</span>))) &#123; <span class="comment">// 对一个数组集合进行遍历</span></span><br><span class="line">    <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//匹配Array(0) 这个数组</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y <span class="comment">//匹配有两个元素的数组，然后将将元素值赋给对应的x,y</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;以0开头的数组&quot;</span> <span class="comment">//匹配以0开头和数组</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;result = &quot;</span> + result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-4-匹配列表"><a href="#9-3-4-匹配列表" class="headerlink" title="9.3.4 匹配列表"></a>9.3.4 匹配列表</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (list &lt;- <span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//匹配List(0)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">List</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y <span class="comment">//匹配有两个元素的List</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;0 ...&quot;</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> first :: second :: rest =&gt; println(first + <span class="string">&quot;-&quot;</span> + second + <span class="string">&quot;-&quot;</span> + rest)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;something else&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-5-匹配元组"><a href="#9-3-5-匹配元组" class="headerlink" title="9.3.5 匹配元组"></a>9.3.5 匹配元组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (tuple &lt;- </span><br><span class="line">     <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = tuple <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">&quot;0 ...&quot;</span> <span class="comment">//是第一个元素是0的元组</span></span><br><span class="line">        <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; <span class="string">&quot;&quot;</span> + y + <span class="string">&quot;0&quot;</span> <span class="comment">// 匹配后一个元素是0的对偶元组</span></span><br><span class="line">        <span class="keyword">case</span> (a, b) =&gt; <span class="string">&quot;&quot;</span> + a + <span class="string">&quot; &quot;</span> + b</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span> <span class="comment">//默认</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式匹配常用用法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.scala.chapter08</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala04_Match</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO - 模式匹配 - 匹配规则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模式匹配</span></span><br><span class="line">        <span class="comment">//val (_, name, _) = (1, &quot;zhangsan&quot;, 30)</span></span><br><span class="line">       <span class="comment">// println(name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        val map = Map(</span></span><br><span class="line"><span class="comment">//            (&quot;a&quot;, 1), (&quot;b&quot;, 2), (&quot;c&quot;, 3)</span></span><br><span class="line"><span class="comment">//        )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        for ( (k, 2) &lt;- map ) &#123;</span></span><br><span class="line"><span class="comment">//            println( k )</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(</span><br><span class="line">            ((<span class="string">&quot;河北&quot;</span>, <span class="string">&quot;鞋&quot;</span>), <span class="number">10</span>),</span><br><span class="line">            ((<span class="string">&quot;河北&quot;</span>, <span class="string">&quot;衣服&quot;</span>), <span class="number">20</span>),</span><br><span class="line">            ((<span class="string">&quot;河北&quot;</span>, <span class="string">&quot;电脑&quot;</span>), <span class="number">15</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        list.map(</span><br><span class="line">            (t) =&gt; &#123;</span><br><span class="line">                t</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的代码中，使用模式匹配需要注意：</span></span><br><span class="line">        <span class="comment">// 1. 匹配数据时，需要使用case关键字</span></span><br><span class="line">        <span class="comment">// 2. case分支可能存在多个，那么需要将map的小括号换成大括号</span></span><br><span class="line"><span class="comment">//        val list1 = list.map &#123;</span></span><br><span class="line"><span class="comment">//            case ((prv, item), cnt) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//                (prv, (item, cnt * 2))</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        println(list1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">        println(<span class="string">s&quot;first=<span class="subst">$first</span>,second=<span class="subst">$second</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-6-匹配对象"><a href="#9-3-6-匹配对象" class="headerlink" title="9.3.6 匹配对象"></a>9.3.6 匹配对象</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>): <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>(name, age)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(user: <span class="type">User</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            <span class="type">None</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="type">Some</span>(user.name, user.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>) =&gt; <span class="string">&quot;yes&quot;</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;no&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-7-样例类"><a href="#9-3-7-样例类" class="headerlink" title="9.3.7 样例类"></a>9.3.7 样例类</h4><ul><li><p>样例类就是使用case关键字声明的类</p></li><li><p>样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中自动提供了一些常用的方法，如apply、unapply、toString、equals、hashCode和copy。</p></li><li><p>样例类是为模式匹配而优化的类，因为其默认提供了unapply方法，因此，样例类可以直接使用模式匹配，而无需自己实现unapply方法。</p></li><li><p>构造器中的每一个参数都成为val，除非它被显式地声明为var（不建议这样做）</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span>, var age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaCaseClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>) =&gt; <span class="string">&quot;yes&quot;</span></span><br><span class="line">            <span class="keyword">case</span> _ =&gt; <span class="string">&quot;no&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-4-应用场景"><a href="#9-4-应用场景" class="headerlink" title="9.4 应用场景"></a>9.4 应用场景</h3><h4 id="9-4-1-变量声明"><a href="#9-4-1-变量声明" class="headerlink" title="9.4.1 变量声明"></a>9.4.1 变量声明</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaMatch</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        println(<span class="string">s&quot;x=<span class="subst">$x</span>,y=<span class="subst">$y</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">        println(<span class="string">s&quot;first=<span class="subst">$first</span>,second=<span class="subst">$second</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> <span class="type">Person</span>(name, age) = <span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">16</span>)</span><br><span class="line">        println(<span class="string">s&quot;name=<span class="subst">$name</span>,age=<span class="subst">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-2-循环匹配"><a href="#9-4-2-循环匹配" class="headerlink" title="9.4.2 循环匹配"></a>9.4.2 循环匹配</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaMatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;B&quot;</span> -&gt; <span class="number">0</span>, <span class="string">&quot;C&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> ((k, v) &lt;- map) &#123; <span class="comment">//直接将map中的k-v遍历出来</span></span><br><span class="line">            println(k + <span class="string">&quot; -&gt; &quot;</span> + v) <span class="comment">//3个</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line">        <span class="comment">//遍历value=0的 k-v ,如果v不是0,过滤</span></span><br><span class="line">        <span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">            println(k + <span class="string">&quot; --&gt; &quot;</span> + <span class="number">0</span>) <span class="comment">// B-&gt;0</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line">        <span class="comment">//if v == 0 是一个过滤的条件</span></span><br><span class="line">        <span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            println(k + <span class="string">&quot; ---&gt; &quot;</span> + v) <span class="comment">// A-&gt;1 和 c-&gt;33</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-3-函数参数"><a href="#9-4-3-函数参数" class="headerlink" title="9.4.3 函数参数"></a>9.4.3 函数参数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaMatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> list = <span class="type">List</span>(</span><br><span class="line">            (<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> list1 = list.map &#123;</span><br><span class="line">            <span class="keyword">case</span> ( k, v ) =&gt; &#123;</span><br><span class="line">                (k, v*<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(list1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5-偏函数"><a href="#9-5-偏函数" class="headerlink" title="9.5 偏函数"></a>9.5 偏函数</h3><p>​所谓的偏函数，其实就是对集合中符合条件的数据进行处理的函数</p><p>​偏函数也是函数的一种，通过偏函数我们可以方便的对输入参数做更精确的检查。例如该偏函数的输入类型为Int，但是我们只考虑数值为1的时候，数据该如何处理，其他不考虑。</p><p><strong>基本语法</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明偏函数</span></span><br><span class="line"><span class="keyword">val</span> pf: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">// 应用偏函数</span></span><br><span class="line">println(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).collect(pf))</span><br></pre></td></tr></table></figure><hr><p><strong>案例实操</strong></p><p>将该List(1,2,3,4,5,6,”test”)中的Int类型的元素加一，并去掉字符串。</p><p>不使用偏函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;test&quot;</span>).filter(_.isInstanceOf[<span class="type">Int</span>]).map(_.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span>).foreach(println)</span><br></pre></td></tr></table></figure><p>使用偏函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;test&quot;</span>).collect &#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span> &#125;.foreach(println)</span><br></pre></td></tr></table></figure><p>collect就是一个偏函数</p><h2 id="10-异常"><a href="#10-异常" class="headerlink" title="10. 异常"></a>10. 异常</h2><p>Scala异常语法处理上和Java类似，但是又不尽相同。</p><p><strong>Java异常：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">    <span class="comment">// catch时，需要将范围小的写到前面</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Scala异常</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> n= <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ex: <span class="type">ArithmeticException</span>=&gt;&#123;</span><br><span class="line">                <span class="comment">// 发生算术异常</span></span><br><span class="line">                println(<span class="string">&quot;发生算术异常&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> ex: <span class="type">Exception</span>=&gt;&#123;</span><br><span class="line">                <span class="comment">// 对异常处理</span></span><br><span class="line">                println(<span class="string">&quot;发生了异常1&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-隐式转换"><a href="#11-隐式转换" class="headerlink" title="11. 隐式转换"></a>11. 隐式转换</h2><h3 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h3><p>​在之前的类型学习中，我们已经学习了自动类型转换，精度小的类型可以自动转换为精度大的类型，这个转换过程无需开发人员参与，由编译器自动完成，这个转换操作我们称之为隐式转换。</p><p>​在其他的场合，隐式转换也起到了非常重要的作用。如Scala在程序编译错误时，可以通过隐式转换中类型转换机制尝试进行二次编译，将本身错误无法编译通过的代码通过类型转换后编译通过。慢慢地，这也形成了一种扩展功能的转换机制。这个听着很抽象，不好理解，不急，咱慢慢体会。</p><h3 id="11-2-隐式函数"><a href="#11-2-隐式函数" class="headerlink" title="11.2 隐式函数"></a>11.2 隐式函数</h3><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662306692988.png" alt="1662306692988"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImplicit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>( d : <span class="type">Double</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            d.toInt</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> d : <span class="type">Double</span> = <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">val</span> i : <span class="type">Int</span> = d</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-隐式参数、隐式变量"><a href="#11-3-隐式参数、隐式变量" class="headerlink" title="11.3 隐式参数、隐式变量"></a>11.3 隐式参数、隐式变量</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImplicit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>( <span class="keyword">implicit</span>  d : <span class="type">Double</span> ) = &#123;</span><br><span class="line">            d.toInt</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">val</span> dd : <span class="type">Double</span> = <span class="number">2.0</span></span><br><span class="line">        println(transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​隐式参数和隐式变量是成对出现的，就是把隐式变量赋值给隐式参数，但是我们不需要传递，这个传递的过程是编译器完成的</p><p>​<strong>在同一个作用域中，如果有相同的转换规则的多个数据，会发生错误。</strong></p><h3 id="11-4-隐式类"><a href="#11-4-隐式类" class="headerlink" title="11.4 隐式类"></a>11.4 隐式类</h3><p>​在Scala2.10后提供了隐式类，可以使用implicit声明类，隐式类非常强大，同样可以扩展类的功能，在集合的数据处理中，隐式类发挥了重要的作用。</p><ul><li><p>其所带的构造参数有且只能有一个</p></li><li><p>隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶级的。</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImplicit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> emp = <span class="keyword">new</span> <span class="type">Emp</span>()</span><br><span class="line">        emp.insertUser()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params"> emp : <span class="type">Emp</span></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">insertUser</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(<span class="string">&quot;insert user...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-5-隐式机制"><a href="#11-5-隐式机制" class="headerlink" title="11.5 隐式机制"></a>11.5 隐式机制</h3><p>所谓的隐式机制，就是一旦出现编译错误时，编译器会从哪些地方查找对应的隐式转换规则</p><p>Ø  当前代码作用域</p><p>Ø  当前代码上级作用域</p><p>Ø  当前类所在的包对象</p><p>Ø  当前类（对象）的父类（父类）或特质（父特质）</p><p>其实最直接的方式就是直接导入。</p><h2 id="12-泛型"><a href="#12-泛型" class="headerlink" title="12. 泛型"></a>12. 泛型</h2><p>​Scala的泛型和Java中的泛型表达的含义都是一样的，对处理的数据类型进行约束，但是Scala提供了更加强大的功能</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> elements: <span class="type">List</span>[<span class="type">A</span>] = <span class="type">Nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-1-泛型转换"><a href="#12-1-泛型转换" class="headerlink" title="12.1 泛型转换"></a>12.1 泛型转换</h3><h4 id="12-1-1-泛型不可变"><a href="#12-1-1-泛型不可变" class="headerlink" title="12.1.1 泛型不可变"></a>12.1.1 泛型不可变</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> test1 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">User</span>] <span class="comment">// OK</span></span><br><span class="line">        <span class="keyword">val</span> test2 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">Parent</span>] <span class="comment">// Error</span></span><br><span class="line">        <span class="keyword">val</span> test3 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">SubUser</span>]  <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-1-2-泛型协变"><a href="#12-1-2-泛型协变" class="headerlink" title="12.1.2 泛型协变"></a>12.1.2 泛型协变</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> test1 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">User</span>] <span class="comment">// OK</span></span><br><span class="line">        <span class="keyword">val</span> test2 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">Parent</span>] <span class="comment">// Error</span></span><br><span class="line">        <span class="keyword">val</span> test3 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">SubUser</span>]  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-1-3-泛型逆变"><a href="#12-1-3-泛型逆变" class="headerlink" title="12.1.3 泛型逆变"></a>12.1.3 泛型逆变</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> test1 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">User</span>] <span class="comment">// OK</span></span><br><span class="line">        <span class="keyword">val</span> test2 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">Parent</span>] <span class="comment">// OK</span></span><br><span class="line">        <span class="keyword">val</span> test3 : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">SubUser</span>]  <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12-2-泛型边界"><a href="#12-2-泛型边界" class="headerlink" title="12.2 泛型边界"></a>12.2 泛型边界</h3><p>​Scala的泛型可以根据功能设定类树的边界</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> parent : <span class="type">Parent</span> = <span class="keyword">new</span> <span class="type">Parent</span>()</span><br><span class="line">        <span class="keyword">val</span> user : <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">        <span class="keyword">val</span> subuser : <span class="type">SubUser</span> = <span class="keyword">new</span> <span class="type">SubUser</span>()</span><br><span class="line">        test[<span class="type">User</span>](parent) <span class="comment">// Error</span></span><br><span class="line">        test[<span class="type">User</span>](user)   <span class="comment">// OK</span></span><br><span class="line">        test[<span class="type">User</span>](subuser) <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">test</span></span>[<span class="type">A</span>]( a : <span class="type">A</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-2-1-泛型上限"><a href="#12-2-1-泛型上限" class="headerlink" title="12.2.1 泛型上限"></a>12.2.1 泛型上限</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> parent : <span class="type">Parent</span> = <span class="keyword">new</span> <span class="type">Parent</span>()</span><br><span class="line">        <span class="keyword">val</span> user : <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">        <span class="keyword">val</span> subuser : <span class="type">SubUser</span> = <span class="keyword">new</span> <span class="type">SubUser</span>()</span><br><span class="line">        test[<span class="type">Parent</span>](parent) <span class="comment">// Error</span></span><br><span class="line">        test[<span class="type">User</span>](user)   <span class="comment">// OK</span></span><br><span class="line">        test[<span class="type">SubUser</span>](subuser) <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">test</span></span>[<span class="type">A</span>&lt;:<span class="type">User</span>]( a : <span class="type">A</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-2-2-泛型下限"><a href="#12-2-2-泛型下限" class="headerlink" title="12.2.2 泛型下限"></a>12.2.2 泛型下限</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> parent : <span class="type">Parent</span> = <span class="keyword">new</span> <span class="type">Parent</span>()</span><br><span class="line">        <span class="keyword">val</span> user : <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">        <span class="keyword">val</span> subuser : <span class="type">SubUser</span> = <span class="keyword">new</span> <span class="type">SubUser</span>()</span><br><span class="line">        test[<span class="type">Parent</span>](parent) <span class="comment">// OK</span></span><br><span class="line">        test[<span class="type">User</span>](user)   <span class="comment">// OK</span></span><br><span class="line">        test[<span class="type">SubUser</span>](subuser) <span class="comment">// Error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span>  <span class="title">test</span></span>[<span class="type">A</span>&gt;:<span class="type">User</span>]( a : <span class="type">A</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-上下文限定"><a href="#12-3-上下文限定" class="headerlink" title="12.3 上下文限定"></a>12.3 上下文限定</h3><p>​上下文限定是将泛型和隐式转换的结合产物，以下两者功能相同，使用上下文限定[A : Ordering]之后，方法内无法使用隐式参数名调用隐式参数，需要通过implicitly[Ordering[A]]获取隐式变量，如果此时无法查找到对应类型的隐式变量，会发生出错误。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span> : <span class="type">Test</span>](a: <span class="type">A</span>) = println(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">val</span> test : <span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">User</span>]</span><br><span class="line">        f( <span class="keyword">new</span> <span class="type">User</span>() )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-正则表达式"><a href="#13-正则表达式" class="headerlink" title="13 正则表达式"></a>13 正则表达式</h2><h3 id="13-1-简介"><a href="#13-1-简介" class="headerlink" title="13.1 简介"></a>13.1 简介</h3><p>​正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662379360534.png" alt="1662379360534"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662379378344.png" alt="1662379378344"></p><p><img src="/2022/09/03/scala/scala%E7%AE%80%E4%BB%8B/1662379386353.png" alt="1662379386353"></p><h3 id="13-2-基本语法"><a href="#13-2-基本语法" class="headerlink" title="13.2 基本语法"></a>13.2 基本语法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaRegex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 构建正则表达式</span></span><br><span class="line">        <span class="keyword">val</span> pattern = <span class="string">&quot;Scala&quot;</span>.r</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">&quot;Scala is Scalable Language&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配字符串 - 第一个</span></span><br><span class="line">        println(pattern findFirstIn str)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配字符串 - 所有</span></span><br><span class="line">        <span class="keyword">val</span> iterator: <span class="type">Regex</span>.<span class="type">MatchIterator</span> = pattern findAllIn str</span><br><span class="line">        <span class="keyword">while</span> ( iterator.hasNext ) &#123;</span><br><span class="line">            println(iterator.next())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;***************************&quot;</span>)</span><br><span class="line">        <span class="comment">// 匹配规则：大写，小写都可</span></span><br><span class="line">        <span class="keyword">val</span> pattern1 = <span class="keyword">new</span> <span class="type">Regex</span>(<span class="string">&quot;(S|s)cala&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> str1 = <span class="string">&quot;Scala is scalable Language&quot;</span></span><br><span class="line">        println((pattern1 findAllIn str1).mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-3-案例实操"><a href="#13-3-案例实操" class="headerlink" title="13.3  案例实操"></a>13.3  案例实操</h3><ul><li>手机号正则表达式验证方法</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaRegex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 构建正则表达式</span></span><br><span class="line">        println(isMobileNumber(<span class="string">&quot;18801234567&quot;</span>))</span><br><span class="line">        println(isMobileNumber(<span class="string">&quot;11111111111&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMobileNumber</span></span>(number: <span class="type">String</span>): <span class="type">Boolean</span> =&#123;</span><br><span class="line">        <span class="keyword">val</span> regex = <span class="string">&quot;^((13[0-9])|(14[5,7,9])|(15[^4])|(18[0-9])|(17[0,1,3,5,6,7,8]))[0-9]&#123;8&#125;$&quot;</span>.r</span><br><span class="line">        <span class="keyword">val</span> length = number.length</span><br><span class="line">        regex.findFirstMatchIn(number.slice(length<span class="number">-11</span>,length)) != <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提取邮件地址的域名部分</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaRegex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 构建正则表达式</span></span><br><span class="line">        <span class="keyword">val</span> r = <span class="string">&quot;&quot;&quot;([_A-Za-z0-9-]+(?:\.[_A-Za-z0-9-\+]+)*)(@[A-Za-z0-9-]+(?:\.[A-Za-z0-9-]+)*(?:\.[A-Za-z]&#123;2,&#125;)) ?&quot;&quot;&quot;</span>.r</span><br><span class="line">        println(r.replaceAllIn(<span class="string">&quot;abc.edf+jianli@gmail.com   hello@gmail.com.cn&quot;</span>, (m =&gt; <span class="string">&quot;*****&quot;</span> + m.group(<span class="number">2</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> groupBy </tag>
            
            <tag> flatMap </tag>
            
            <tag> Scala </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 特质 </tag>
            
            <tag> 样例类 </tag>
            
            <tag> reduce </tag>
            
            <tag> reduceLeft </tag>
            
            <tag> fold </tag>
            
            <tag> filter </tag>
            
            <tag> sliding </tag>
            
            <tag> List </tag>
            
            <tag> Set </tag>
            
            <tag> Map </tag>
            
            <tag> 模式匹配 </tag>
            
            <tag> 偏函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase概述</title>
      <link href="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Hbase简介"><a href="#1-Hbase简介" class="headerlink" title="1.Hbase简介"></a>1.Hbase简介</h2><h3 id="1-1-Hbase定义"><a href="#1-1-Hbase定义" class="headerlink" title="1.1 Hbase定义"></a>1.1 Hbase定义</h3><p>​它是一种分布式、可扩展、支持海量数据存储的NoSQL数据库</p><h3 id="1-2-HBase数据模型"><a href="#1-2-HBase数据模型" class="headerlink" title="1.2 HBase数据模型"></a>1.2 HBase数据模型</h3><p>​逻辑上，HBase的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从HBase的底层物理存储结构（K-V）来看，HBase更像是一个multi-dimensional<br>map。</p><h4 id="1-2-1-HBase逻辑结构"><a href="#1-2-1-HBase逻辑结构" class="headerlink" title="1.2.1 HBase逻辑结构"></a>1.2.1 HBase逻辑结构</h4><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662083629185.png" alt="1662083629185"></p><h4 id="1-2-2-HBase物理结构"><a href="#1-2-2-HBase物理结构" class="headerlink" title="1.2.2 HBase物理结构"></a>1.2.2 HBase物理结构</h4><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662083681648.png" alt="1662083681648"></p><h4 id="1-2-3-数据模型"><a href="#1-2-3-数据模型" class="headerlink" title="1.2.3 数据模型"></a>1.2.3 数据模型</h4><p><strong>1）Name Space</strong></p><p>​命名空间，类似于关系型数据库的database概念，每个命名空间下有多个表。HBase有两个自带的命名空间，分别是hbase和default，hbase中存放的是HBase内置的表，default表是用户默认使用的命名空间。</p><p><strong>2）Table</strong></p><p>​类似于关系型数据库的表概念。不同的是，HBase定义表时只需要声明列族即可，不需要声明具体的列。这意味着，往HBase写入数据时，字段可以动态、按需指定。因此，和关系型数据库相比，HBase能够轻松应对字段变更的场景。</p><p><strong>3）Row</strong></p><p>​HBase表中的每行数据都由一个<strong>RowKey</strong>和多个<strong>Column</strong>（列）组成，数据是按照RowKey的字典顺序存储的，并且查询数据时只能根据RowKey进行检索，所以RowKey的设计十分重要。</p><p><strong>4）Column</strong></p><p>​HBase中的每个列都由Column Family(列族)和Column Qualifier（列限定符）进行限定，例如info：name，info：age。建表时，只需指明列族，而列限定符无需预先定义。</p><p><strong>5）Time Stamp</strong></p><p>​用于标识数据的不同版本（version），每条数据写入时，系统会自动为其加上该字段，其值为写入HBase的时间。</p><p><strong>6）Cell</strong></p><p>​由{rowkey, column Family：column Qualifier, time Stamp} 唯一确定的单元。cell中的数据全部是字节码形式存贮。</p><h3 id="1-3-HBase基本架构"><a href="#1-3-HBase基本架构" class="headerlink" title="1.3 HBase基本架构"></a>1.3 HBase基本架构</h3><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662085829198.png" alt="1662085829198"></p><p><strong>架构角色：</strong></p><p><strong>1）Region Server</strong></p><p>​Region Server为 Region的管理者，其实现类为HRegionServer，主要作用如下:</p><p>​对于数据的操作：get, put, delete；</p><p>​对于Region的操作：splitRegion、compactRegion。</p><p><strong>2）Master</strong></p><p>​Master是所有Region Server的管理者，其实现类为HMaster，主要作用如下：</p><p>​对于表的操作：create, delete, alter</p><p>​对于RegionServer的操作：分配regions到每个RegionServer，监控每个RegionServer的状态，负载均衡和故障转移。</p><p><strong>3）Zookeeper</strong></p><p>​HBase通过Zookeeper来做master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。</p><p><strong>4）HDFS</strong></p><p>​HDFS为Hbase提供最终的底层数据存储服务，同时为HBase提供高可用的支持。</p><h2 id="2-HBase-Shell操作"><a href="#2-HBase-Shell操作" class="headerlink" title="2. HBase Shell操作"></a>2. HBase Shell操作</h2><p><strong>1．查看当前Hbase中有哪些namespace</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; list_namespace</span><br><span class="line"></span><br><span class="line">NAMESPACE                                                                                 </span><br><span class="line">default(创建表时未指定命名空间的话默认在default下)                                             hbase(系统使用的，用来存放系统相关的元数据信息等，勿随便操作)  </span><br></pre></td></tr></table></figure><p><strong>2．创建namespace</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt;  create_namespace &quot;test&quot;</span><br><span class="line"></span><br><span class="line">hbase(main):010:0&gt; create_namespace &quot;test01&quot;, &#123;&quot;author&quot;=&gt;&quot;wyh&quot;, &quot;create_time&quot;=&gt;&quot;2020-03-10 08:08:08&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>3.查看namespace</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt;  describe_namespace &quot;test01&quot;</span><br></pre></td></tr></table></figure><p><strong>4.修改namespace的信息（添加或者修改属性）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt; alter_namespace &quot;test01&quot;, &#123;METHOD =&gt; &#x27;set&#x27;, &#x27;author&#x27; =&gt; &#x27;weiyunhui&#x27;&#125;</span><br></pre></td></tr></table></figure><p><strong>添加或者修改属性:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter_namespace &#x27;ns1&#x27;, &#123;METHOD =&gt; &#x27;set&#x27;, &#x27;PROPERTY_NAME&#x27; =&gt; &#x27;PROPERTY_VALUE&#x27;&#125; </span><br></pre></td></tr></table></figure><p><strong>删除属性:</strong>          </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter_namespace &#x27;ns1&#x27;, &#123;METHOD =&gt; &#x27;unset&#x27;, NAME =&gt; &#x27; PROPERTY_NAME &#x27;&#125; </span><br></pre></td></tr></table></figure><p><strong>5.删除namespace</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt; drop_namespace &quot;test01&quot;</span><br><span class="line">注意: 要删除的namespace必须是空的，其下没有表。</span><br></pre></td></tr></table></figure><p><strong>6.查看当前数据库中有那些表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; list</span><br></pre></td></tr></table></figure><p><strong>7.创建表</strong></p><p> 下面这个表就会在default 之中建立student这个表格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; create &#x27;student&#x27;,&#x27;info&#x27;</span><br></pre></td></tr></table></figure><p>如果想再其它数据库中建立表格我们可以用如下语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; create &#x27;namespace:student&#x27;,&#x27;info&#x27;</span><br></pre></td></tr></table></figure><p>上述namespace就是代表了你的数据库名字    </p><p>创建表格的时候，我们必须要为这个表格添加一个列族，就是加一个逗号，后面跟着的字符串就是列族名称 </p><p>如果想要给列族增加一些其它信息，可以使用如下语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; create &#x27;namespace:student&#x27;,&#123;NAME =&gt; &#x27;info&#x27;,VERSION =&gt; 5&#125; </span><br></pre></td></tr></table></figure><p><strong>8.插入数据到表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; put &#x27;student&#x27;,&#x27;1001&#x27;,&#x27;info:sex&#x27;,&#x27;male&#x27;</span><br><span class="line">hbase(main):004:0&gt; put &#x27;student&#x27;,&#x27;1001&#x27;,&#x27;info:age&#x27;,&#x27;18&#x27;</span><br><span class="line">hbase(main):005:0&gt; put &#x27;student&#x27;,&#x27;1002&#x27;,&#x27;info:name&#x27;,&#x27;Janna&#x27;</span><br><span class="line">hbase(main):006:0&gt; put &#x27;student&#x27;,&#x27;1002&#x27;,&#x27;info:sex&#x27;,&#x27;female&#x27;</span><br><span class="line">hbase(main):007:0&gt; put &#x27;student&#x27;,&#x27;1002&#x27;,&#x27;info:age&#x27;,&#x27;20&#x27;</span><br></pre></td></tr></table></figure><p><strong>9.扫描查看表数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):008:0&gt; scan &#x27;student&#x27;</span><br><span class="line">hbase(main):009:0&gt; scan &#x27;student&#x27;,&#123;STARTROW =&gt; &#x27;1001&#x27;, STOPROW  =&gt; &#x27;1001&#x27;&#125;</span><br><span class="line">hbase(main):010:0&gt; scan &#x27;student&#x27;,&#123;STARTROW =&gt; &#x27;1001&#x27;&#125;</span><br></pre></td></tr></table></figure><p><strong>10.查看表结构</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):011:0&gt; describe &#x27;student&#x27;</span><br></pre></td></tr></table></figure><p><strong>11.更新指定字段的数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):012:0&gt; put &#x27;student&#x27;,&#x27;1001&#x27;,&#x27;info:name&#x27;,&#x27;Nick&#x27;</span><br><span class="line">hbase(main):013:0&gt; put &#x27;student&#x27;,&#x27;1001&#x27;,&#x27;info:age&#x27;,&#x27;100&#x27;</span><br></pre></td></tr></table></figure><p><strong>12.查看“指定行”或“指定列族:列”的数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):014:0&gt; get &#x27;student&#x27;,&#x27;1001&#x27;</span><br><span class="line">hbase(main):015:0&gt; get &#x27;student&#x27;,&#x27;1001&#x27;,&#x27;info:name&#x27;</span><br></pre></td></tr></table></figure><p><strong>13.统计表数据行数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):021:0&gt; count &#x27;student&#x27;</span><br></pre></td></tr></table></figure><p><strong>14.删除数据</strong></p><p>​删除某rowkey的全部数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):016:0&gt; deleteall &#x27;student&#x27;,&#x27;1001&#x27;</span><br></pre></td></tr></table></figure><p>​删除某rowkey的某一列数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):017:0&gt; delete &#x27;student&#x27;,&#x27;1002&#x27;,&#x27;info:sex&#x27;</span><br></pre></td></tr></table></figure><p><strong>15.清空表数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):018:0&gt; truncate &#x27;student&#x27;</span><br></pre></td></tr></table></figure><p>提示：清空表的操作顺序为先disable，然后再truncate。</p><p><strong>16.删除表</strong></p><p>​首先需要先让该表为disable状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):019:0&gt; disable &#x27;student&#x27;</span><br></pre></td></tr></table></figure><p>​然后才能drop这个表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):020:0&gt; drop &#x27;student&#x27;</span><br></pre></td></tr></table></figure><hr><p><strong>version 和 timestamp的联系</strong></p><p>​version我们可以建表的时候自己指定，粒度是针对于某一个列族而言，这个数字代表了我们会存储最近n次的数据，就好比某一个列族、一个列限定符确定的cell，我们对其进行修改，其实是会把之前的数据也保存下来的，这个是用timestamp来区分的，每次我们都会取timestamp最大的作为最新的数据，这个version就是我们会保存几次原始的数据，如果修改次数过多，超过了version的数字，我们就需要删除之前的数据。</p><p>​在HBase之中，我们都是使用的追加的操作，因此比较高效</p><h2 id="3-RegionServer-基础架构"><a href="#3-RegionServer-基础架构" class="headerlink" title="3. RegionServer 基础架构"></a>3. RegionServer 基础架构</h2><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662099311523.png" alt="1662099311523"></p><p><strong>1）StoreFile</strong></p><p>​保存实际数据的物理文件，StoreFile以Hfile的形式存储在HDFS上。每个Store会有一个或多个StoreFile（HFile），数据在每个StoreFile中都是有序的。其中Store是存放的每一个列族的数据 ，HFile是HBase实现的文件格式，其中文件是由多个64KB大小的block组成的。</p><p><strong>2）MemStore</strong></p><p>​写缓存，由 于HFile中的数据要求是有序的，所以数据是先存储在MemStore中，排好序后，等到达刷写时机才会刷写到HFile，每次刷写都会形成一个新的HFile。</p><p> <strong>3）WAL</strong></p><p>​由于数据要经MemStore排序后才能刷写到HFile，但把数据保存在内存中会有很高的概率导致数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，然后再写入MemStore中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。</p><p><strong>4）BlockCache</strong></p><p>​读缓存，每次查询出的数据会缓存在BlockCache中，方便下次查询。最大限制是HBase内存的40% </p><h2 id="4-HBase数据写流程"><a href="#4-HBase数据写流程" class="headerlink" title="4. HBase数据写流程"></a>4. HBase数据写流程</h2><p>​Hbase会默认存在一个名为Hbase的namespace，里面有个meta的表格，其中存放着元数据信息，而某一个client写数据的时候，需要获取到这个元数据信息，才能去写数据，这个meta到底在哪一个regionserver维护？需要client去zookeeper中去寻找。</p><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662126233372.png" alt="1662126233372"></p><p> meta表格信息如下：</p><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662126326550.png" alt="1662126326550"></p><p>​ client可以从meta表格中获取哪一个表格是由哪一个regionserver所维护的，因此就可以向这个表格增加数据</p><p> <img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662126465194.png" alt="1662126465194"></p><ol><li>首先client会去zookeeper请求存放meta表格的regionserver</li><li>访问对应的regionserver，获取meta表格信息，根据自身所请求的表格和rowkey，确定目标数据位于哪一个regionserver中的哪一个region。并且把该table中的region信息以及meta表位置信息缓存到meta cache之中，方便下次访问</li><li>然后与目标regionserver进行通讯</li><li>将数据顺序写入目标RS的WAL文件之中</li><li>然后把数据写入memstore中，数据会在memstore中进行排序</li><li>向客户端发送ack</li><li>等达到memstore的刷写机制之后，把数据刷写到HFile中去。</li></ol><h2 id="5-Memstore刷写操作"><a href="#5-Memstore刷写操作" class="headerlink" title="5. Memstore刷写操作"></a>5. Memstore刷写操作</h2><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662126813770.png" alt="1662126813770"></p><ol><li><p>当某个memstore的大小达到了<strong>hbase.hregion.memstore.flush.size（默认值128M）</strong>，其所在region的所有memstore都会刷写。 </p><p>当memstore的大小达到了 <strong>hbase.hregion.memstore.flush.size</strong>（默认值128M）*<strong>hbase.hregion.memstore.block.multiplier</strong>（默认值4）时，会阻止继续往该memstore写数据。主要是由于可能写的速度非常快，可能上一次判断还是127MB，下一次判断就直接变为了512MB，由于写的速度很快导致的</p></li><li><p>当region server中memstore的总大小达到</p><p><strong>java_heapsize</strong></p><p><em><strong>hbase.regionserver.global.memstore.size</strong></em><em>（默认值0.4</em>*<strong>）</strong></p><p><em><strong>hbase.regionserver.global.memstore.size.lower.limit</strong></em><em>（默认值0.95</em>*<strong>）</strong>，</p><p>region会按照其所有memstore的大小顺序（由大到小）依次进行刷写。直到region server中所有memstore的总大小减小到上述值以下。（其实就是达到堆内存的38%之后，就会执行刷写操作）</p><p>当region server 中memstore的总大小达到</p><p><strong>java_heapsize</strong></p><p>*<strong>hbase.regionserver.global.memstore.size（默认值0.4）</strong></p><p>时，会阻止继续往所有的memstore写数据。</p></li><li><p>到达自动刷写的时间，也会触发memstore flush。自动刷新的时间间隔由该属性进行配置<strong>hbase.regionserver.optionalcacheflushinterval（默认1小时）</strong>。</p></li><li><p>当WAL文件的数量超过<strong>hbase.regionserver.max.logs</strong>，region会按照时间顺序依次进行刷写，直到WAL文件数量减小到<strong>hbase.regionserver.max.logs</strong>以下（该属性名已经废弃，现无需手动设置，最大值为32）。</p></li></ol><h2 id="6-Hbase读流程"><a href="#6-Hbase读流程" class="headerlink" title="6. Hbase读流程"></a>6. Hbase读流程</h2><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662128183264.png" alt="1662128183264"></p><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662128199205.png" alt="1662128199205"></p><p><strong>读流程</strong></p><p>1）Client先访问zookeeper，获取hbase:meta表位于哪个Region Server。</p><p>2）访问对应的Region Server，获取hbase:meta表，根据读请求的namespace:table&#x2F;rowkey，查询出目标数据位于哪个Region Server中的哪个Region中。并将该table的region信息以及meta表 位置信息缓存在客户端的meta cache，方便下次访问。</p><p>3）与目标Region Server进行通讯；</p><p>4）分别在MemStore和Store File（HFile）中查询目标数据，并将查到的所有数据进行合并。此处所有数据是指同一条数据的不同版本（time stamp）或者不同的类型（Put&#x2F;Delete）。</p><p>5）将查询到的新的数据块（Block，HFile数据存储单元，默认大小为64KB）缓存到Block Cache。</p><p>6）将合并后的最终结果返回给客户端。</p><h2 id="7-HBase读取数据为何速度很快？"><a href="#7-HBase读取数据为何速度很快？" class="headerlink" title="7. HBase读取数据为何速度很快？"></a>7. HBase读取数据为何速度很快？</h2><p>​ 由6题中可知，我们HBase读取某一个数据的时候需要把HFile文件和Memstore中的文件进行合并，然后才能得到最新的数据，这么繁琐的操作是如何保证读取速度很快的呢？</p><p>​主要归功于时间范围、Rowkey范围、以及布隆过滤器等操作。</p><p>​ 首先我们可以根据时间范围、Rowkey把很多的Hfile过滤掉。然后可以根据布隆过滤器来接着筛选Hfile文件</p><p><strong>布隆过滤器原理</strong></p><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662128821165.png" alt="1662128821165"></p><p>​布隆过滤器可以让我们知道，这个文件并不存在某一条数据。</p><p>​文件会维护一个数组。然后当client插入数据的时候，会经过三个hash算法，算出来三个值，然后我们把这个数组对应的位置赋值为1，当用户读取数据的时候，也是会把该数据经过这三个hash算法，如果三个值都为1，那么这个数据就有可能存在这个文件中，如果其中有一个不是1，那么这个数据肯定不存在于这个文件当中。</p><p>​这样就可以避免去遍历这个文件中的所有数据来判断这个数据是否存在，因此极大提升了读取数据速度。</p><h2 id="8-StoreFile的合并操作"><a href="#8-StoreFile的合并操作" class="headerlink" title="8. StoreFile的合并操作"></a>8. StoreFile的合并操作</h2><p>​由于memstore每次刷写都会生成一个新的HFile，且同一个字段的不同版本（timestamp）和不同类型（Put&#x2F;Delete）有可能会分布在不同的HFile中，因此查询时需要遍历所有的HFile。为了减少HFile的个数，以及清理掉过期和删除的数据，会进行StoreFile Compaction。</p><p>​Compaction分为两种，分别是Minor Compaction和Major Compaction。Minor Compaction会将临近的若干个较小的HFile合并成一个较大的HFile，并清理掉部分过期和删除的数据。Major Compaction会将一个Store下的所有的HFile合并成一个大HFile，并且<strong>会清理掉所有过期和删除的数据</strong>。</p><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662129173208.png" alt="1662129173208"></p><h2 id="9-Region-Split"><a href="#9-Region-Split" class="headerlink" title="9. Region Split"></a>9. Region Split</h2><p>​默认情况下，每个Table起初只有一个Region，随着数据的不断写入，Region会自动进行拆分。刚拆分时，两个子Region都位于当前的Region Server，但处于负载均衡的考虑，HMaster有可能会将某个Region转移给其他的Region Server。</p><p>​Region Split时机：</p><ol><li><p>当1个region中的某个Store下所有StoreFile的总大小超过hbase.hregion.max.filesize，该Region就会进行拆分（0.94版本之前）。大小是10GB </p><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662129413947.png" alt="1662129413947"></p></li><li><p>当1个region中的某个Store下所有StoreFile的总大小超过Min(initialSize<em>R^3 ,hbase.hregion.max.filesize”)，该Region就会进行拆分。其中initialSize的默认值为2</em>hbase.hregion.memstore.flush.size，R为当前Region Server中属于该Table的Region个数（0.94版本之后）。</p><p>具体的切分策略为：</p><p>第一次split：1^3 * 256 &#x3D; 256MB </p><p>第二次split：2^3 * 256 &#x3D; 2048MB </p><p>第三次split：3^3 * 256 &#x3D; 6912MB </p><p>第四次split：4^3 * 256 &#x3D; 16384MB &gt; 10GB，因此取较小的值10GB </p><p>后面每次split的size都是10GB了。</p></li><li><p>Hbase 2.0引入了新的split策略：如果当前RegionServer上该表只有一个Region，按照2 * hbase.hregion.memstore.flush.size分裂，否则按照hbase.hregion.max.filesize分裂。</p></li></ol><p> <img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662129619223.png" alt="1662129619223"></p><h2 id="10-Hbase优化"><a href="#10-Hbase优化" class="headerlink" title="10.Hbase优化"></a>10.Hbase优化</h2><h3 id="10-1-预分区"><a href="#10-1-预分区" class="headerlink" title="10.1 预分区"></a>10.1 预分区</h3><p>​每一个region维护着startRow与endRowKey，如果加入的数据符合某个region维护的rowKey范围，则该数据交给这个region维护。那么依照这个原则，我们可以将数据所要投放的分区提前大致的规划好，以提高HBase性能。</p><p><strong>1.手动设置预分区</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">hbase&gt; </span><span class="language-bash">create <span class="string">&#x27;staff1&#x27;</span>,<span class="string">&#x27;info&#x27;</span>,SPLITS =&gt; [<span class="string">&#x27;1000&#x27;</span>,<span class="string">&#x27;2000&#x27;</span>,<span class="string">&#x27;3000&#x27;</span>,<span class="string">&#x27;4000&#x27;</span>]</span></span><br></pre></td></tr></table></figure><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662130710167.png" alt="1662130710167"></p><p><strong>2.生成十六进制序列预分区</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x27;staff2&#x27;,&#x27;info&#x27;,&#123;NUMREGIONS =&gt; 15, SPLITALGO =&gt; &#x27;HexStringSplit&#x27;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662130740089.png" alt="1662130740089"></p><p><strong>3.按照文件中设置的规则预分区</strong></p><p>创建splits.txt文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaaa</span><br><span class="line">bbbb</span><br><span class="line">cccc</span><br><span class="line">dddd</span><br><span class="line">eeee</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x27;staff3&#x27;,&#x27;info&#x27;,SPLITS_FILE =&gt; &#x27;splits.txt&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662130786078.png" alt="1662130786078"></p><p><strong>4.通过javaAPI来分区</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义算法，产生一系列Hash散列值存储在二维数组中</span></span><br><span class="line"><span class="type">byte</span>[][] splitKeys = 某个散列值函数</span><br><span class="line"><span class="comment">//创建HbaseAdmin实例</span></span><br><span class="line"><span class="type">HBaseAdmin</span> <span class="variable">hAdmin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBaseAdmin</span>(HbaseConfiguration.create());</span><br><span class="line"><span class="comment">//创建HTableDescriptor实例</span></span><br><span class="line"><span class="type">HTableDescriptor</span> <span class="variable">tableDesc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HTableDescriptor</span>(tableName);</span><br><span class="line"><span class="comment">//通过HTableDescriptor实例和散列值二维数组创建带有预分区的Hbase表</span></span><br><span class="line">hAdmin.createTable(tableDesc, splitKeys);</span><br></pre></td></tr></table></figure><p><img src="/2022/09/02/Hbase/Hbase%E6%A6%82%E5%BF%B5/1662130842605.png" alt="1662130842605"></p><h3 id="10-2-rowkey设计"><a href="#10-2-rowkey设计" class="headerlink" title="10.2 rowkey设计"></a>10.2 rowkey设计</h3><p>​一条数据的唯一标识就是rowkey，那么这条数据存储于哪个分区，取决于rowkey处于哪个一个预分区的区间内，设计rowkey的主要目的，就是让数据均匀的分布于所有的region中，在一定程度上防止数据倾斜。接下来我们就谈一谈rowkey常用的设计方案。</p><p><strong>1.生成随机数、hash、散列值</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">原本rowKey为1001的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7</span><br><span class="line">原本rowKey为3001的，SHA1后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd</span><br><span class="line">原本rowKey为5001的，SHA1后变成：7b61dec07e02c188790670af43e717f0f46e8913</span><br><span class="line">在做此操作之前，一般我们会选择从数据集中抽取样本，来决定什么样的rowKey来Hash后作为每个分区的临界值。</span><br></pre></td></tr></table></figure><p><strong>2.字符串反转</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20170524000001转成10000042507102   20170524000002转成20000042507102   </span><br></pre></td></tr></table></figure><p>这样也可以在一定程度上散列逐步put进来的数据。</p><p><strong>3.字符串拼接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20170524000001_a12e   20170524000001_93i7   </span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p>场景: 大量的运营商的通话数据<br>      1388888888(主叫) 13999999999(被叫) 2021-05-14 12:12:12  360 ……</p><p>业务: 查询某个用户 某天  某月  某年 的通话记录 </p><p>预分区: 预计规划50个分区 .</p><p>-∞  ~  00|<br>00| ~  01|<br>01| ~  02|<br>…….</p><p>分析:  假如将某个用户某天的数据存到一个分区中. 查某天的数据只需要扫描一个分区<br>           假如将某个用户某月的数据存到一个分区中. 查某天 某月的数据只需要扫描一个分区.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rowkey: 01_1388888888_2021-05-14 12:12:12  -&gt;  1388888888_2021-05 % 分区数  = 01</span><br><span class="line">01_1388888888_2021-05-15 12:12:12  -&gt;  1388888888_2021-05 % 分区数  = 01 </span><br><span class="line">01_1388888888_2021-05-16 12:12:12</span><br><span class="line">01_1388888888_2021-05-17 12:12:12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        03_1377777777_2021-05-16 12:12:12  -&gt;  1377777777_2021-05 % 分区数  = 03</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证:<br>查询  1388888888 用户 2020年08月的通话记录</p><ol><li>先计算分区号<br>1388888888_2020-08  % 50  &#x3D; 04 </li><li>rowkey<br>04_1388888888_2020-08-……..</li><li>scan<br>scan “teldata” ,{STARTROW&#x3D;&gt; ‘04_1388888888_2020-08’ STOPROW&#x3D;&gt; ‘04_1388888888_2020-08|’}</li></ol><p>查询  1388888888 用户 2020年08月08日的通话记录     </p><ol><li>先计算分区号<br>1388888888_2020-08  % 50  &#x3D; 04 </li><li>rowkey<br>04_1388888888_2020-08-08……..</li><li>scan<br>scan “teldata” ,{STARTROW&#x3D;&gt; ‘04_1388888888_2020-08-08’ STOPROW&#x3D;&gt; ‘04_1388888888_2020-08-08|’}</li></ol><p>查询  1388888888 用户 2020年08月 和 09月的通话记录 </p><ol><li>先计算分区号<br>1388888888_2020-08  % 50  &#x3D; 04<br>1388888888_2020-09  % 50  &#x3D; 06 </li><li>rowkey<br>04_1388888888_2020-08-……..<br>06_1388888888_2020-09-……..</li><li>scan<br>scan “teldata” ,{STARTROW&#x3D;&gt; ‘04_1388888888_2020-08’ STOPROW&#x3D;&gt; ‘04_1388888888_2020-08|’}<br>scan “teldata” ,{STARTROW&#x3D;&gt; ‘06_1388888888_2020-09’ STOPROW&#x3D;&gt; ‘06_1388888888_2020-09|’}</li></ol><p>查询  1388888888 用户 2020年08月09日 和 10日的通话记录      </p><ol><li>先计算分区号<br>1388888888_2020-08  % 50  &#x3D; 04 </li><li>rowkey<br>04_1388888888_2020-08-09……..<br>04_1388888888_2020-08-09……..<br>04_1388888888_2020-08-10……..</li><li>scan<br>scan “teldata” ,{STARTROW&#x3D;&gt; ‘04_1388888888_2020-08-09’ STOPROW&#x3D;&gt; ‘04_1388888888_2020-08-10|’}</li></ol><p><strong>上述例子中大量使用了字符串的拼接操作，比较巧妙</strong></p>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> RegionServer </tag>
            
            <tag> MemStore </tag>
            
            <tag> Store </tag>
            
            <tag> Region </tag>
            
            <tag> WAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka面试题总结</title>
      <link href="/2022/09/01/Kafka/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/09/01/Kafka/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kafka中的ISR、AR又代表什么？"><a href="#1-Kafka中的ISR、AR又代表什么？" class="headerlink" title="1. Kafka中的ISR、AR又代表什么？"></a>1. Kafka中的ISR、AR又代表什么？</h2><p>​    ISR：与leader保持同步的follower集合</p><p>​    AR：分区的所有副本</p><h2 id="2-Kafka中的HW、LEO等分别代表什么？"><a href="#2-Kafka中的HW、LEO等分别代表什么？" class="headerlink" title="2. Kafka中的HW、LEO等分别代表什么？"></a>2. Kafka中的HW、LEO等分别代表什么？</h2><p>​    LEO：没个副本的最后条消息的offset</p><p>​    HW：一个分区中所有副本最小的offset</p><h2 id="3-Kafka中是怎么体现消息顺序性的？"><a href="#3-Kafka中是怎么体现消息顺序性的？" class="headerlink" title="3. Kafka中是怎么体现消息顺序性的？"></a>3. Kafka中是怎么体现消息顺序性的？</h2><p>​    每个分区内，每条消息都有一个offset，故只能保证分区内有序。</p><h2 id="4-Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？"><a href="#4-Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？" class="headerlink" title="4. Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？"></a>4. Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？</h2><p>​    拦截器 -&gt; 序列化器 -&gt; 分区器</p><h2 id="5-Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？"><a href="#5-Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？" class="headerlink" title="5. Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？"></a>5. Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？</h2><p><img src="/2022/09/01/Kafka/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98/1662033221113.png" alt="1662033221113"></p><h2 id="6-“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？"><a href="#6-“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？" class="headerlink" title="6. “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？"></a>6. “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？</h2><p>​    正确</p><h2 id="7-消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1？"><a href="#7-消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1？" class="headerlink" title="7. 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？"></a>7. 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？</h2><p>​    offset+1</p><h2 id="8-有哪些情形会造成重复消费？"><a href="#8-有哪些情形会造成重复消费？" class="headerlink" title="8. 有哪些情形会造成重复消费？"></a>8. 有哪些情形会造成重复消费？</h2><p>​    <img src="/2022/09/01/Kafka/Kafka%E9%9D%A2%E8%AF%95%E9%A2%98/1662033238360.png" alt="1662033238360"></p><h2 id="9-那些情景会造成消息漏消费？"><a href="#9-那些情景会造成消息漏消费？" class="headerlink" title="9. 那些情景会造成消息漏消费？"></a>9. 那些情景会造成消息漏消费？</h2><p>​    先提交offset，后消费，有可能造成数据的重复</p><h2 id="10-当你使用kafka-topics-sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？"><a href="#10-当你使用kafka-topics-sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？" class="headerlink" title="10. 当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？"></a>10. 当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？</h2><p>​    1）会在zookeeper中的&#x2F;brokers&#x2F;topics节点下创建一个新的topic节点，如：&#x2F;brokers&#x2F;topics&#x2F;first</p><p>​    2）触发Controller的监听程序</p><p>​    3）kafka Controller 负责topic的创建工作，并更新metadata cache</p><h2 id="11-topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？"><a href="#11-topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？" class="headerlink" title="11. topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？"></a>11. topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？</h2><p>可以增加</p><p>bin&#x2F;kafka-topics.sh –zookeeper localhost:2181&#x2F;kafka –alter –topic topic-config –partitions 3</p><h2 id="12-topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？"><a href="#12-topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？" class="headerlink" title="12. topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？"></a>12. topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？</h2><p>​    不可以减少，现有的分区数据难以处理。</p><h2 id="13-Kafka有内部的topic吗？如果有是什么？有什么所用？"><a href="#13-Kafka有内部的topic吗？如果有是什么？有什么所用？" class="headerlink" title="13. Kafka有内部的topic吗？如果有是什么？有什么所用？"></a>13. Kafka有内部的topic吗？如果有是什么？有什么所用？</h2><p>​    __consumer_offsets,保存消费者offset</p><h2 id="14-Kafka分区分配的概念？"><a href="#14-Kafka分区分配的概念？" class="headerlink" title="14. Kafka分区分配的概念？"></a>14. Kafka分区分配的概念？</h2><p>​    一个topic多个分区，一个消费者组多个消费者，故需要将分区分配个消费者(roundrobin、range)</p><h2 id="15-简述Kafka的日志目录结构？"><a href="#15-简述Kafka的日志目录结构？" class="headerlink" title="15. 简述Kafka的日志目录结构？"></a>15. 简述Kafka的日志目录结构？</h2><p>​    每个分区对应一个文件夹，文件夹的命名为topic-0，topic-1，内部为.log和.index文件</p><h2 id="16-如果我指定了一个offset，Kafka-Controller怎么查找到对应的消息？"><a href="#16-如果我指定了一个offset，Kafka-Controller怎么查找到对应的消息？" class="headerlink" title="16. 如果我指定了一个offset，Kafka Controller怎么查找到对应的消息？"></a>16. 如果我指定了一个offset，Kafka Controller怎么查找到对应的消息？</h2><p>​       </p><h2 id="17-聊一聊Kafka-Controller的作用？"><a href="#17-聊一聊Kafka-Controller的作用？" class="headerlink" title="17. 聊一聊Kafka Controller的作用？"></a>17. 聊一聊Kafka Controller的作用？</h2><p>​    负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。</p><h2 id="18-Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"><a href="#18-Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？" class="headerlink" title="18. Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"></a>18. Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？</h2><p>​    partition leader（ISR），controller（先到先得）</p><h2 id="19-失效副本是指什么？有那些应对措施？"><a href="#19-失效副本是指什么？有那些应对措施？" class="headerlink" title="19. 失效副本是指什么？有那些应对措施？"></a>19. 失效副本是指什么？有那些应对措施？</h2><p>​    不能及时与leader同步，暂时踢出ISR，等其追上leader之后再重新加入</p><h2 id="20-Kafka的那些设计让它有如此高的性能？"><a href="#20-Kafka的那些设计让它有如此高的性能？" class="headerlink" title="20. Kafka的那些设计让它有如此高的性能？"></a>20. Kafka的那些设计让它有如此高的性能？</h2><p>​    分区，顺序写磁盘，0-copy</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> topic </tag>
            
            <tag> Kafka </tag>
            
            <tag> 分区 </tag>
            
            <tag> ISR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka概述</title>
      <link href="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kafka概述"><a href="#1-Kafka概述" class="headerlink" title="1. Kafka概述"></a>1. Kafka概述</h2><h3 id="1-1Kafka定义"><a href="#1-1Kafka定义" class="headerlink" title="1.1Kafka定义"></a>1.1Kafka定义</h3><p>​kafka是一个分布式的基于发布&#x2F;订阅模式的消息队列，主要应用于大数据实时处理领域</p><h3 id="1-2-消息队列"><a href="#1-2-消息队列" class="headerlink" title="1.2 消息队列"></a>1.2 消息队列</h3><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1661997559323.png" alt="1661997559323"></p><p><strong>使用消息队列的好处：</strong></p><p>1）解耦</p><p>​允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><p>2）可恢复性</p><p>​系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><p>3）缓冲</p><p>​有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p><p>4）灵活性 &amp; 峰值处理能力</p><p>​在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><p>5）异步通信</p><p>​很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h3 id="1-3-消息队列的两种模式"><a href="#1-3-消息队列的两种模式" class="headerlink" title="1.3 消息队列的两种模式"></a>1.3 消息队列的两种模式</h3><p><strong>（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</strong></p><p>​消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662019291856.png" alt="1662019291856"></p><p><strong>（2）发布&#x2F;订阅模式（一对多，消费者消费数据之后不会清除消息）</strong></p><p>​消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662019314571.png" alt="1662019314571"></p><h3 id="1-4-Kakfa基础架构"><a href="#1-4-Kakfa基础架构" class="headerlink" title="1.4 Kakfa基础架构"></a>1.4 Kakfa基础架构</h3><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662019514912.png" alt="1662019514912"></p><p><strong>1）Producer</strong> <strong>：</strong>消息生产者，就是向kafka broker发消息的客户端；</p><p><strong>2）Consumer</strong> <strong>：</strong>消息消费者，向kafka broker取消息的客户端；</p><p><strong>3）Consumer Group （CG）</strong>：<strong>消费者组，由多个consumer组成。</strong>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。<strong>所有的消费者都属于某个消费者组，即</strong>消费者组是逻辑上的一个订阅者。</p><p><strong>4）Broker</strong> <strong>：</strong>一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</p><p><strong>5）Topic</strong> <strong>：</strong>可以理解为一个队列，生产者和消费者面向的都是一个<strong>topic</strong>；</p><p><strong>6）Partition</strong>：<strong>为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，</strong>一个<strong>topic</strong>可以分为多个partition，每个partition是一个有序的队列；</p><p><strong>7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个</strong>leader<strong>和若干个</strong>follower。</p><p><strong>8）leader</strong>：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。</p><p><strong>9）follower</strong>：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。</p><h2 id="2-Kafka命令行操作"><a href="#2-Kafka命令行操作" class="headerlink" title="2. Kafka命令行操作"></a>2. Kafka命令行操作</h2><p><strong>1.启动Kafka集群</strong></p><p>首先需要启动Zookeeper集群，然后再启动Kakfa</p><p>单节点启动指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-server-start.sh -daemon config/server.properties</span><br><span class="line">[atguigu@hadoop103 kafka]$ bin/kafka-server-start.sh -daemon  config/server.properties</span><br><span class="line">[atguigu@hadoop104 kafka]$ bin/kafka-server-start.sh -daemon  config/server.properties</span><br></pre></td></tr></table></figure><p>单节点关闭指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-server-stop.sh stop</span><br><span class="line">[atguigu@hadoop103 kafka]$ bin/kafka-server-stop.sh stop</span><br><span class="line">[atguigu@hadoop104 kafka]$ bin/kafka-server-stop.sh stop</span><br></pre></td></tr></table></figure><p>群起脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then </span><br><span class="line">  echo &quot;Input Args Error.....&quot;</span><br><span class="line">  exit</span><br><span class="line">fi</span><br><span class="line">for i in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">  echo &quot;==================START $i KAFKA===================&quot;</span><br><span class="line">  ssh $i /opt/module/kafka_2.11-2.4.1/bin/kafka-server-start.sh -daemon /opt/module/kafka_2.11-2.4.1/config/server.properties</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">  echo &quot;==================STOP $i KAFKA===================&quot;</span><br><span class="line">  ssh $i /opt/module/kafka_2.11-2.4.1/bin/kafka-server-stop.sh stop</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line"> echo &quot;Input Args Error.....&quot;</span><br><span class="line"> exit</span><br><span class="line">;;  </span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>2.查看当前服务器所有topic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --list</span><br></pre></td></tr></table></figure><p><strong>3.创建topic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --create --replication-factor 3 --partitions 1 --topic first</span><br></pre></td></tr></table></figure><p>​选项说明：</p><p>​–topic 定义topic名</p><p>​–replication-factor  定义副本数</p><p>​–partitions  定义分区数</p><p><strong>4.发送消息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-producer.sh --broker-list hadoop102:9092 --topic first</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">hello world</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">atguigu  atguigu</span></span><br></pre></td></tr></table></figure><p><strong>5.消费消息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092 --topic first</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092 --from-beginning --topic first</span><br></pre></td></tr></table></figure><p>​–from-beginning：会把主题中现有的所有的数据都读取出来。</p><p><strong>6.查看某个topic的详情</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --describe –</span><br><span class="line">-topic first</span><br></pre></td></tr></table></figure><p><strong>7.修改分区数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-topics.sh --zookeeper hadoop102:2181 --alter –-</span><br><span class="line">topic first --partitions 6</span><br></pre></td></tr></table></figure><h2 id="3-Kafka工作流程以及文件存储机制"><a href="#3-Kafka工作流程以及文件存储机制" class="headerlink" title="3. Kafka工作流程以及文件存储机制"></a>3. Kafka工作流程以及文件存储机制</h2><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662020587465.png" alt="1662020587465"></p><p>​Kafka中的消息按照topic来分类，生产者生产消息，消费者消费消息，都是面向topic的</p><p>​topic是逻辑上的概念，而partition是物理上的概念，每一个partition都对应一个log文件，该log文件中存储的就是producer生产的数据。Producer生产的数据会被不断的追加到log文件的末端，而且每一条数据都会有个offset。消费者组中的每一个消费者，都会实时记录自己消费到了哪一个offset，用来实施回复，从上次的位置继续消费。</p><p>​在kafka0.9版本之前，offset的信息都是存放在zookeeper之中，之后的版本是存放在Kafka之中</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662021768846.png" alt="1662021768846"></p><p>​由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个partition分为多个segment。每个segment对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，first这个topic有三个分区，则其对应的文件夹为first-0,first-1,first-2。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure><p>​index和log文件以当前segment的第一条消息的offset命名。下图为index文件和log文件的结构示意图。</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662021987087.png" alt="1662021987087"></p><p>​“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。</p><h2 id="4-Kafka生产者"><a href="#4-Kafka生产者" class="headerlink" title="4. Kafka生产者"></a>4. Kafka生产者</h2><h3 id="4-1-分区策略"><a href="#4-1-分区策略" class="headerlink" title="4.1 分区策略"></a>4.1 分区策略</h3><p><strong>为什么要分区？</strong></p><p><a href="https://zhuanlan.zhihu.com/p/125159716">Kafka的topic为什么要分区 - 知乎 (zhihu.com)</a></p><ol><li><strong>可以提高并发性</strong>，这样可以以partition作为单位去读写，多个partition可以提升读写的性能（多个分区存在多个磁盘，可以成倍的增加系统的性能，在kafka中其实读写操作都是面向leader的，而kafka会把不同的分区分配给不同的机器当作leader，这样可以极大提高并发性 ） </li><li><strong>方便在集群中扩展</strong>，每一个partition可以通过调整以适应它所在的机器，而一个topic可以有多个partition组成，因此整个集群可以适应任意大小的数据，通俗的解释就是，如果一开始没有规划好，目前的机器已经存放不下生产的数据了，我们可以通过增加机器，在增加的机器上增加分区，这样就可以在集群中接着存放数据了，所以方便了集群中扩展</li></ol><p><strong>但这又产生了一个问题，既然我们有多个分区，那么生产者生产的数据该存放在哪一个分区上呢？</strong></p><p>我们需要把生产者发送的数据封装成一个producerRecord对象，该对象在java中有很多重载方法，主要有几下几种情况</p><p>（1）  指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</p><p>（2） 没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；</p><p>（3）  既没有 partition 值又没有 key 值的情况下， kafka采用Sticky Partition(黏性分区器)，会随机选择一个分区，并尽可能一直使用该分区，待该分区的batch已满或者已完成，kafka再随机一个分区进行使用.</p><h3 id="4-2-数据可靠性保证"><a href="#4-2-数据可靠性保证" class="headerlink" title="4.2 数据可靠性保证"></a>4.2 数据可靠性保证</h3><p>​为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662023547423.png" alt="1662023547423"></p><table><thead><tr><th><strong>方案</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>半数以上完成同步，就发送ack</strong></td><td>延迟低</td><td>选举新的leader时，容忍n台节点的故障，需要2n+1个副本</td></tr><tr><td><strong>全部完成同步，才发送ack</strong></td><td>选举新的leader时，容忍n台节点的故障，需要n+1个副本</td><td>延迟高</td></tr></tbody></table><p>Kafka选择了第二种方案，原因如下：</p><ol><li><p>同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。（<strong>通俗理解就是，如果采用第一种方式，如果集群有2n+1台节点，一旦超过n台节点故障，那么集群就不再可用，而第二种方案只需要n+1台节点就可以实现同让的容错能力，因此使用了第二种方案</strong>）</p></li><li><p>虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。</p></li></ol><hr><p>​采用第二种方案之后，设想以下情景：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p><p>​       <strong>Leader维护了一个动态的in-sync replica set (ISR)，意为和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给producer发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader发生故障之后，就会从ISR中选举新的leader。</strong></p><hr><p><strong>ack应答级别</strong></p><p>​对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接收成功。</p><p>​所以Kafka为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p><p><strong>acks参数配置：</strong></p><p><strong>acks</strong>：</p><p>0：这一操作提供了一个最低的延迟，partition的leader接收到消息还没有写入磁盘就已经返回ack，当leader故障时有可能<strong>丢失数据</strong>；</p><p>1： partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会<strong>丢失数据</strong>；</p><p>-1（all）： partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成<strong>数据重复</strong>。</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662024173426.png" alt="1662024173426"></p><hr><p><strong>leader和 follower故障处理细节</strong></p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662024671775.png" alt="1662024671775"></p><p><strong>LEO</strong>：指的是每个副本最大的offset;</p><p><strong>HW：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。</strong></p><p><strong>（1）follower故障</strong></p><p>follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该<strong>follower的LEO大于等于该Partition的HW</strong>，即follower追上leader之后，就可以重新加入ISR了。</p><p><strong>（2）leader故障</strong></p><p>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件<strong>高于HW</strong>的部分截掉，然后从新的leader同步数据。</p><p>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><h3 id="4-3-Exactly-Once语义"><a href="#4-3-Exactly-Once语义" class="headerlink" title="4.3 Exactly Once语义"></a>4.3 Exactly Once语义</h3><p>​将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即At Most Once语义。</p><p>​       At Least Once可以保证数据不丢失，但是不能保证数据不重复；相对的，At Most Once可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p><p>​0.11版本的Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。幂等性结合At Least Once语义，就构成了Kafka的Exactly Once语义。即：<strong>At Least Once +</strong> <strong>幂等性 &#x3D; Exactly Once</strong></p><p>​       要启用幂等性，只需要将Producer的参数中<strong>enable.idempotence</strong>设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p><p>​但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p><h2 id="5-Kafka消费者"><a href="#5-Kafka消费者" class="headerlink" title="5. Kafka消费者"></a>5. Kafka消费者</h2><p>​<strong>一个分区只能被一个消费者组中的一个消费者所消费</strong></p><h3 id="5-1-消费方式"><a href="#5-1-消费方式" class="headerlink" title="5.1 消费方式"></a>5.1 消费方式</h3><p>​<strong>consumer采用pull（拉）模式从broker中读取数据。</strong></p><p>​<strong>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的</strong>。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</p><p>​<strong>pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。</strong>针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</p><h3 id="5-2-分区分配策略"><a href="#5-2-分区分配策略" class="headerlink" title="5.2 分区分配策略"></a>5.2 分区分配策略</h3><p>​一个consumer group中有多个consumer，一个 topic有多个partition，所以必然会涉及到partition的分配问题，即确定那个partition由哪个consumer来消费。</p><p>​Kafka有三种分配策略，RoundRobin，Range , Sticky。</p><p><strong>1.RoundRobin</strong></p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662030059833.png" alt="1662030059833"></p><p>这种方式其实就是轮询分配，从第一个分区到最后一个分区，一个分配给一个消费者，从上到下。</p><p><strong>2.Range</strong> </p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662030016065.png" alt="1662030016065"></p><p>如果除的开，就平等分，把某一个范围内的给某一个消费者去消费，如果除不开，就是让前面的多点分区</p><p><strong>3.Sticky</strong></p><p>粘性分区，这个跟RoundRobin有点像，其实第一次分配都是一模一样，不同点在于当消费者数目增加或者减少的时候。RoundRobin会把所有的分区取回来，按照编号重新排列，然后重新分配给某一个消费者，而粘性分区会把原有消费者负责的分区不变，只把改变的分区再重新分配到消费者中去消费</p><h3 id="5-3-offset的维护"><a href="#5-3-offset的维护" class="headerlink" title="5.3 offset的维护"></a>5.3 offset的维护</h3><p>​由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</p><p>​Kafka 0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为**__consumer_offsets**。</p><p><strong>1.消费offset案例</strong></p><p><strong>修改配置文件consumer.properties</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不排除内部的topic</span></span><br><span class="line">exclude.internal.topics=false</span><br></pre></td></tr></table></figure><p><strong>创建一个topic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --topic atguigu --zookeeper hadoop102:2181 --partitions 2</span><br><span class="line"> --replication-factor 2</span><br></pre></td></tr></table></figure><p><strong>启动生产者和消费者，分别往atguigu生产数据和消费数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --topic atguigu --broker-list  hadoop102:9092</span><br><span class="line">bin/kafka-console-consumer.sh --consumer.config config/consumer.properties --topic atguigu --bootstrap-server hadoop102:9092</span><br></pre></td></tr></table></figure><p><strong>消费offset</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --topic __consumer_offsets --bootstrap-server  hadoop102:9092  --formatter &quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</span><br></pre></td></tr></table></figure><p><strong>消费到的数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[test-consumer-group,atguigu,1]::OffsetAndMetadata(offset=2, leaderEpoch=Optional[0],</span><br><span class="line"> metadata=, commitTimestamp=1591935656078, expireTimestamp=None)</span><br><span class="line">[test-consumer-group,atguigu,0]::OffsetAndMetadata(offset=1, leaderEpoch=Optional[0], metadata=, commitTimestamp=1591935656078, expireTimestamp=None)</span><br></pre></td></tr></table></figure><h2 id="6-Zookeeper在Kafka中的作用"><a href="#6-Zookeeper在Kafka中的作用" class="headerlink" title="6. Zookeeper在Kafka中的作用"></a>6. Zookeeper在Kafka中的作用</h2><p>​Kafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。</p><p>​Controller的管理工作都是依赖于Zookeeper的。</p><p>​       以下为partition的leader选举过程：</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662033484241.png" alt="1662033484241"></p><h2 id="7-Kafka事务（了解就好）"><a href="#7-Kafka事务（了解就好）" class="headerlink" title="7. Kafka事务（了解就好）"></a>7. Kafka事务（了解就好）</h2><p>​Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么&#96;全部成功，要么全部失败。</p><p><strong>Producer事务</strong></p><p>​为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</p><p>​为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator。Producer就是通过和Transaction Coordinator交互获得Transaction ID对应的任务状态。Transaction Coordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><p><strong>Consumer事务（精准一次性消费）</strong></p><p>​上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其时无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p><p>​如果想完成Consumer端的精准一次性消费，那么需要kafka消费端将消费过程和提交offset过程做原子绑定。此时我们需要将kafka的offset保存到支持事务的自定义介质（比如mysql）。这部分知识会在后续项目部分涉及。</p><h2 id="8-Producer-API"><a href="#8-Producer-API" class="headerlink" title="8. Producer API"></a>8. Producer API</h2><h3 id="8-1-消息发送流程"><a href="#8-1-消息发送流程" class="headerlink" title="8.1 消息发送流程"></a>8.1 消息发送流程</h3><p>​Kafka的Producer发送消息采用的是<strong>异步发送</strong>的方式。在消息发送的过程中，涉及到了<strong>两个线程——main线程和Sender线程</strong>，以及<strong>一个线程共享变量——RecordAccumulator</strong>。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662041925263.png" alt="1662041925263"></p><p><strong>相关参数：</strong></p><p><strong>batch.size：</strong>只有数据积累到batch.size之后，sender才会发送数据。</p><p><strong>linger.ms：</strong>如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。</p><h3 id="8-2-异步发送API"><a href="#8-2-异步发送API" class="headerlink" title="8.2 异步发送API"></a>8.2 异步发送API</h3><p><strong>导入依赖：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>需要用到的类：</p><p><strong>KafkaProducer</strong>：需要创建一个生产者对象，用来发送数据</p><p><strong>ProducerConfig</strong>：获取所需的一系列配置参数</p><p><strong>ProducerRecord</strong>：每条数据都要封装成一个ProducerRecord对象</p><p>（1）<strong>不带回调函数的API</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.producer.*;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line">public class CustomProducer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line"></span><br><span class="line">        //kafka集群，broker-list</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line"></span><br><span class="line">        //重试次数</span><br><span class="line">        props.put(&quot;retries&quot;, 1); </span><br><span class="line"></span><br><span class="line">        //批次大小</span><br><span class="line">        props.put(&quot;batch.size&quot;, 16384); </span><br><span class="line"></span><br><span class="line">        //等待时间</span><br><span class="line">        props.put(&quot;linger.ms&quot;, 1); </span><br><span class="line"></span><br><span class="line">        //RecordAccumulator缓冲区大小</span><br><span class="line">        props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）<strong>带回调函数的API</strong></p><p>​回调函数会在producer收到ack时调用，为异步调用，该方法有两个参数，分别是RecordMetadata和Exception，如果Exception为null，说明消息发送成功，如果Exception不为null，说明消息发送失败。</p><p>​注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.producer.*;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line">public class CustomProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Properties props = new Properties();</span><br><span class="line"></span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);//kafka集群，broker-list</span><br><span class="line"></span><br><span class="line">        props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;retries&quot;, 1);//重试次数</span><br><span class="line"></span><br><span class="line">        props.put(&quot;batch.size&quot;, 16384);//批次大小</span><br><span class="line"></span><br><span class="line">        props.put(&quot;linger.ms&quot;, 1);//等待时间</span><br><span class="line"></span><br><span class="line">        props.put(&quot;buffer.memory&quot;, 33554432);//RecordAccumulator缓冲区大小</span><br><span class="line"></span><br><span class="line">        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, Integer.toString(i), Integer.toString(i)), new Callback() &#123;</span><br><span class="line"></span><br><span class="line">                //回调函数，该方法会在Producer收到ack时调用，为异步调用</span><br><span class="line">                @Override</span><br><span class="line">                public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">                    if (exception == null) &#123;</span><br><span class="line">                        System.out.println(&quot;success-&gt;&quot; + metadata.offset());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        exception.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-3-分区器"><a href="#8-3-分区器" class="headerlink" title="8.3 分区器"></a>8.3 分区器</h3><p><strong>1）</strong>  默认的分区器 DefaultPartitioner</p><p><strong>2）</strong>  自定义分区器 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class MyPartitioner implements Partitioner &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 计算某条消息要发送到哪个分区</span><br><span class="line">     * @param topic 主题</span><br><span class="line">     * @param key   消息的key</span><br><span class="line">     * @param keyBytes 消息的key序列化后的字节数组</span><br><span class="line">     * @param value 消息的value</span><br><span class="line">     * @param valueBytes   消息的value序列化后的字节数组</span><br><span class="line">     * @param cluster</span><br><span class="line">     * @return</span><br><span class="line">     *</span><br><span class="line">     * 需求: 以atguigu主题为例，2个分区</span><br><span class="line">     *       消息的 value包含&quot;atguigu&quot;的 进入0号分区</span><br><span class="line">     *       其他的消息进入1号分区</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</span><br><span class="line">        String msgValue = value.toString();</span><br><span class="line">        int partition ;</span><br><span class="line">        if(msgValue.contains(&quot;atguigu&quot;))&#123;</span><br><span class="line">            partition = 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            partition = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 收尾工作</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 读取配置的</span><br><span class="line">     * @param configs</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-4-同步发送API"><a href="#8-4-同步发送API" class="headerlink" title="8.4 同步发送API"></a>8.4 同步发送API</h3><p>​        同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回ack。</p><p>​由于send方法返回的是一个Future对象，根据Futrue对象的特点，我们也可以实现同步发送的效果，只需在调用Future对象的get方发即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.Producer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line">public class CustomProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Properties props = new Properties();</span><br><span class="line"></span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);//kafka集群，broker-list</span><br><span class="line"></span><br><span class="line">        props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;retries&quot;, 1);//重试次数</span><br><span class="line"></span><br><span class="line">        props.put(&quot;batch.size&quot;, 16384);//批次大小</span><br><span class="line"></span><br><span class="line">        props.put(&quot;linger.ms&quot;, 1);//等待时间</span><br><span class="line"></span><br><span class="line">        props.put(&quot;buffer.memory&quot;, 33554432);//RecordAccumulator缓冲区大小</span><br><span class="line"></span><br><span class="line">        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, Integer.toString(i), Integer.toString(i))).get();</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-Consumer-API"><a href="#9-Consumer-API" class="headerlink" title="9. Consumer API"></a>9. Consumer API</h2><p>​Consumer消费数据时的可靠性是很容易保证的，因为数据在Kafka中是持久化的，故不用担心数据丢失问题。</p><p>​由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。所以offset的维护是Consumer消费数据是必须考虑的问题。</p><h3 id="9-1-自动提交offset"><a href="#9-1-自动提交offset" class="headerlink" title="9.1 自动提交offset"></a>9.1 自动提交offset</h3><p>需要用到的类：</p><p><strong>KafkaConsumer</strong>：需要创建一个消费者对象，用来消费数据</p><p><strong>ConsumerConfig</strong>：获取所需的一系列配置参数</p><p><strong>ConsuemrRecord</strong>：每条数据都要封装成一个ConsumerRecord对象</p><p>为了使我们能够专注于自己的业务逻辑，Kafka提供了自动提交offset的功能。 </p><p>自动提交offset的相关参数：</p><p><strong>enable.auto.commit：</strong>是否开启自动提交offset功能</p><p><strong>auto.commit.interval.ms：</strong>自动提交offset的时间间隔</p><p><strong>消费者自动提交offset</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line">import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class CustomConsumer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Properties props = new Properties();</span><br><span class="line"></span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;group.id&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(Arrays.asList(&quot;first&quot;));</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);</span><br><span class="line"></span><br><span class="line">            for (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line"></span><br><span class="line">                System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-重置offset"><a href="#9-2-重置offset" class="headerlink" title="9.2 重置offset"></a>9.2 重置offset</h3><p>auto.offset.rest &#x3D; earliest | latest | none |</p><h3 id="9-3-手动提交offset"><a href="#9-3-手动提交offset" class="headerlink" title="9.3 手动提交offset"></a>9.3 手动提交offset</h3><p>​虽然自动提交offset十分简介便利，但由于其是基于时间提交的，开发人员难以把握offset提交的时机。因此Kafka还提供了手动提交offset的API。</p><p>​手动提交offset的方法有两种：分别是commitSync（同步提交）和commitAsync（异步提交）。两者的相同点是，都会将<strong>本次poll的一批数据最高的偏移量提交</strong>；不同点是，commitSync阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而commitAsync则没有失败重试机制，故有可能提交失败。</p><p><strong>1）同步提交offset</strong></p><p>​由于同步提交offset有失败重试机制，故更加可靠，以下为同步提交offset的示例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.consumer;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line">import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class CustomComsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Properties props = new Properties();</span><br><span class="line"></span><br><span class="line">//Kafka集群</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;); </span><br><span class="line"></span><br><span class="line">//消费者组，只要group.id相同，就属于同一个消费者组</span><br><span class="line">        props.put(&quot;group.id&quot;, &quot;test&quot;); </span><br><span class="line"></span><br><span class="line">        props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);//关闭自动提交offset</span><br><span class="line"></span><br><span class="line">        props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(Arrays.asList(&quot;first&quot;));//消费者订阅主题</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">//消费者拉取数据</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); </span><br><span class="line"></span><br><span class="line">            for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, record.offset(), record.key(), record.value());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">//同步提交，当前线程会阻塞直到offset提交成功</span><br><span class="line">            consumer.commitSync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）异步提交offset</strong></p><p>​虽然同步提交offset更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。因此更多的情况下，会选用异步提交offset的方式。</p><p>​以下为异步提交offset的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.consumer;</span><br><span class="line"></span><br><span class="line">import org.apache.kafka.clients.consumer.*;</span><br><span class="line">import org.apache.kafka.common.TopicPartition;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CustomConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Properties props = new Properties();</span><br><span class="line"></span><br><span class="line">        //Kafka集群</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;); </span><br><span class="line"></span><br><span class="line">        //消费者组，只要group.id相同，就属于同一个消费者组</span><br><span class="line">        props.put(&quot;group.id&quot;, &quot;test&quot;); </span><br><span class="line"></span><br><span class="line">        //关闭自动提交offset</span><br><span class="line">        props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);</span><br><span class="line"></span><br><span class="line">        props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(&quot;first&quot;));//消费者订阅主题</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);//消费者拉取数据</span><br><span class="line">            for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">//异步提交</span><br><span class="line">            consumer.commitAsync(new OffsetCommitCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception) &#123;</span><br><span class="line">                    if (exception != null) &#123;</span><br><span class="line">                        System.err.println(&quot;Commit failed for&quot; + offsets);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）</strong>  <strong>数据漏消费和重复消费分析</strong></p><p>​无论是同步提交还是异步提交offset，都有可能会造成数据的漏消费或者重复消费。先提交offset后消费，有可能造成数据的漏消费；而先消费后提交offset，有可能会造成数据的重复消费。</p><h2 id="10-自定义拦截器"><a href="#10-自定义拦截器" class="headerlink" title="10. 自定义拦截器"></a>10. 自定义拦截器</h2><h3 id="10-1-拦截器原理"><a href="#10-1-拦截器原理" class="headerlink" title="10.1 拦截器原理"></a>10.1 拦截器原理</h3><p>​Producer拦截器(interceptor)是在Kafka 0.10版本被引入的，主要用于实现clients端的定制化控制逻辑。</p><p>​对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：</p><p>（1）configure(configs)</p><p>​获取配置信息和初始化数据时调用。</p><p>（2）onSend(ProducerRecord)：</p><p>​该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算。</p><p>（3）onAcknowledgement(RecordMetadata, Exception)：</p><p>​该方法会在消息从RecordAccumulator成功发送到Kafka Broker之后，或者在发送过程中失败时调用。并且通常都是在producer回调逻辑触发之前。onAcknowledgement运行在producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率。</p><p>（4）close：</p><p>​关闭interceptor，主要用于执行一些资源清理工作</p><p>​如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceptor，则producer将按照指定顺序调用它们，并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。</p><h3 id="10-2-拦截器案例"><a href="#10-2-拦截器案例" class="headerlink" title="10.2 拦截器案例"></a>10.2 拦截器案例</h3><p><strong>需求：</strong></p><p>​实现一个简单的双interceptor组成的拦截链。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部；第二个interceptor会在消息发送后更新成功发送消息数或失败发送消息数。</p><p><strong>案例实操</strong></p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662042928444.png" alt="1662042928444"></p><p>（1）增加时间戳拦截器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.interceptor;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line">import org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line">public class TimeInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123;</span><br><span class="line"></span><br><span class="line">// 创建一个新的record，把时间戳写入消息体的最前部</span><br><span class="line">return new ProducerRecord(record.topic(), record.partition(), record.timestamp(), record.key(),</span><br><span class="line">System.currentTimeMillis() + &quot;,&quot; + record.value().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）统计发送消息成功和发送失败消息数，并在producer关闭时打印这两个计数器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.interceptor;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line">import org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line">public class CounterInterceptor implements ProducerInterceptor&lt;String, String&gt;&#123;</span><br><span class="line">    private int errorCounter = 0;</span><br><span class="line">    private int successCounter = 0;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123;</span><br><span class="line"> return record;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">// 统计成功和失败的次数</span><br><span class="line">        if (exception == null) &#123;</span><br><span class="line">            successCounter++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            errorCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line">        // 保存结果</span><br><span class="line">        System.out.println(&quot;Successful sent: &quot; + successCounter);</span><br><span class="line">        System.out.println(&quot;Failed sent: &quot; + errorCounter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）producer主程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.interceptor;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.Producer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line">public class InterceptorProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 1 设置配置信息</span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);</span><br><span class="line">props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line">props.put(&quot;retries&quot;, 3);</span><br><span class="line">props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">// 2 构建拦截链</span><br><span class="line">List&lt;String&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">interceptors.add(&quot;com.atguigu.kafka.interceptor.TimeInterceptor&quot;); interceptors.add(&quot;com.atguigu.kafka.interceptor.CounterInterceptor&quot;); </span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line"> </span><br><span class="line">String topic = &quot;first&quot;;</span><br><span class="line">Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">// 3 发送消息</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(topic, &quot;message&quot; + i);</span><br><span class="line">    producer.send(record);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 4 一定要关闭producer，这样才会调用interceptor的close方法</span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>在kafka上启动消费者，然后运行客户端java程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092 --from-beginning --topic first</span><br><span class="line"></span><br><span class="line">1501904047034,message0</span><br><span class="line">1501904047225,message1</span><br><span class="line">1501904047230,message2</span><br><span class="line">1501904047234,message3</span><br><span class="line">1501904047236,message4</span><br><span class="line">1501904047240,message5</span><br><span class="line">1501904047243,message6</span><br><span class="line">1501904047246,message7</span><br><span class="line">1501904047249,message8</span><br><span class="line">1501904047252,message9</span><br></pre></td></tr></table></figure><h2 id="11-Flume-和-Kafka的对接"><a href="#11-Flume-和-Kafka的对接" class="headerlink" title="11.Flume 和 Kafka的对接"></a>11.Flume 和 Kafka的对接</h2><ol><li><p>KafkaSource<br> 用于从kafka中读取数据.KafkaSource对于flume来讲是一个source的角色. 对于Kafka来讲，是一个消费者的角色.</p></li><li><p>KafkaSink<br> 用于往Kafka中写数据KafkaSink对于flume来讲是一个sink的角色,对于kafka来讲，是一个生产者的角色. </p></li><li><p>KafkaChannel<br>① 作为一个基本的channel来使用.<br>   xxxSource -&gt; KafkaChannel -&gt; xxxSink</p></li></ol><p>​    ② 支持往kafka中写入数据<br>​       xxxSource -&gt; KafkaChannel </p><p>​    ③ 支持从Kafka中读取数据</p><p>​kafkaChannel -&gt; xxxSink  </p><p><strong>1.Flume-&gt; Kafka:KafkaSink</strong></p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662043816100.png" alt="1662043816100"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Named</span></span><br><span class="line">a1.sources = r1 </span><br><span class="line">a1.channels = c1 </span><br><span class="line">a1.sinks = k1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line">a1.sources.r1.port = 6666 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Channel</span> </span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 10000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Sink</span></span><br><span class="line">a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">a1.sinks.k1.kafka.bootstrap.servers = hadoop102:9092,hadoop103:9092,hadoop104:9092</span><br><span class="line">a1.sinks.k1.kafka.topic = flumetopic</span><br><span class="line">a1.sinks.k1.kafka.flumeBatchSize = 100</span><br><span class="line">a1.sinks.k1.useFlumeEventFormat = true</span><br><span class="line">a1.sinks.k1.kafka.producer.acks = -1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Bind</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flume-ng agent -c $FLUME_HOME/conf -f $FLUME_HOME/jobs/kafka/netcat-flume-kafka.conf -n a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p><strong>2.Flume-&gt;Kafka : KafkaSink</strong></p><p>需求如下图，按照已有知识分析思路如下图</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662044250870.png" alt="1662044250870"></p><p>简化方法如下（可以通过Kafka的一个功能实现简化操作）：</p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662044394191.png" alt="1662044394191"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Named</span></span><br><span class="line">a1.sources = r1 </span><br><span class="line">a1.channels = c1 </span><br><span class="line">a1.sinks = k1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line">a1.sources.r1.port = 6666 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Channel</span> </span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 10000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Interceptor</span></span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line">a1.sources.r1.interceptors.i1.type = com.atguigu.kafka.flumeinterceptor.DataValueInterceptor$MyBuilder</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Sink</span></span><br><span class="line">a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">a1.sinks.k1.kafka.bootstrap.servers = hadoop102:9092,hadoop103:9092,hadoop104:9092</span><br><span class="line">a1.sinks.k1.kafka.topic = topicother</span><br><span class="line">a1.sinks.k1.kafka.flumeBatchSize = 100</span><br><span class="line">a1.sinks.k1.useFlumeEventFormat = true</span><br><span class="line">a1.sinks.k1.kafka.producer.acks = -1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Bind</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p><strong>3.Kafka-&gt;Flume : Kafka Source</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">kafka-flume-logger.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Named</span></span><br><span class="line">a1.sources = r1 </span><br><span class="line">a1.channels = c1 </span><br><span class="line">a1.sinks = k1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Source</span></span><br><span class="line">a1.sources.r1.type = org.apache.flume.source.kafka.KafkaSource</span><br><span class="line">a1.sources.r1.kafka.bootstrap.servers = hadoop102:9092,hadoop103:9092</span><br><span class="line">a1.sources.r1.kafka.topics = first</span><br><span class="line">a1.sources.r1.kafka.consumer.group.id = flume</span><br><span class="line">a1.sources.r1.batchSize = 100</span><br><span class="line">a1.sources.r1.useFlumeEventFormat = false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Channel</span> </span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 10000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Bind</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p><strong>4. KafkaChannel -&gt; xxxSink</strong></p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662045060028.png" alt="1662045060028"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kafkachannel-flume-logger.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Named</span></span><br><span class="line">a1.channels = c1 </span><br><span class="line">a1.sinks = k1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Source</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Channel</span> </span><br><span class="line">a1.channels.c1.type = org.apache.flume.channel.kafka.KafkaChannel</span><br><span class="line">a1.channels.c1.kafka.bootstrap.servers = hadoop102:9092,hadoop103:9092,hadoop104:9092</span><br><span class="line">a1.channels.c1.kafka.topic = first </span><br><span class="line">a1.channels.c1.kafka.consumer.group.id = flume</span><br><span class="line">a1.channels.c1.kafka.consumer.auto.offset.reset = latest</span><br><span class="line">a1.channels.c1.parseAsFlumeEvent = false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Bind</span></span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p><strong>5.xxxSource -&gt; KafkaChannel</strong> </p><p><img src="/2022/09/01/Kafka/kafka%E6%A6%82%E8%BF%B0/1662045206789.png" alt="1662045206789"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Named</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line">a1.sources.r1.port = 6666 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Channel</span> </span><br><span class="line">a1.channels.c1.type = org.apache.flume.channel.kafka.KafkaChannel</span><br><span class="line">a1.channels.c1.kafka.bootstrap.servers = hadoop102:9092,hadoop103:9092,hadoop104:9092</span><br><span class="line">a1.channels.c1.kafka.topic = first </span><br><span class="line">a1.channels.c1.parseAsFlumeEvent = false</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Sink</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Bind</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LEO </tag>
            
            <tag> HW </tag>
            
            <tag> offset </tag>
            
            <tag> 拦截器 </tag>
            
            <tag> 分区策略 </tag>
            
            <tag> 粘性分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flume面试题总结</title>
      <link href="/2022/08/31/Flume/flume%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/08/31/Flume/flume%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-你是如何实现Flume数据传输的监控的"><a href="#1-你是如何实现Flume数据传输的监控的" class="headerlink" title="1.你是如何实现Flume数据传输的监控的"></a>1.你是如何实现Flume数据传输的监控的</h2><p>​使用第三方框架Ganglia实时监控Flume。</p><h2 id="2-Flume的Source，Sink，Channel的作用？你们Source是什么类型？"><a href="#2-Flume的Source，Sink，Channel的作用？你们Source是什么类型？" class="headerlink" title="2. Flume的Source，Sink，Channel的作用？你们Source是什么类型？"></a>2. Flume的Source，Sink，Channel的作用？你们Source是什么类型？</h2><p><strong>1）作用</strong></p><p>（1）Source组件是专门用来收集数据的，可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、sequence generator、syslog、http、legacy</p><p>（2）Channel组件对采集到的数据进行缓存，可以存放在Memory或File中。</p><p>（3）Sink组件是用于把数据发送到目的地的组件，目的地包括Hdfs、Logger、avro、thrift、ipc、file、Hbase、solr、自定义。</p><p><strong>2）我公司采用的Source类型为：</strong></p><p>（1）监控后台日志：exec</p><p>（2）监控后台产生日志的端口：netcat</p><h2 id="3-Flume的Channel-Selectors"><a href="#3-Flume的Channel-Selectors" class="headerlink" title="3. Flume的Channel Selectors"></a>3. Flume的Channel Selectors</h2><p><img src="/2022/08/31/Flume/flume%E9%9D%A2%E8%AF%95%E9%A2%98/1661961515838.png" alt="1661961515838"></p><h2 id="4-Flume参数调优"><a href="#4-Flume参数调优" class="headerlink" title="4. Flume参数调优"></a>4. Flume参数调优</h2><p><strong>1）Source</strong></p><p>​增加Source个（使用Tair Dir Source时可增加FileGroups个数）可以增大Source的读取数据的能力。例如：当某一个目录产生的文件过多时需要将这个文件目录拆分成多个文件目录，同时配置好多个Source 以保证Source有足够的能力获取到新产生的数据。</p><p>​batchSize参数决定Source一次批量运输到Channel的event条数，适当调大这个参数可以提高Source搬运Event到Channel时的性能。</p><p><strong>2）Channel</strong> </p><p>​type 选择memory时Channel的性能最好，但是如果Flume进程意外挂掉可能会丢失数据。type选择file时Channel的容错性更好，但是性能上会比memory channel差。</p><p>​使用file Channel时dataDirs配置多个不同盘下的目录可以提高性能。</p><p>​Capacity 参数决定Channel可容纳最大的event条数。transactionCapacity 参数决定每次Source往channel里面写的最大event条数和每次Sink从channel里面读的最大event条数。<strong>transactionCapacity需要大于Source和Sink的batchSize参数。</strong></p><p><strong>3）Sink</strong> </p><p>​增加Sink的个数可以增加Sink消费event的能力。Sink也不是越多越好够用就行，过多的Sink会占用系统资源，造成系统资源不必要的浪费。</p><p>​batchSize参数决定Sink一次批量从Channel读取的event条数，适当调大这个参数可以提高Sink从Channel搬出event的性能。</p><h2 id="5-Flume的事务机制"><a href="#5-Flume的事务机制" class="headerlink" title="5. Flume的事务机制"></a>5. Flume的事务机制</h2><p>​Flume的事务机制（类似数据库的事务机制）：Flume使用两个独立的事务分别负责从Soucrce到Channel，以及从Channel到Sink的事件传递。比如spooling directory source 为文件的每一行创建一个事件，一旦事务中所有的事件全部传递到Channel且提交成功，那么Soucrce就将该文件标记为完成。同理，事务以类似的方式处理从Channel到Sink的传递过程，如果因为某种原因使得事件无法记录，那么事务将会回滚。且所有的事件都会保持到Channel中，等待重新传递。</p><h2 id="6-Flume采集数据会丢失吗"><a href="#6-Flume采集数据会丢失吗" class="headerlink" title="6. Flume采集数据会丢失吗?"></a>6. Flume采集数据会丢失吗?</h2><p>​根据Flume的架构原理，Flume是不可能丢失数据的，其内部有完善的事务机制，Source到Channel是事务性的，Channel到Sink是事务性的，因此这两个环节不会出现数据的丢失，唯一可能丢失数据的情况是Channel采用memoryChannel，agent宕机导致数据丢失，或者Channel存储数据已满，导致Source不再写入，未写入的数据丢失。</p><p>​Flume不会丢失数据，但是有可能造成数据的重复，例如数据已经成功由Sink发出，但是没有接收到响应，Sink会再次发送数据，此时可能会导致数据的重复。</p>]]></content>
      
      
      <categories>
          
          <category> Flume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flume参数调优 </tag>
            
            <tag> 丢失数据 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flume概述</title>
      <link href="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Flume概述"><a href="#1-Flume概述" class="headerlink" title="1.Flume概述"></a>1.Flume概述</h2><h3 id="1-1-Flume的定义"><a href="#1-1-Flume的定义" class="headerlink" title="1.1 Flume的定义"></a>1.1 Flume的定义</h3><p>​Flume是Cloudera提供的一个高可用的、高可靠的、分布式的海量日志采集、聚合和传输的系统。Flume基于流式架构，灵活简单。</p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661944866185.png" alt="1661944866185"></p><p>Flume最主要的作用就是，实时读取服务器本地资源的数据，然后把本地数据写入到HDFS中。</p><h3 id="1-2-Flume基础架构"><a href="#1-2-Flume基础架构" class="headerlink" title="1.2 Flume基础架构"></a>1.2 Flume基础架构</h3><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661944962011.png" alt="1661944962011"></p><p><strong>Agent</strong></p><p>​Agent是一个JVM进程，它以事件的形式将数据从源头送至目的。</p><p>​Agent主要有3个部分组成，Source、Channel、Sink。</p><p><strong>Source</strong></p><p>​Source是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型、各种格式的日志数据，包括avro、thrift、exec、jms、spooling directory、netcat、taildir 、sequence generator、syslog、http、legacy。</p><p><strong>Sink</strong></p><p>​Sink不断地轮询Channel中的事件且批量地移除它们，并将这些事件批量写入到存储或索引系统、或者被发送到另一个Flume Agent。</p><p>​Sink组件目的地包括hdfs、logger、avro、thrift、ipc、file、HBase、solr、自定义。</p><p><strong>Channel</strong></p><p>​Channel是位于Source和Sink之间的缓冲区。因此，Channel允许Source和Sink运作在不同的速率上。Channel是线程安全的，可以同时处理几个Source的写入操作和几个Sink的读取操作。</p><p>​Flume自带两种Channel：Memory Channel和File Channel。</p><p>​Memory Channel是内存中的队列。Memory Channel在不需要关心数据丢失的情景下适用。如果需要关心数据丢失，那么Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失。</p><p>​File Channel将所有事件写到磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据。</p><p><strong>Event</strong></p><p>​传输单元，Flume数据传输的基本单元，以Event的形式将数据从源头送至目的地。Event由<strong>Header</strong>和<strong>Body</strong>两部分组成，Header用来存放该event的一些属性，为K-V结构，Body用来存放该条数据，形式为字节数组。</p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661945150542.png" alt="1661945150542"></p><h2 id="2-Flume入门案例"><a href="#2-Flume入门案例" class="headerlink" title="2.Flume入门案例"></a>2.Flume入门案例</h2><h3 id="2-1-监控端口数据官方案例"><a href="#2-1-监控端口数据官方案例" class="headerlink" title="2.1 监控端口数据官方案例"></a>2.1 监控端口数据官方案例</h3><p><strong>需求：</strong></p><p>​使用Flume监听一个端口，收集该端口数据，并打印到控制台。</p><p><strong>需求分析：</strong></p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661945291534.png" alt="1661945291534"></p><ol><li>通过netcat工具向本主机的某一个端口发送数据</li><li>Flume监控本机的该端口，通过Flume的source端来读取数据</li><li>Flume把获取的数据通过Sink端写出到控制台</li></ol><p><strong>实现步骤：</strong></p><p>​创建Flume Agent配置文件 flume-netcat-logger.conf（名字可以随便取，但是一般按照sink、channel、source的类型来命名，比较好辨认）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">添加内容如下：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent   a1表示agent的名称</span></span><br><span class="line">a1.sources = r1      r1：表示a1的Source的名称</span><br><span class="line">a1.sinks = k1        k1：表示a1的Sink的名称</span><br><span class="line">a1.channels = c1     c1：表示a1的Channel的名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat          表示source的类型</span><br><span class="line">a1.sources.r1.bind = localhost       表示source监听的主机</span><br><span class="line">a1.sources.r1.port = 44444           表示source监听的端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger             表示sink的类型</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory               表示channel的类型</span><br><span class="line">a1.channels.c1.capacity = 1000             表示channel的总容量式1000个event</span><br><span class="line">a1.channels.c1.transactionCapacity = 100   表示channel传输的时候每收集到100个event再去提交事务</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1                表示把r1和c1连接起来</span><br><span class="line">a1.sinks.k1.channel = c1                   表示把k1和c1连接起来</span><br></pre></td></tr></table></figure><p><strong>开启flume监听端口</strong></p><p>第一种写法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a1 --conf-file job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p>第二种写法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent -c conf/ -n a1 -f job/flume-netcat-logger.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>​       –conf&#x2F;-c：表示配置文件存储在conf&#x2F;目录</p><p>​       –name&#x2F;-n：表示给agent起名为a1</p><p>​       –conf-file&#x2F;-f：flume本次启动读取的配置文件是在job文件夹下的flume-telnet.conf文件。</p><p>​       -Dflume.root.logger&#x3D;INFO,console ：-D表示flume运行时动态修改flume.root.logger参数属性值，并将控制台日志打印级别设置为INFO级别。日志级别包括:log、info、warn、error。console代表的意思式打印到控制台</p><p><strong>使用netcat工具向本机的4444端口发送内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ nc localhost 44444</span><br><span class="line">hello </span><br><span class="line">atguigu</span><br></pre></td></tr></table></figure><h3 id="2-2-实施监控单个追加文件"><a href="#2-2-实施监控单个追加文件" class="headerlink" title="2.2 实施监控单个追加文件"></a>2.2 实施监控单个追加文件</h3><p><strong>案例需求：</strong></p><p>​实时监控Hive日志，并上传到HDFS中</p><p><strong>需求分析：</strong></p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661946573036.png" alt="1661946573036"></p><p><strong>实现步骤：</strong></p><p>编写flume配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a2.sources = r2</span><br><span class="line">a2.sinks = k2</span><br><span class="line">a2.channels = c2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a2.sources.r2.type = exec</span><br><span class="line">a2.sources.r2.command = tail -F /opt/module/hive/logs/hive.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a2.sinks.k2.type = hdfs</span><br><span class="line">a2.sinks.k2.hdfs.path = hdfs://hadoop102:8020/flume/%Y%m%d/%H</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上传文件的前缀</span></span><br><span class="line">a2.sinks.k2.hdfs.filePrefix = logs-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否按照时间滚动文件夹</span></span><br><span class="line">a2.sinks.k2.hdfs.round = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多少时间单位创建一个新的文件夹</span></span><br><span class="line">a2.sinks.k2.hdfs.roundValue = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新定义时间单位</span></span><br><span class="line">a2.sinks.k2.hdfs.roundUnit = hour</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否使用本地时间戳</span></span><br><span class="line">a2.sinks.k2.hdfs.useLocalTimeStamp = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">积攒多少个Event才flush到HDFS一次</span></span><br><span class="line">a2.sinks.k2.hdfs.batchSize = 100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置文件类型，可支持压缩</span></span><br><span class="line">a2.sinks.k2.hdfs.fileType = DataStream</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多久生成一个新的文件</span></span><br><span class="line">a2.sinks.k2.hdfs.rollInterval = 60</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置每个文件的滚动大小</span></span><br><span class="line">a2.sinks.k2.hdfs.rollSize = 134217700</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件的滚动与Event数量无关</span></span><br><span class="line">a2.sinks.k2.hdfs.rollCount = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a2.channels.c2.type = memory</span><br><span class="line">a2.channels.c2.capacity = 1000</span><br><span class="line">a2.channels.c2.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a2.sources.r2.channels = c2</span><br><span class="line">a2.sinks.k2.channel = c2</span><br></pre></td></tr></table></figure><p>​对于所有与时间相关的转义序列，Event Header中必须存在以 “timestamp”的key（除非hdfs.useLocalTimeStamp设置为true，此方法会使用TimestampInterceptor自动添加timestamp）。</p><p>​a3.sinks.k3.hdfs.useLocalTimeStamp &#x3D; true</p><p><strong>运行flume:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a2 --conf-file job/flume-file-hdfs.conf</span><br></pre></td></tr></table></figure><h3 id="2-3-实时监控目录下多个新文件"><a href="#2-3-实时监控目录下多个新文件" class="headerlink" title="2.3 实时监控目录下多个新文件"></a>2.3 实时监控目录下多个新文件</h3><p><strong>案例需求：</strong></p><p>​使用Flume监听整个目录的文件，并且上传到HDFS</p><p><strong>需求分析：</strong></p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661951520500.png" alt="1661951520500"></p><p><strong>实现步骤：</strong></p><p>编写配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">a3.sources = r3</span><br><span class="line">a3.sinks = k3</span><br><span class="line">a3.channels = c3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a3.sources.r3.type = spooldir</span><br><span class="line">a3.sources.r3.spoolDir = /opt/module/flume/upload</span><br><span class="line">a3.sources.r3.fileSuffix = .COMPLETED</span><br><span class="line">a3.sources.r3.fileHeader = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">忽略所有以.tmp结尾的文件，不上传</span></span><br><span class="line">a3.sources.r3.ignorePattern = ([^ ]*\.tmp)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a3.sinks.k3.type = hdfs</span><br><span class="line">a3.sinks.k3.hdfs.path = hdfs://hadoop102:8020/flume/upload/%Y%m%d/%H</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上传文件的前缀</span></span><br><span class="line">a3.sinks.k3.hdfs.filePrefix = upload-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否按照时间滚动文件夹</span></span><br><span class="line">a3.sinks.k3.hdfs.round = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多少时间单位创建一个新的文件夹</span></span><br><span class="line">a3.sinks.k3.hdfs.roundValue = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新定义时间单位</span></span><br><span class="line">a3.sinks.k3.hdfs.roundUnit = hour</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否使用本地时间戳</span></span><br><span class="line">a3.sinks.k3.hdfs.useLocalTimeStamp = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">积攒多少个Event才flush到HDFS一次</span></span><br><span class="line">a3.sinks.k3.hdfs.batchSize = 100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置文件类型，可支持压缩</span></span><br><span class="line">a3.sinks.k3.hdfs.fileType = DataStream</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多久生成一个新的文件</span></span><br><span class="line">a3.sinks.k3.hdfs.rollInterval = 60</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置每个文件的滚动大小大概是128M</span></span><br><span class="line">a3.sinks.k3.hdfs.rollSize = 134217700</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件的滚动与Event数量无关</span></span><br><span class="line">a3.sinks.k3.hdfs.rollCount = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a3.channels.c3.type = memory</span><br><span class="line">a3.channels.c3.capacity = 1000</span><br><span class="line">a3.channels.c3.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a3.sources.r3.channels = c3</span><br><span class="line">a3.sinks.k3.channel = c3</span><br></pre></td></tr></table></figure><h3 id="2-4-实时监控目录下的多个追加文件"><a href="#2-4-实时监控目录下的多个追加文件" class="headerlink" title="2.4 实时监控目录下的多个追加文件"></a>2.4 实时监控目录下的多个追加文件</h3><p>​Exec source适用于监控一个实时追加的文件，不能实现断点续传；Spooldir Source适合用于同步新文件，但不适合对实时追加日志的文件进行监听并同步；而Taildir Source适合用于监听多个实时追加的文件，并且能够实现断点续传。</p><p><strong>案例需求：</strong></p><p>​使用Flume监听整个目录的实时追加文件，并上传至HDFS</p><p><strong>案例分析：</strong></p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661951688179.png" alt="1661951688179"></p><p><strong>案例实操：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">a3.sources = r3</span><br><span class="line">a3.sinks = k3</span><br><span class="line">a3.channels = c3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a3.sources.r3.type = TAILDIR</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定position文件的位置</span></span><br><span class="line">a3.sources.r3.positionFile = /opt/module/flume/tail_dir.json</span><br><span class="line">a3.sources.r3.filegroups = f1 f2</span><br><span class="line">a3.sources.r3.filegroups.f1 = /opt/module/flume/files/.*file.*</span><br><span class="line">a3.sources.r3.filegroups.f2 = /opt/module/flume/files2/.*log.*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a3.sinks.k3.type = hdfs</span><br><span class="line">a3.sinks.k3.hdfs.path = hdfs://hadoop102:8020/flume/upload2/%Y%m%d/%H</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上传文件的前缀</span></span><br><span class="line">a3.sinks.k3.hdfs.filePrefix = upload-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否按照时间滚动文件夹</span></span><br><span class="line">a3.sinks.k3.hdfs.round = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多少时间单位创建一个新的文件夹</span></span><br><span class="line">a3.sinks.k3.hdfs.roundValue = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新定义时间单位</span></span><br><span class="line">a3.sinks.k3.hdfs.roundUnit = hour</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否使用本地时间戳</span></span><br><span class="line">a3.sinks.k3.hdfs.useLocalTimeStamp = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">积攒多少个Event才flush到HDFS一次</span></span><br><span class="line">a3.sinks.k3.hdfs.batchSize = 100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置文件类型，可支持压缩</span></span><br><span class="line">a3.sinks.k3.hdfs.fileType = DataStream</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多久生成一个新的文件</span></span><br><span class="line">a3.sinks.k3.hdfs.rollInterval = 60</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置每个文件的滚动大小大概是128M</span></span><br><span class="line">a3.sinks.k3.hdfs.rollSize = 134217700</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件的滚动与Event数量无关</span></span><br><span class="line">a3.sinks.k3.hdfs.rollCount = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a3.channels.c3.type = memory</span><br><span class="line">a3.channels.c3.capacity = 1000</span><br><span class="line">a3.channels.c3.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a3.sources.r3.channels = c3</span><br><span class="line">a3.sinks.k3.channel = c3</span><br></pre></td></tr></table></figure><h2 id="3-Flume事务"><a href="#3-Flume事务" class="headerlink" title="3. Flume事务"></a>3. Flume事务</h2><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661951909426.png" alt="1661951909426"></p><p><strong>Flume共包括了两个事务，一个是put，一个是take</strong></p><p><strong>put事务：</strong></p><p>首先把batch data写入临时缓冲区putList，然后检查channel内存队列是否足够合并，如果足够就写入channel，如果内存不足，就回滚数据</p><p><strong>take事务：</strong></p><p>把数据取到缓冲区takeList，并且把数据发送到HDFS，如果数据全部发送成功，清楚临时缓冲区takelist，数据发送过程中如果出现异常，就会把临时缓冲区中的数据归还给channel队列中去。</p><p>这样可能导致写入HDFS中的数据有重复值（重复的event）</p><h2 id="4-Flume-Agent内部原理"><a href="#4-Flume-Agent内部原理" class="headerlink" title="4. Flume Agent内部原理"></a>4. Flume Agent内部原理</h2><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661952301153.png" alt="1661952301153"></p><p><strong>重要组件：</strong></p><p><strong>ChannelSelector</strong></p><p>​ChannelSelector的作用就是选出Event将要被发往哪个Channel。其共有两种类型，分别是Replicating（复制）和Multiplexing（多路复用）。</p><p>​ReplicatingSelector会将同一个Event发往所有的Channel，Multiplexing会根据相应的原则，将不同的Event发往不同的Channel。</p><p><strong>SinkProcessor</strong></p><p>​SinkProcessor共有三种类型，分别是DefaultSinkProcessor、LoadBalancingSinkProcessor和FailoverSinkProcessor</p><p>​DefaultSinkProcessor对应的是单个的Sink，LoadBalancingSinkProcessor和FailoverSinkProcessor对应的是Sink Group，LoadBalancingSinkProcessor可以实现负载均衡的功能，FailoverSinkProcessor可以错误恢复的功能。</p><p><strong>Interceptor</strong></p><p>拦截器，可以筛选过滤event，这个需要使用java来边写一个class，然后放到flume中，后续会将实现方法。</p><h2 id="5-Flume-拓扑结构"><a href="#5-Flume-拓扑结构" class="headerlink" title="5. Flume 拓扑结构"></a>5. Flume 拓扑结构</h2><h3 id="5-1-简单串联"><a href="#5-1-简单串联" class="headerlink" title="5.1 简单串联"></a>5.1 简单串联</h3><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661958560365.png" alt="1661958560365"></p><p>​这种模式是将多个flume顺序连接起来了，从最初的source开始到最终sink传送的目的存储系统。此模式不建议桥接过多的flume数量， flume数量过多不仅会影响传输速率，而且一旦传输过程中某个节点flume宕机，会影响整个传输系统。</p><h3 id="5-2-复制和多路复用"><a href="#5-2-复制和多路复用" class="headerlink" title="5.2 复制和多路复用"></a>5.2 复制和多路复用</h3><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661958581790.png" alt="1661958581790"></p><p>​Flume支持将事件流向一个或者多个目的地。这种模式可以将相同数据复制到多个channel中，或者将不同数据分发到不同的channel中，sink可以选择传送到不同的目的地。</p><p><strong>需求：</strong></p><p>​使用Flume-1监控文件变动，Flume-1将变动内容传递给Flume-2，Flume-2负责存储到HDFS。同时Flume-1将变动内容传递给Flume-3，Flume-3负责输出到Local FileSystem。</p><p><strong>需求分析：</strong></p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661958843201.png" alt="1661958843201"></p><p><strong>实际操作：</strong></p><p>这里需要写三个flume配置文件</p><p>第一个flume，用于采集数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line">a1.channels = c1 c2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将数据流复制给所有channel</span></span><br><span class="line">a1.sources.r1.selector.type = replicating</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line">a1.sources.r1.command = tail -F /opt/module/hive/logs/hive.log</span><br><span class="line">a1.sources.r1.shell = /bin/bash -c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sink端的avro是一个数据发送者</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = hadoop102 </span><br><span class="line">a1.sinks.k1.port = 4141</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type = avro</span><br><span class="line">a1.sinks.k2.hostname = hadoop102</span><br><span class="line">a1.sinks.k2.port = 4142</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line">a1.channels.c2.type = memory</span><br><span class="line">a1.channels.c2.capacity = 1000</span><br><span class="line">a1.channels.c2.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1 c2</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c2</span><br></pre></td></tr></table></figure><p>把采集来的数据写到HDFS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a2.sources = r1</span><br><span class="line">a2.sinks = k1</span><br><span class="line">a2.channels = c1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span>端的avro是一个数据接收服务</span></span><br><span class="line">a2.sources.r1.type = avro</span><br><span class="line">a2.sources.r1.bind = hadoop102</span><br><span class="line">a2.sources.r1.port = 4141</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a2.sinks.k1.type = hdfs</span><br><span class="line">a2.sinks.k1.hdfs.path = hdfs://hadoop102:8020/flume2/%Y%m%d/%H</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上传文件的前缀</span></span><br><span class="line">a2.sinks.k1.hdfs.filePrefix = flume2-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否按照时间滚动文件夹</span></span><br><span class="line">a2.sinks.k1.hdfs.round = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多少时间单位创建一个新的文件夹</span></span><br><span class="line">a2.sinks.k1.hdfs.roundValue = 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新定义时间单位</span></span><br><span class="line">a2.sinks.k1.hdfs.roundUnit = hour</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否使用本地时间戳</span></span><br><span class="line">a2.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">积攒多少个Event才flush到HDFS一次</span></span><br><span class="line">a2.sinks.k1.hdfs.batchSize = 100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置文件类型，可支持压缩</span></span><br><span class="line">a2.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多久生成一个新的文件</span></span><br><span class="line">a2.sinks.k1.hdfs.rollInterval = 600</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置每个文件的滚动大小大概是128M</span></span><br><span class="line">a2.sinks.k1.hdfs.rollSize = 134217700</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件的滚动与Event数量无关</span></span><br><span class="line">a2.sinks.k1.hdfs.rollCount = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a2.channels.c1.type = memory</span><br><span class="line">a2.channels.c1.capacity = 1000</span><br><span class="line">a2.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a2.sources.r1.channels = c1</span><br><span class="line">a2.sinks.k1.channel = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采集来的数据写到local</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a3.sources = r1</span><br><span class="line">a3.sinks = k1</span><br><span class="line">a3.channels = c2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a3.sources.r1.type = avro</span><br><span class="line">a3.sources.r1.bind = hadoop102</span><br><span class="line">a3.sources.r1.port = 4142</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a3.sinks.k1.type = file_roll</span><br><span class="line">a3.sinks.k1.sink.directory = /opt/module/data/flume3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a3.channels.c2.type = memory</span><br><span class="line">a3.channels.c2.capacity = 1000</span><br><span class="line">a3.channels.c2.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a3.sources.r1.channels = c2</span><br><span class="line">a3.sinks.k1.channel = c2</span><br></pre></td></tr></table></figure><p><strong>启动flume进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group1/flume-flume-dir.conf</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group1/flume-flume-hdfs.conf</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group1/flume-file-flume.conf</span><br></pre></td></tr></table></figure><h3 id="5-3-负载均衡和故障转移"><a href="#5-3-负载均衡和故障转移" class="headerlink" title="5.3 负载均衡和故障转移"></a>5.3 负载均衡和故障转移</h3><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661958717935.png" alt="1661958717935"></p><p>​Flume支持使用将多个sink逻辑上分到一个sink组，sink组配合不同的SinkProcessor可以实现负载均衡和错误恢复的功能。</p><p><strong>案例需求：</strong></p><p>​使用Flume1监控一个端口，其sink组中的sink分别对接Flume2和Flume3，采用FailoverSinkProcessor，实现故障转移的功能。</p><p><strong>需求分析：</strong></p><p>​<img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661959589858.png" alt="1661959589858"></p><p><strong>代码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1</span><br><span class="line">a1.sinkgroups = g1</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line">a1.sinkgroups.g1.processor.type = failover</span><br><span class="line">a1.sinkgroups.g1.processor.priority.k1 = 5</span><br><span class="line">a1.sinkgroups.g1.processor.priority.k2 = 10</span><br><span class="line">a1.sinkgroups.g1.processor.maxpenalty = 10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = hadoop102</span><br><span class="line">a1.sinks.k1.port = 4141</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type = avro</span><br><span class="line">a1.sinks.k2.hostname = hadoop102</span><br><span class="line">a1.sinks.k2.port = 4142</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinkgroups.g1.sinks = k1 k2</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a2.sources = r1</span><br><span class="line">a2.sinks = k1</span><br><span class="line">a2.channels = c1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a2.sources.r1.type = avro</span><br><span class="line">a2.sources.r1.bind = hadoop102</span><br><span class="line">a2.sources.r1.port = 4141</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a2.sinks.k1.type = logger</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a2.channels.c1.type = memory</span><br><span class="line">a2.channels.c1.capacity = 1000</span><br><span class="line">a2.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a2.sources.r1.channels = c1</span><br><span class="line">a2.sinks.k1.channel = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a3.sources = r1</span><br><span class="line">a3.sinks = k1</span><br><span class="line">a3.channels = c2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a3.sources.r1.type = avro</span><br><span class="line">a3.sources.r1.bind = hadoop102</span><br><span class="line">a3.sources.r1.port = 4142</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a3.sinks.k1.type = logger</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a3.channels.c2.type = memory</span><br><span class="line">a3.channels.c2.capacity = 1000</span><br><span class="line">a3.channels.c2.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a3.sources.r1.channels = c2</span><br><span class="line">a3.sinks.k1.channel = c2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​这个故障转移，其实就是设置了多个接收的flume机器，当其中一个坏掉之后，另一个就会代替其工作接着运行（初始的时候会根据权值，来判断哪一个机器正常运行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a3 --conf-file job/group2/flume-flume-console2.conf -Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a2 --conf-file job/group2/flume-flume-console1.conf -Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 flume]$ bin/flume-ng agent --conf conf/ --name a1 --conf-file job/group2/flume-netcat-flume.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-聚合"><a href="#5-4-聚合" class="headerlink" title="5.4 聚合"></a>5.4 聚合</h3><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661958765075.png" alt="1661958765075"></p><p>​这种模式是我们最常见的，也非常实用，日常web应用通常分布在上百个服务器，大者甚至上千个、上万个服务器。产生的日志，处理起来也非常麻烦。用flume的这种组合方式能很好的解决这一问题，每台服务器部署一个flume采集日志，传送到一个集中收集日志的flume，再由此flume上传到hdfs、hive、hbase等，进行日志分析。</p><p><strong>案例需求：</strong></p><p>​hadoop102上的Flume-1监控文件&#x2F;opt&#x2F;module&#x2F;group.log，</p><p>​hadoop103上的Flume-2监控某一个端口的数据流，</p><p>​Flume-1与Flume-2将数据发送给hadoop104上的Flume-3，Flume-3将最终数据打印到控制台。</p><p><strong>需求分析：</strong></p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661959950484.png" alt="1661959950484"></p><p><strong>代码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line">a1.sources.r1.command = tail -F /opt/module/group.log</span><br><span class="line">a1.sources.r1.shell = /bin/bash -c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = hadoop104</span><br><span class="line">a1.sinks.k1.port = 4141</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a2.sources = r1</span><br><span class="line">a2.sinks = k1</span><br><span class="line">a2.channels = c1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a2.sources.r1.type = netcat</span><br><span class="line">a2.sources.r1.bind = hadoop103</span><br><span class="line">a2.sources.r1.port = 44444</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a2.sinks.k1.type = avro</span><br><span class="line">a2.sinks.k1.hostname = hadoop104</span><br><span class="line">a2.sinks.k1.port = 4141</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a2.channels.c1.type = memory</span><br><span class="line">a2.channels.c1.capacity = 1000</span><br><span class="line">a2.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a2.sources.r1.channels = c1</span><br><span class="line">a2.sinks.k1.channel = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a3.sources = r1</span><br><span class="line">a3.sinks = k1</span><br><span class="line">a3.channels = c1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a3.sources.r1.type = avro</span><br><span class="line">a3.sources.r1.bind = hadoop104</span><br><span class="line">a3.sources.r1.port = 4141</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a3.sinks.k1.type = logger</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the channel</span></span><br><span class="line">a3.channels.c1.type = memory</span><br><span class="line">a3.channels.c1.capacity = 1000</span><br><span class="line">a3.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a3.sources.r1.channels = c1</span><br><span class="line">a3.sinks.k1.channel = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-自定义Interceptor"><a href="#6-自定义Interceptor" class="headerlink" title="6. 自定义Interceptor"></a>6. 自定义Interceptor</h2><p><strong>案例需求：</strong></p><p>​使用Flume采集服务器本地日志，需要按照日志类型的不同，将不同种类的日志发往不同的分析系统。</p><p><strong>需求分析：</strong></p><p>​在实际的开发中，一台服务器产生的日志类型可能有很多种，不同类型的日志可能需要发送到不同的分析系统。此时会用到Flume拓扑结构中的Multiplexing结构，Multiplexing的原理是，根据event中Header的某个key的值，将不同的event发送到不同的Channel中，所以我们需要自定义一个Interceptor，为不同类型的event的Header中的key赋予不同的值。</p><p>​在该案例中，我们以端口数据模拟日志，以数字（单个）和字母（单个）模拟不同类型的日志，我们需要自定义interceptor区分数字和字母，将其分别发往不同的分析系统（Channel）。</p><p><img src="/2022/08/31/Flume/flume%E6%A6%82%E8%BF%B0/1661960819628.png" alt="1661960819628"></p><p><strong>代码实现：</strong></p><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flume&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flume-ng-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.flume.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Event;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.interceptor.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Event <span class="title function_">intercept</span><span class="params">(Event event)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] body = event.getBody();</span><br><span class="line">        <span class="keyword">if</span> (body[<span class="number">0</span>] &lt; <span class="string">&#x27;z&#x27;</span> &amp;&amp; body[<span class="number">0</span>] &gt; <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            event.getHeaders().put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;letter&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body[<span class="number">0</span>] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; body[<span class="number">0</span>] &lt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            event.getHeaders().put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;number&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Event&gt; <span class="title function_">intercept</span><span class="params">(List&lt;Event&gt; events)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Event event : events) &#123;</span><br><span class="line">            intercept(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>.Builder &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Interceptor <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomInterceptor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>配置flume文件</strong></p><p>​为hadoop102上的Flume1配置1个netcat source，1个sink group（2个avro sink），并配置相应的ChannelSelector和interceptor。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line">a1.channels = c1 c2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line">a1.sources.r1.interceptors.i1.type = com.atguigu.flume.interceptor.CustomInterceptor$Builder</span><br><span class="line">a1.sources.r1.selector.type = multiplexing</span><br><span class="line">a1.sources.r1.selector.header = type</span><br><span class="line">a1.sources.r1.selector.mapping.letter = c1</span><br><span class="line">a1.sources.r1.selector.mapping.number = c2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = hadoop103</span><br><span class="line">a1.sinks.k1.port = 4141</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type=avro</span><br><span class="line">a1.sinks.k2.hostname = hadoop104</span><br><span class="line">a1.sinks.k2.port = 4242</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c2.type = memory</span><br><span class="line">a1.channels.c2.capacity = 1000</span><br><span class="line">a1.channels.c2.transactionCapacity = 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1 c2</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c2</span><br></pre></td></tr></table></figure><p>​为hadoop103上的Flume4配置一个avro source和一个logger sink。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = hadoop103</span><br><span class="line">a1.sources.r1.port = 4141</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​为hadoop104上的Flume3配置一个avro source和一个logger sink。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = hadoop104</span><br><span class="line">a1.sources.r1.port = 4242</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：source的Multiplexing需要结合拦截器来使用，需要拦截器给每个event来增加头部值，把头部不同的值分发到不同的channel中去。</p>]]></content>
      
      
      <categories>
          
          <category> Flume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sink </tag>
            
            <tag> Interceptor </tag>
            
            <tag> Source </tag>
            
            <tag> Channel </tag>
            
            <tag> event </tag>
            
            <tag> agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive概念介绍</title>
      <link href="/2022/08/30/Hive/hive%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/30/Hive/hive%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Hive的几种启动方式"><a href="#1-Hive的几种启动方式" class="headerlink" title="1. Hive的几种启动方式"></a>1. Hive的几种启动方式</h2><h3 id="1-1-命令行模式"><a href="#1-1-命令行模式" class="headerlink" title="1.1 命令行模式"></a>1.1 命令行模式</h3><p>先启动hadoop集群之后，然后就可以直接在命令行启动Hive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hive]$ bin/hive</span><br></pre></td></tr></table></figure><h3 id="1-2-使用元数据服务的方式访问Hive"><a href="#1-2-使用元数据服务的方式访问Hive" class="headerlink" title="1.2 使用元数据服务的方式访问Hive"></a>1.2 使用元数据服务的方式访问Hive</h3><p><strong>1）在hive-site.xml文件中添加如下配置信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 指定存储元数据要连接的地址 --&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hive.metastore.uris&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;thrift://hadoop102:9083&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br></pre></td></tr></table></figure><p><strong>2）启动metastore</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop202 hive]$ hive --service metastore</span><br><span class="line">2020-04-24 16:58:08: Starting Hive Metastore Server</span><br></pre></td></tr></table></figure><p>注意: 启动后窗口不能再操作，需打开一个新的shell窗口做别的操作</p><p><strong>3）启动hive</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop202 hive]$ bin/hive</span><br></pre></td></tr></table></figure><p><strong>好奇一个问题：我们为什么要配置这个metastore服务？</strong></p><p>首先，什么是元数据：<a href="https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">元数据</a>包含用Hive创建的database、table等的元信息。元数据存储在关系型数据库中。如Derby、MySQL等。</p><p>那么，配置的metastore有什么用：<strong>客户端连接metastore服务，metastore再去连接MySQL数据库来存取元数据。有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接metastore 服务即可。</strong></p><h3 id="1-3-使用JDBC方式来访问Hive"><a href="#1-3-使用JDBC方式来访问Hive" class="headerlink" title="1.3 使用JDBC方式来访问Hive"></a>1.3 使用JDBC方式来访问Hive</h3><ol><li><strong>在hive-site.xml文件中添加如下配置信息</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 指定hiveserver2连接的host --&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;hadoop102&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 指定hiveserver2连接的端口号 --&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hive.server2.thrift.port&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;10000&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>启动hiveserver2</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hive]$ bin/hive --service hiveserver2</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>启动beeline客户端</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hive]$ bin/beeline -u jdbc:hive2://hadoop102:10000 -n atguigu</span><br></pre></td></tr></table></figure><h3 id="1-4-hiveserver2和metastore的联系"><a href="#1-4-hiveserver2和metastore的联系" class="headerlink" title="1.4 hiveserver2和metastore的联系"></a>1.4 hiveserver2和metastore的联系</h3><p>hiveServer2和metaStore其实都是hive本身带的组件，那么两者究竟有什么不同呢？</p><ol><li><p>metaStore：hive的metaStore提供的是一个服务，而这个服务就是将hive的元数据暴露出去，而不是需要通过对hive元数据库mysql的访问才能拿到hive的元数据信息;metastore服务实际上就是一种thrift服务，通过它我们可以获取到hive原数据，并且通过thrift获取原数据的方式，屏蔽了数据库访问需要驱动，url，用户名，密码等等细节</p></li><li><p>hiveServer2: HiveServer2（HS2）是一个服务端接口，使远程客户端可以执行对Hive的查询并返回结果。目前基于Thrift RPC的实现是HiveServer的改进版本，并支持多客户端并发和身份验证, 启动hiveServer2服务后，就可以使用jdbc，odbc，或者thrift的方式连接</p></li></ol><p><strong>总结：</strong></p><ol><li>HiveServer2和MetaStore本质上都是Thrift Service，虽然可以启动在同一个进程内，但不建议这么做。建议是拆成不同的服务进程来启动。</li><li>一般来讲，我们认为HiveServer2是用来提交查询的，也就是用来访问数据的。而MetaStore才是用来访问元数据的。<strong>在我的认知下，其实就是metaStore用来访问元数据，而hiveserver只是在metaStore的上层又添加了一层功能（用来让用户可以使用jdbc等方式连接）</strong></li></ol><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>1）hive有2种客户端：hive客户端和beeline客户端，beeline客户端是通过hiveserver2服务以JDBC的方式连接hive客户端。<br>2）hive作为服务端有2个后台服务：metastore服务，hiveserver2服务。<br>3）hive连接元数据有2种方式：直接连接和metastore服务连接。<br>4）如果配置了hive.metastore.uris参数，必须启动metastore服务才能连接元数据；如果没有配置可以直接连接元数据。<br>5）hive本身既是客户端，又是服务端。</p><h2 id="2-Hive的数据类型"><a href="#2-Hive的数据类型" class="headerlink" title="2.Hive的数据类型"></a>2.Hive的数据类型</h2><h3 id="2-1Hive的基本数据类型"><a href="#2-1Hive的基本数据类型" class="headerlink" title="2.1Hive的基本数据类型"></a>2.1Hive的基本数据类型</h3><table><thead><tr><th>Hive数据类型</th><th>Java数据类型</th><th>长度</th><th>例子</th></tr></thead><tbody><tr><td>TINYINT</td><td>byte</td><td>1byte有符号整数</td><td>20</td></tr><tr><td>SMALINT</td><td>short</td><td>2byte有符号整数</td><td>20</td></tr><tr><td>INT</td><td>int</td><td>4byte有符号整数</td><td>20</td></tr><tr><td>BIGINT</td><td>long</td><td>8byte有符号整数</td><td>20</td></tr><tr><td>BOOLEAN</td><td>boolean</td><td>布尔类型，true或者false</td><td>TRUE  FALSE</td></tr><tr><td>FLOAT</td><td>float</td><td>单精度浮点数</td><td>3.14159</td></tr><tr><td>DOUBLE</td><td>double</td><td>双精度浮点数</td><td>3.14159</td></tr><tr><td>STRING</td><td>string</td><td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td><td>‘now is the time’   “for all good men”</td></tr><tr><td>TIMESTAMP</td><td></td><td>时间类型</td><td></td></tr><tr><td>BINARY</td><td></td><td>字节数组</td><td></td></tr></tbody></table><p>​其中的string相当于数据库中的varchar类型，改类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。</p><h3 id="2-2-集合数据类型"><a href="#2-2-集合数据类型" class="headerlink" title="2.2 集合数据类型"></a>2.2 集合数据类型</h3><table><thead><tr><th>数据类型</th><th>描述</th><th>语法示例</th></tr></thead><tbody><tr><td>STRUCT</td><td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last   STRING},那么第1个元素可以通过字段.first来引用。</td><td>struct()   例如struct&lt;street:string, city:string&gt;</td></tr><tr><td>MAP</td><td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td><td>map()   例如map&lt;string, int&gt;</td></tr><tr><td>ARRAY</td><td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td><td>Array()   例如array<string></td></tr></tbody></table><p>​Hive有三种复杂数据类型ARRAY、MAP 和STRUCT。ARRAY和MAP与Java中的Array和Map类似，而STRUCT与C语言中的Struct类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。</p><p><strong>实例展示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;songsong&quot;,</span><br><span class="line">    &quot;friends&quot;: [&quot;bingbing&quot; , &quot;lili&quot;] ,       //列表Array, </span><br><span class="line">    &quot;children&quot;: &#123;                      //键值Map,</span><br><span class="line">        &quot;xiao song&quot;: 19 ,</span><br><span class="line">        &quot;xiaoxiao song&quot;: 18</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;address&quot;: &#123;                      //结构Struct,</span><br><span class="line">        &quot;street&quot;: &quot;hui long guan&quot; ,</span><br><span class="line">        &quot;city&quot;: &quot;beijing&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Hive创建表格"><a href="#3-Hive创建表格" class="headerlink" title="3.Hive创建表格"></a>3.Hive创建表格</h2><p>建表语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name </span><br><span class="line">[(col_name data_type [COMMENT col_comment], ...)] </span><br><span class="line">[COMMENT table_comment] </span><br><span class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] </span><br><span class="line">[CLUSTERED BY (col_name, col_name, ...) </span><br><span class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] </span><br><span class="line">[ROW FORMAT row_format] </span><br><span class="line">[STORED AS file_format] </span><br><span class="line">[LOCATION hdfs_path]</span><br><span class="line">[TBLPROPERTIES (property_name=property_value, ...)]</span><br><span class="line">[AS select_statement]</span><br></pre></td></tr></table></figure><p>（1）CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。</p><p>（2）EXTERNAL关键字可以让用户创建一个外部表，在建表的同时可以指定一个指向实际数据的路径（LOCATION），在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p><p>（3）COMMENT：为表和列添加注释。</p><p>（4）PARTITIONED BY创建分区表</p><p>（5）CLUSTERED BY创建分桶表</p><p>（6）SORTED BY不常用，对桶中的一个或多个列另外排序</p><p>（7）ROW FORMAT </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]</span><br><span class="line">        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] </span><br><span class="line">   | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]</span><br></pre></td></tr></table></figure><p>用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。</p><p>SerDe是Serialize&#x2F;Deserilize的简称， hive使用Serde进行行对象的序列与反序列化。</p><p>（8）STORED AS指定存储文件类型</p><p>常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件）</p><p>如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p><p>（9）LOCATION ：指定表在HDFS上的存储位置(这样其实就是把HDFS中的结构化文件映射到表格中来)，如果在这里没有指定文件路径，那么我们还需要后续指定，或者手动添加数据（一般不常用）。</p><p>（10）AS：后跟查询语句，根据查询结果创建表。</p><p>（11）LIKE允许用户复制现有的表结构，但是不复制数据。</p><h3 id="3-1-内部表"><a href="#3-1-内部表" class="headerlink" title="3.1 内部表"></a>3.1 内部表</h3><p>​默认创建的表都是所谓的管理表，有时也被称为内部表。因为这种表，Hive会（或多或少地）控制着数据的生命周期。Hive默认情况下会将这些表的数据存储在由配置项hive.metastore.warehouse.dir(例如，&#x2F;user&#x2F;hive&#x2F;warehouse)所定义的目录的子目录下。当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据。</p><p>​<strong>通俗的来讲，内部表，顾名思义，Hive内部管理的表格，所以hive删除该表格的时候，数据文件也会相应的删除掉</strong></p><h3 id="3-2-外部表"><a href="#3-2-外部表" class="headerlink" title="3.2 外部表"></a>3.2 外部表</h3><p>​外部表，hive并非认为其含有这份数据，删除这个表格的时候并不会删除数据，但是描述表格信息的元数据信息会被删除掉。</p><p><strong>实例展示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">name string,</span><br><span class="line">friends array&lt;string&gt;,</span><br><span class="line">children map&lt;string, int&gt;,</span><br><span class="line">address struct&lt;street:string, city:string&gt;</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#x27;,&#x27;</span><br><span class="line">collection items terminated by &#x27;_&#x27;</span><br><span class="line">map keys terminated by &#x27;:&#x27;</span><br><span class="line">lines terminated by &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure><p>字段解释如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row format delimited fields terminated by &#x27;,&#x27;     表示列的分隔符是&#x27;,&#x27;</span><br><span class="line">collection items terminated by &#x27;_&#x27;                表示map和array和struct的分隔符</span><br><span class="line">map keys terminated by &#x27;:&#x27;                        表示map中key和value的分隔符</span><br><span class="line">lines terminated by &#x27;\n&#x27;;                         表示行分隔符</span><br></pre></td></tr></table></figure><h2 id="4-Hive数据导入"><a href="#4-Hive数据导入" class="headerlink" title="4.Hive数据导入"></a>4.Hive数据导入</h2><h3 id="4-1-向表中装载数据（最常用）"><a href="#4-1-向表中装载数据（最常用）" class="headerlink" title="4.1 向表中装载数据（最常用）"></a>4.1 向表中装载数据（最常用）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">load data [<span class="built_in">local</span>] inpath <span class="string">&#x27;数据的path&#x27;</span> [overwrite] into table student [partition (partcol1=val1,…)];</span></span><br></pre></td></tr></table></figure><ol><li>local :加上该字段代表从本地加载数据到hive表格，否则从HDFS中加载数据</li><li>overwrite：加上该字段代表覆盖表中已有的数据，否则表示最佳</li><li>partition：表示上传到指定的分区（分区表的概念）</li></ol><h3 id="4-2-通过查询语句向表中插入数据"><a href="#4-2-通过查询语句向表中插入数据" class="headerlink" title="4.2 通过查询语句向表中插入数据"></a>4.2 通过查询语句向表中插入数据</h3><ol><li><strong>单张表查询结果插入</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; insert overwrite table student_par </span><br><span class="line">             select id, name from student ; </span><br></pre></td></tr></table></figure><p>insert into：以追加数据的方式插入到表或分区，原有数据不会删除</p><p>insert overwrite：会覆盖表中已存在的数据</p><p>注意：insert不支持插入部分字段</p><ol start="2"><li><strong>多分区插入模式(分区表)</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; from student</span><br><span class="line">              insert overwrite table student partition(month=&#x27;201707&#x27;)</span><br><span class="line">              select id, name where month=&#x27;201709&#x27;</span><br><span class="line">              insert overwrite table student partition(month=&#x27;201706&#x27;)</span><br><span class="line">              select id, name where month=&#x27;201709&#x27;;</span><br></pre></td></tr></table></figure><h3 id="4-3-创建表格的时候通过location指定加载的数据路径"><a href="#4-3-创建表格的时候通过location指定加载的数据路径" class="headerlink" title="4.3 创建表格的时候通过location指定加载的数据路径"></a>4.3 创建表格的时候通过location指定加载的数据路径</h3><p>​就是在建立表格的之后指定数据路径</p><h3 id="4-4-Import数据到指定Hive表格中"><a href="#4-4-Import数据到指定Hive表格中" class="headerlink" title="4.4 Import数据到指定Hive表格中"></a>4.4 Import数据到指定Hive表格中</h3><p>注意：这里需要先使用export把某个表格到处，然后才能把数据导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; import table student2  from</span><br><span class="line"> &#x27;/user/hive/warehouse/export/student&#x27;;</span><br></pre></td></tr></table></figure><h2 id="5-数据导出"><a href="#5-数据导出" class="headerlink" title="5.数据导出"></a>5.数据导出</h2><ol><li><p><strong>Insert导出</strong></p><p>导出到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; insert overwrite local directory &#x27;/opt/module/hive/datas/export/student&#x27;</span><br><span class="line">            select * from student;</span><br></pre></td></tr></table></figure><p>查询结果格式化后再保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">hive(default)&gt;</span><span class="language-bash">insert overwrite <span class="built_in">local</span> directory <span class="string">&#x27;/opt/module/hive/datas/export/student1&#x27;</span></span></span><br><span class="line">           ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;\t&#x27;             select * from student;</span><br></pre></td></tr></table></figure><p>查询结果保存到HDFS上（其实就是把local去掉就可以）</p></li><li><p><strong>Hadoop命令导出到本地</strong></p><p>其实就是put指令把文件下载下来</p></li><li><p><strong>Hive Shell命令导出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hive]$ bin/hive -e &#x27;select * from default.student;&#x27; &gt;</span><br><span class="line"> /opt/module/hive/datas/export/student4.txt;</span><br></pre></td></tr></table></figure></li><li><p>Export导出到HDFS中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(defahiveult)&gt; </span><span class="language-bash"><span class="built_in">export</span> table default.student to</span></span><br><span class="line"> &#x27;/user/hive/warehouse/export/student&#x27;;</span><br></pre></td></tr></table></figure><p><strong>export和import主要用于两个Hadoop平台集群之间Hive表迁移。</strong></p></li><li><p>Sqoop导出，后续我会再写一个专门的博客来讲述</p></li></ol><h2 id="6-分区表"><a href="#6-分区表" class="headerlink" title="6.分区表"></a>6.分区表</h2><h3 id="6-1-分区表基本操作"><a href="#6-1-分区表基本操作" class="headerlink" title="6.1 分区表基本操作"></a>6.1 分区表基本操作</h3><p>​分区表实际上就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过WHERE子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。</p><p>​一般来说，分区表大部分都是按照时间来划分，把每一天的数据当作一个分区</p><hr><p><strong>创建分区表语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create table dept_partition(</span><br><span class="line">deptno int, dname string, loc string</span><br><span class="line">)</span><br><span class="line">partitioned by (day string)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure><p><strong>注意：分区字段不能是表中已经存在的数据，可以将分区字段看作表的伪列。</strong></p><hr><p><strong>加载数据到分区表中：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/hive/datas/dept_20200401.log&#x27; into table dept_partition partition(day=&#x27;20200401&#x27;);</span><br><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/hive/datas/dept_20200402.log&#x27; into table dept_partition partition(day=&#x27;20200402&#x27;);</span><br><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module/hive/datas/dept_20200403.log&#x27; into table dept_partition partition(day=&#x27;20200403&#x27;);</span><br></pre></td></tr></table></figure><h3 id="6-2-二级分区"><a href="#6-2-二级分区" class="headerlink" title="6.2 二级分区"></a>6.2 二级分区</h3><p><strong>创建表格基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create table dept_partition2(</span><br><span class="line">               deptno int, dname string, loc string</span><br><span class="line">               )</span><br><span class="line">               partitioned by (day string, hour string)</span><br><span class="line">               row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure><p><strong>加载数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#x27;/opt/module`/hive/datas/dept_20200401.log&#x27; into table</span><br><span class="line">dept_partition2 partition(day=&#x27;20200401&#x27;, hour=&#x27;12&#x27;);</span><br></pre></td></tr></table></figure><h3 id="6-3-动态分区"><a href="#6-3-动态分区" class="headerlink" title="6.3 动态分区"></a>6.3 动态分区</h3><p>​关系型数据库中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p><p>（1）开启动态分区功能（默认true，开启）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.exec.dynamic.partition=true</span><br></pre></td></tr></table></figure><p>（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.exec.dynamic.partition.mode=nonstrict</span><br></pre></td></tr></table></figure><p>（3）在所有执行MR的节点上，最大一共可以创建多少个动态分区。默认1000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.exec.max.dynamic.partitions=1000</span><br></pre></td></tr></table></figure><p>（4）在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.exec.max.dynamic.partitions.pernode=100</span><br></pre></td></tr></table></figure><p>（5）整个MR Job中，最大可以创建多少个HDFS文件。默认100000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.exec.max.created.files=100000</span><br></pre></td></tr></table></figure><p>（6）当有空分区生成时，是否抛出异常。一般不需要设置。默认false</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.error.on.empty.partition=false</span><br></pre></td></tr></table></figure><p><strong>创建目标分区表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create table dept_partition_dy(id int, name string) partitioned by (loc int) row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure><p><strong>设置动态分区</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; insert into table dept_partition_dy partition(loc) select deptno, dname, loc from dept;</span><br></pre></td></tr></table></figure><h2 id="7-分桶表"><a href="#7-分桶表" class="headerlink" title="7.分桶表"></a>7.分桶表</h2><p>​分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区。对于一张表或者分区，Hive 可以进一步组织成桶，也就是更为细粒度的数据范围划分。</p><p>​分桶是将数据集分解成更容易管理的若干部分的另一个技术。</p><p>​分区针对的是数据的存储路径；分桶针对的是数据文件。</p><p><strong>创建分桶表语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu_bucket(id int, name string)</span><br><span class="line">clustered by(id) </span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure><p><strong>导入数据到分桶表：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data inpath   &#x27;/student.txt&#x27; into table stu_bucket;</span><br></pre></td></tr></table></figure><p><strong>分桶规则：</strong></p><p>Hive的分桶采用对分桶字段的值进行哈希，然后除以桶的个数求余的方 式决定该条记录存放在哪个桶当中</p><p><strong>注意事项：</strong></p><p>（1）reduce的个数设置为-1,让Job自行决定需要用多少个reduce或者将reduce的个数设置为大于等于分桶表的桶数</p><p>（2）从hdfs中load数据到分桶表中，避免本地文件找不到问题</p><p>（3）不要使用本地模式</p><h2 id="8-Hive常用内置函数"><a href="#8-Hive常用内置函数" class="headerlink" title="8. Hive常用内置函数"></a>8. Hive常用内置函数</h2><h3 id="8-1-空字段复制"><a href="#8-1-空字段复制" class="headerlink" title="8.1 空字段复制"></a>8.1 空字段复制</h3><p><strong>函数说明：</strong></p><p>​NVL：给值为NULL的数据赋值，它的格式是NVL( value，default_value)。它的功能是如果value为NULL，则NVL函数返回default_value的值，否则返回value的值，如果两个参数都为NULL ，则返回NULL。</p><p><strong>实例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select comm, nvl(comm,mgr) from emp;</span><br><span class="line">OK</span><br><span class="line">comm    _c1</span><br><span class="line">NULL    7902.0</span><br><span class="line">300.0   300.0</span><br><span class="line">500.0   500.0</span><br><span class="line">NULL    7839.0</span><br><span class="line">1400.0  1400.0</span><br><span class="line">NULL    7839.0</span><br><span class="line">NULL    7839.0</span><br><span class="line">NULL    7566.0</span><br><span class="line">NULL    NULL</span><br><span class="line">0.0     0.0</span><br><span class="line">NULL    7788.0</span><br><span class="line">NULL    7698.0</span><br><span class="line">NULL    7566.0</span><br><span class="line">NULL    7782.0</span><br></pre></td></tr></table></figure><h3 id="8-2-CASE-WHEN-ELSE-END"><a href="#8-2-CASE-WHEN-ELSE-END" class="headerlink" title="8.2 CASE WHEN ELSE END"></a>8.2 CASE WHEN ELSE END</h3><p><strong>数据：</strong></p><table><thead><tr><th>name</th><th>dept_id</th><th>sex</th></tr></thead><tbody><tr><td>悟空</td><td>A</td><td>男</td></tr><tr><td>大海</td><td>A</td><td>男</td></tr><tr><td>宋宋</td><td>B</td><td>男</td></tr><tr><td>凤姐</td><td>A</td><td>女</td></tr><tr><td>婷姐</td><td>B</td><td>女</td></tr><tr><td>婷婷</td><td>B</td><td>女</td></tr></tbody></table><p><strong>创建表格：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table emp_sex(</span><br><span class="line">name string, </span><br><span class="line">dept_id string, </span><br><span class="line">sex string) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &#x27;/opt/module/hive/datas/emp_sex.txt&#x27; into table emp_sex;</span><br></pre></td></tr></table></figure><p><strong>查询：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">  dept_id,</span><br><span class="line">  sum(case sex when &#x27;男&#x27; then 1 else 0 end) male_count,</span><br><span class="line">  sum(case sex when &#x27;女&#x27; then 1 else 0 end) female_count</span><br><span class="line">from </span><br><span class="line">  emp_sex</span><br><span class="line">group by</span><br><span class="line">  dept_id;</span><br></pre></td></tr></table></figure><h3 id="8-3-行转列"><a href="#8-3-行转列" class="headerlink" title="8.3 行转列"></a>8.3 行转列</h3><p><strong>相关函数说明</strong></p><p>​CONCAT(string A&#x2F;col, string B&#x2F;col…)：返回输入字符串连接后的结果，支持任意个输入字符串;</p><p>​CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;</p><p>​注意: CONCAT_WS must be “string or array<string></p><p>​COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p><p>数据：</p><table><thead><tr><th>name</th><th>constellation</th><th>blood_type</th></tr></thead><tbody><tr><td>孙悟空</td><td>白羊座</td><td>A</td></tr><tr><td>大海</td><td>射手座</td><td>A</td></tr><tr><td>宋宋</td><td>白羊座</td><td>B</td></tr><tr><td>猪八戒</td><td>白羊座</td><td>A</td></tr><tr><td>凤姐</td><td>射手座</td><td>A</td></tr><tr><td>苍老师</td><td>白羊座</td><td>B</td></tr></tbody></table><p><strong>需求：</strong></p><p>把星座和血型一样的人归类到一起。结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">射手座,A            大海|凤姐</span><br><span class="line">白羊座,A            孙悟空|猪八戒</span><br><span class="line">白羊座,B            宋宋|苍老师</span><br></pre></td></tr></table></figure><p><strong>创建表格：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table person_info(</span><br><span class="line">name string, </span><br><span class="line">constellation string, </span><br><span class="line">blood_type string) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &quot;/opt/module/hive/datas/person_info.txt&quot; into table person_info;</span><br></pre></td></tr></table></figure><p><strong>查询语句：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.c_b , CONCAT_WS(&quot;|&quot;,collect_set(t1.name))</span><br><span class="line">FROM (</span><br><span class="line">SELECT NAME ,CONCAT_WS(&#x27;,&#x27;,constellation,blood_type) c_b</span><br><span class="line">FROM person_info</span><br><span class="line">)t1 </span><br><span class="line">GROUP BY t1.c_b</span><br></pre></td></tr></table></figure><p>其实行转列或者列转行并不是严格的 非得n行转成1行，要按照函数的应用情况来看</p><h3 id="8-4-列转行"><a href="#8-4-列转行" class="headerlink" title="8.4 列转行"></a>8.4 列转行</h3><p><strong>函数说明：</strong></p><p>EXPLODE(col)：将hive一列中复杂的array或者map结构拆分成多行。</p><p>LATERAL VIEW</p><p>用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias</p><p>解释：用于和split, explode等UDTF一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。</p><p><strong>数据准备：</strong></p><table><thead><tr><th>movie</th><th>category</th></tr></thead><tbody><tr><td>《疑犯追踪》</td><td>悬疑,动作,科幻,剧情</td></tr><tr><td>《Lie to me》</td><td>悬疑,警匪,动作,心理,剧情</td></tr><tr><td>《战狼2》</td><td>战争,动作,灾难</td></tr></tbody></table><p><strong>需求：</strong></p><p>将电影分类中的数组数据展开。结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">《疑犯追踪》      悬疑</span><br><span class="line">《疑犯追踪》      动作</span><br><span class="line">《疑犯追踪》      科幻</span><br><span class="line">《疑犯追踪》      剧情</span><br><span class="line">《Lie to me》   悬疑</span><br><span class="line">《Lie to me》   警匪</span><br><span class="line">《Lie to me》   动作</span><br><span class="line">《Lie to me》   心理</span><br><span class="line">《Lie to me》   剧情</span><br><span class="line">《战狼2》        战争</span><br><span class="line">《战狼2》        动作</span><br><span class="line">《战狼2》        灾难</span><br></pre></td></tr></table></figure><p><strong>创建表格：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table movie_info(</span><br><span class="line">    movie string, </span><br><span class="line">    category string) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &quot;/opt/module/hive/datas/movie_info.txt&quot; into table movie_info;</span><br></pre></td></tr></table></figure><p><strong>查询语句：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT movie,category_name </span><br><span class="line">FROM movie_info </span><br><span class="line">lateral VIEW</span><br><span class="line">explode(split(category,&quot;,&quot;)) movie_info_tmp  AS category_name ;</span><br></pre></td></tr></table></figure><p>解读：上述经过split函数之后，就成了一个字符串数组，然后我们就可以使用explode函数把这个数组变为多行数据。</p><h3 id="8-5-窗口函数"><a href="#8-5-窗口函数" class="headerlink" title="8.5 窗口函数"></a>8.5 窗口函数</h3><p><strong>相关函数说明</strong></p><p>OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的改变而变化。</p><p>CURRENT ROW：当前行</p><p>n PRECEDING：往前n行数据</p><p>n FOLLOWING：往后n行数据</p><p>UNBOUNDED：起点，</p><p>​         UNBOUNDED PRECEDING 表示从前面的起点， </p><p>​    UNBOUNDED FOLLOWING表示到后面的终点</p><p>LAG(col,n,default_val)：往前第n行数据</p><p>LEAD(col,n, default_val)：往后第n行数据</p><p>NTILE(n)：把有序窗口的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</p><p><strong>数据准备：name,orderdate,cost</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure><p><strong>需求：</strong></p><p>（1）查询在2017年4月份购买过的顾客及总人数</p><p>（2）查询顾客的购买明细及月购买总额</p><p>（3）上述的场景, 将每个顾客的cost按照日期进行累加</p><p>（4）查询每个顾客上次的购买时间</p><p>（5）查询前20%时间的订单信息</p><p><strong>创建表格：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table business(</span><br><span class="line">name string, </span><br><span class="line">orderdate string,</span><br><span class="line">cost int</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#x27;,&#x27;;</span><br><span class="line">load data local inpath &quot;/opt/module/hive/datas/business.txt&quot; into table business;</span><br></pre></td></tr></table></figure><p><strong>查询命令：</strong></p><ol><li><p>查询在2017年4月份购买过的顾客及总人数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name,count(*) over () </span><br><span class="line">from business </span><br><span class="line">where substring(orderdate,1,7) = &#x27;2017-04&#x27; </span><br><span class="line">group by name;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查询顾客的购买明细及月购买总额</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name,orderdate,cost,sum(cost) over(partition by month(orderdate)) from</span><br><span class="line">business;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将每个顾客的cost按照日期进行累加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select name,orderdate,cost, </span><br><span class="line">sum(cost) over() as sample1,--所有行相加 </span><br><span class="line">sum(cost) over(partition by name) as sample2,--按name分组，组内数据相加 </span><br><span class="line">sum(cost) over(partition by name order by orderdate) as sample3,--按name分组，组内数据累加 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between UNBOUNDED PRECEDING and current row ) as sample4 ,--和sample3一样,由起点到当前行的聚合 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING and current row) as sample5, --当前行和前面一行做聚合 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING AND 1 FOLLOWING ) as sample6,--当前行和前边一行及后面一行 </span><br><span class="line">sum(cost) over(partition by name order by orderdate rows between current row and UNBOUNDED FOLLOWING ) as sample7 --当前行及后面所有行 </span><br><span class="line">from business;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看顾客上次的购买时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name,orderdate,cost, </span><br><span class="line">lag(orderdate,1,&#x27;1900-01-01&#x27;) over(partition by name order by orderdate ) as time1, lag(orderdate,2) over (partition by name order by orderdate) as time2 </span><br><span class="line">from business;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查询前20%时间的订单信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from (</span><br><span class="line">    select name,orderdate,cost, ntile(5) over(order by orderdate) sorted</span><br><span class="line">    from business</span><br><span class="line">) t</span><br><span class="line">where sorted = 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>over(): 会为每条数据都开启一个窗口. 默认的窗口大小就是当前数据集的大小.<br>over(partition by ….) : 会按照指定的字段进行分区， 将分区字段的值相同的数据划分到相同的区。<br>                          每个区中的每条数据都会开启一个窗口.每条数据的窗口大小默认为当前分区数据集的大小.<br>over(order by ….) : 会在窗口中按照指定的字段对数据进行排序.<br>                      会为每条数据都开启一个窗口,默认的窗口大小为从数据集开头（起始行）开始到当前行.  </p><p>over(partition by …. order by ….) :会按照指定的字段进行分区， 将分区字段的值相同的数据划分到相同的区,<br>                                       在每个区中会按照指定的字段进行排序.<br>                                       会为每条数据都开启一个窗口,默认的窗口大小为当前分区中从数据集开始到当前行.                                            over(partition by … order by … rows between … and ….) : 指定每条数据的窗口大小.</p><h3 id="8-6-Rank"><a href="#8-6-Rank" class="headerlink" title="8.6 Rank"></a>8.6 Rank</h3><p><strong>函数说明：</strong></p><p>RANK() 排序相同时会重复，总数不会变</p><p>DENSE_RANK() 排序相同时会重复，总数会减少</p><p>ROW_NUMBER() 会根据顺序计算</p><p><strong>数据准备：</strong></p><table><thead><tr><th>name</th><th>subject</th><th>score</th></tr></thead><tbody><tr><td>孙悟空</td><td>语文</td><td>87</td></tr><tr><td>孙悟空</td><td>数学</td><td>95</td></tr><tr><td>孙悟空</td><td>英语</td><td>68</td></tr><tr><td>大海</td><td>语文</td><td>94</td></tr><tr><td>大海</td><td>数学</td><td>56</td></tr><tr><td>大海</td><td>英语</td><td>84</td></tr><tr><td>宋宋</td><td>语文</td><td>64</td></tr><tr><td>宋宋</td><td>数学</td><td>86</td></tr><tr><td>宋宋</td><td>英语</td><td>84</td></tr><tr><td>婷婷</td><td>语文</td><td>65</td></tr><tr><td>婷婷</td><td>数学</td><td>85</td></tr><tr><td>婷婷</td><td>英语</td><td>78</td></tr></tbody></table><p><strong>需求：</strong></p><p>计算每门学科成绩排名</p><p><strong>创建表格：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table score(</span><br><span class="line">name string,</span><br><span class="line">subject string, </span><br><span class="line">score int) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &#x27;/opt/module/hive/datas/score.txt&#x27; into table score;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>查询语句：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">select name,</span><br><span class="line">subject,</span><br><span class="line">score,</span><br><span class="line">rank() over(partition by subject order by score desc) rp,</span><br><span class="line">dense_rank() over(partition by subject order by score desc) drp,</span><br><span class="line">row_number() over(partition by subject order by score desc) rmp</span><br><span class="line">from score;</span><br><span class="line"></span><br><span class="line">name    subject score   rp      drp     rmp</span><br><span class="line">孙悟空  数学    95      1       1       1</span><br><span class="line">宋宋    数学    86      2       2       2</span><br><span class="line">婷婷    数学    85      3       3       3</span><br><span class="line">大海    数学    56      4       4       4</span><br><span class="line">宋宋    英语    84      1       1       1</span><br><span class="line">大海    英语    84      1       1       2</span><br><span class="line">婷婷    英语    78      3       2       3</span><br><span class="line">孙悟空  英语    68      4       3       4</span><br><span class="line">大海    语文    94      1       1       1</span><br><span class="line">孙悟空  语文    87      2       2       2</span><br><span class="line">婷婷    语文    65      3       3       3</span><br><span class="line">宋宋    语文    64      4       4       4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-7-其它常用函数"><a href="#8-7-其它常用函数" class="headerlink" title="8.7 其它常用函数"></a>8.7 其它常用函数</h3><h4 id="8-7-1-常用日期函数"><a href="#8-7-1-常用日期函数" class="headerlink" title="8.7.1 常用日期函数"></a>8.7.1 常用日期函数</h4><ol><li>unix_timestamp:返回当前或指定时间的时间戳<br>select unix_timestamp();<br>select unix_timestamp(“2020-10-28”,’yyyy-MM-dd’);</li><li>from_unixtime：将时间戳转为日期格式<br>select from_unixtime(1603843200);</li><li>current_date：当前日期<br>select current_date;</li><li>current_timestamp：当前的日期加时间<br>select current_timestamp;</li><li>to_date：抽取日期部分<br>select to_date(‘2020-10-28 12:12:12’);</li><li>year：获取年<br>select year(‘2020-10-28 12:12:12’);</li><li>month：获取月<br>select month(‘2020-10-28 12:12:12’);</li><li>day：获取日<br>select day(‘2020-10-28 12:12:12’);</li><li>hour：获取时<br>select hour(‘2020-10-28 12:13:14’);</li><li>minute：获取分<br>select minute(‘2020-10-28 12:13:14’);</li><li>second：获取秒<br>select second(‘2020-10-28 12:13:14’);</li><li>weekofyear：当前时间是一年中的第几周<br>select weekofyear(‘2020-10-28 12:12:12’);</li><li>dayofmonth：当前时间是一个月中的第几天<br>select dayofmonth(‘2020-10-28 12:12:12’);</li><li>months_between： 两个日期间的月份<br>select months_between(‘2020-04-01’,’2020-10-28’);</li><li>add_months：日期加减月<br>select add_months(‘2020-10-28’,-3);</li><li>datediff：两个日期相差的天数<br>select datediff(‘2020-11-04’,’2020-10-28’);</li><li>date_add：日期加天数<br>select date_add(‘2020-10-28’,4);</li><li>date_sub：日期减天数<br>select date_sub(‘2020-10-28’,-4);</li><li>last_day：日期的当月的最后一天<br>select last_day(‘2020-02-30’);</li><li>date_format(): 格式化日期<br>select date_format(‘2020-10-28 12:12:12’,’yyyy&#x2F;MM&#x2F;dd HH:mm:ss’);</li></ol><h4 id="8-7-2-常用取整函数"><a href="#8-7-2-常用取整函数" class="headerlink" title="8.7.2 常用取整函数"></a>8.7.2 常用取整函数</h4><ol start="21"><li>round： 四舍五入<br>select round(3.14);<br>select round(3.54);</li><li>ceil：  向上取整<br>select ceil(3.14);<br>select ceil(3.54);</li></ol><p>floor： 向下取整</p><ol start="23"><li>select floor(3.14);<br>select floor(3.54);</li></ol><h4 id="8-7-3-常用字符串操作函数"><a href="#8-7-3-常用字符串操作函数" class="headerlink" title="8.7.3 常用字符串操作函数"></a>8.7.3 常用字符串操作函数</h4><ol start="24"><li>upper： 转大写<br>select upper(‘low’);</li><li>lower： 转小写<br>select lower(‘low’);</li><li>length： 长度<br>select length(“atguigu”);</li><li>trim：  前后去空格<br>select trim(“ atguigu “);</li><li>lpad： 向左补齐，到指定长度<br>select lpad(‘atguigu’,9,’g’);</li><li>rpad：  向右补齐，到指定长度<br>select rpad(‘atguigu’,9,’g’);</li><li>regexp_replace：使用正则表达式匹配目标字符串，匹配成功后替换！<br>SELECT regexp_replace(‘2020&#x2F;10&#x2F;25’, ‘&#x2F;‘, ‘-‘);</li></ol><h4 id="8-7-4-集合操作"><a href="#8-7-4-集合操作" class="headerlink" title="8.7.4 集合操作"></a>8.7.4 集合操作</h4><ol start="31"><li>size： 集合中元素的个数<br>select size(friends) from test3;</li><li>map_keys： 返回map中的key<br>select map_keys(children) from test3;</li><li>map_values: 返回map中的value<br>select map_values(children) from test3;</li><li>array_contains: 判断array中是否包含某个元素<br>select array_contains(friends,’bingbing’) from test3;</li><li>sort_array： 将array中的元素排序<br>select sort_array(friends) from test3;</li></ol><h3 id="8-8-自定义UDF函数"><a href="#8-8-自定义UDF函数" class="headerlink" title="8.8 自定义UDF函数"></a>8.8 自定义UDF函数</h3><p><strong>需求：</strong></p><p>自定义一个UDF实现计算给定字符串的长度，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">hive(default)&gt; </span><span class="language-bash">select my_len(<span class="string">&quot;abcd&quot;</span>);</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义UDF函数，需要继承GenericUDF类</span></span><br><span class="line"><span class="comment"> * 需求: 计算指定字符串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStringLength</span> <span class="keyword">extends</span> <span class="title class_">GenericUDF</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments 输入参数类型的鉴别器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值类型的鉴别器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObjectInspector <span class="title function_">initialize</span><span class="params">(ObjectInspector[] arguments)</span> <span class="keyword">throws</span> UDFArgumentException &#123;</span><br><span class="line">        <span class="comment">// 判断输入参数的个数</span></span><br><span class="line">        <span class="keyword">if</span>(arguments.length !=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UDFArgumentLengthException</span>(<span class="string">&quot;Input Args Length Error!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断输入参数的类型</span></span><br><span class="line">        <span class="keyword">if</span>(!arguments[<span class="number">0</span>].getCategory().equals(ObjectInspector.Category.PRIMITIVE))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UDFArgumentTypeException</span>(<span class="number">0</span>,<span class="string">&quot;Input Args Type Error!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数本身返回值为int，需要返回int类型的鉴别器对象</span></span><br><span class="line">        <span class="keyword">return</span> PrimitiveObjectInspectorFactory.javaIntObjectInspector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments 输入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">evaluate</span><span class="params">(DeferredObject[] arguments)</span> <span class="keyword">throws</span> HiveException &#123;</span><br><span class="line">       <span class="keyword">if</span>(arguments[<span class="number">0</span>].get() == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arguments[<span class="number">0</span>].get().toString().length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDisplayString</span><span class="params">(String[] children)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打成jar包上传到服务器&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;myudf.jar</strong></p><p><strong>将jar包添加到hive的classpath</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; add jar /opt/module/hive/datas/myudf.jar;</span><br></pre></td></tr></table></figure><p><strong>创建临时函数与开发好的javaclass关联</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; create temporary function my_len as &quot;com.atguigu.hive.MyStringLength&quot;;</span><br></pre></td></tr></table></figure><p><strong>即可在hql中使用自定义的函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive (default)&gt; select ename,my_len(ename) ename_len from emp;</span><br></pre></td></tr></table></figure><h3 id="8-9-自定义UDTF函数"><a href="#8-9-自定义UDTF函数" class="headerlink" title="8.9 自定义UDTF函数"></a>8.9 自定义UDTF函数</h3><p><strong>需求：</strong></p><p>自定义一个UDTF实现将一个任意分割符的字符串切割成独立的单词，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">hive(default)&gt; </span><span class="language-bash">select myudtf(<span class="string">&quot;hello,world,hadoop,hive&quot;</span>, <span class="string">&quot;,&quot;</span>);</span></span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hadoop</span><br><span class="line">hive</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.udtf;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line">import org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line">import org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line">import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line">import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line">import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line">import org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MyUDTF extends GenericUDTF &#123;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;String&gt; outList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public StructObjectInspector initialize(StructObjectInspector argOIs) throws UDFArgumentException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //1.定义输出数据的列名和类型</span><br><span class="line">        List&lt;String&gt; fieldNames = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;ObjectInspector&gt; fieldOIs = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加输出数据的列名和类型</span><br><span class="line">        fieldNames.add(&quot;lineToWord&quot;);</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line"></span><br><span class="line">        return ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void process(Object[] args) throws HiveException &#123;</span><br><span class="line">        </span><br><span class="line">        //1.获取原始数据</span><br><span class="line">        String arg = args[0].toString();</span><br><span class="line"></span><br><span class="line">        //2.获取数据传入的第二个参数，此处为分隔符</span><br><span class="line">        String splitKey = args[1].toString();</span><br><span class="line"></span><br><span class="line">        //3.将原始数据按照传入的分隔符进行切分</span><br><span class="line">        String[] fields = arg.split(splitKey);</span><br><span class="line"></span><br><span class="line">        //4.遍历切分后的结果，并写出</span><br><span class="line">        for (String field : fields) &#123;</span><br><span class="line"></span><br><span class="line">            //集合为复用的，首先清空集合</span><br><span class="line">            outList.clear();</span><br><span class="line"></span><br><span class="line">            //将每一个单词添加至集合</span><br><span class="line">            outList.add(field);</span><br><span class="line"></span><br><span class="line">            //将集合内容写出</span><br><span class="line">            forward(outList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws HiveException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打成jar包上传到服务器&#x2F;opt&#x2F;module&#x2F;hive&#x2F;data&#x2F;myudtf.jar</strong></p><p><strong>将jar包添加到hive的classpath下</strong></p><p><strong>创建临时函数与开发好的javaclass关联</strong></p><p><strong>使用自定义的函数</strong></p><h2 id="9-文件存储格式"><a href="#9-文件存储格式" class="headerlink" title="9.文件存储格式"></a>9.文件存储格式</h2><p>​Hive支持的存储数据的格式主要有：TEXTFILE 、SEQUENCEFILE、ORC、PARQUET。</p><h3 id="9-1列式存储和行式存储"><a href="#9-1列式存储和行式存储" class="headerlink" title="9.1列式存储和行式存储"></a>9.1列式存储和行式存储</h3><p><img src="/2022/08/30/Hive/hive%E6%A6%82%E8%BF%B0/1661938785375.png" alt="1661938785375"></p><p>​如图所示左边为逻辑表，右边第一个为行式存储，第二个为列式存储。</p><ol><li><p><strong>行存储的特点</strong></p><p>​查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p></li><li><p><strong>列存储的特点</strong></p><p>​因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p></li></ol><p>​<strong>TEXTFILE和SEQUENCEFILE的存储格式都是基于行存储的；</strong></p><p>​<strong>ORC和PARQUET是基于列式存储的。</strong></p><h3 id="9-2-textFile格式"><a href="#9-2-textFile格式" class="headerlink" title="9.2 textFile格式"></a>9.2 textFile格式</h3><p>​默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合Gzip、Bzip2使用，但使用Gzip这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p><h3 id="9-3-Orc格式"><a href="#9-3-Orc格式" class="headerlink" title="9.3 Orc格式"></a>9.3 Orc格式</h3><p>​Orc (Optimized Row Columnar)是Hive 0.11版里引入的新的存储格式。</p><p>​如下图所示可以看到每个Orc文件由1个或多个stripe组成，每个stripe一般为HDFS的块大小，每一个stripe包含多条记录，这些记录按照列进行独立存储，对应到Parquet中的row group的概念。每个Stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer：</p><p><img src="/2022/08/30/Hive/hive%E6%A6%82%E8%BF%B0/1661939117144.png" alt="1661939117144"></p><p>​1）Index Data：一个轻量级的index，默认是每隔1W行做一个索引。这里做的索引应该只是记录某行的各字段在Row Data中的offset。</p><p>​2）Row Data：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream来存储。</p><p>​3）Stripe Footer：存的是各个Stream的类型，长度等信息。</p><p>​每个文件有一个File Footer，这里面存的是每个Stripe的行数，每个Column的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。在读取文件时，会seek到文件尾部读PostScript，从里面解析到File Footer长度，再读FileFooter，从里面解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p><h3 id="9-4-Parquet格式"><a href="#9-4-Parquet格式" class="headerlink" title="9.4 Parquet格式"></a>9.4 Parquet格式</h3><p>​Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式文件是自解析的。</p><p>（1）行组(Row Group)：每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，类似于orc的stripe的概念。</p><p>（2）列块(Column Chunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。一个列块中的值都是相同类型的，不同的列块可能使用不同的算法进行压缩。</p><p>（3）页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。</p><p>​通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式。</p><p><img src="/2022/08/30/Hive/hive%E6%A6%82%E8%BF%B0/1661939577441.png" alt="1661939577441"></p><p>​上图展示了一个Parquet文件的内容，一个文件中可以存储多个行组，文件的首位都是该文件的Magic<br>Code，用于校验它是否是一个Parquet文件，Footer length记录了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和该文件存储数据的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet中还不支持索引页。</p><h3 id="9-5存储方式和压缩总结"><a href="#9-5存储方式和压缩总结" class="headerlink" title="9.5存储方式和压缩总结"></a>9.5存储方式和压缩总结</h3><p>​在实际的项目开发当中，hive表的数据存储格式一般选择：orc或parquet。压缩方式一般选择snappy，lzo。</p>]]></content>
      
      
      <categories>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDF </tag>
            
            <tag> UDTF </tag>
            
            <tag> 分区表 </tag>
            
            <tag> 分桶表 </tag>
            
            <tag> 开窗函数 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2022/08/28/Zookeper/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
      <url>/2022/08/28/Zookeper/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Zookeeper的选举机制"><a href="#1-Zookeeper的选举机制" class="headerlink" title="1.Zookeeper的选举机制"></a>1.Zookeeper的选举机制</h2><p>（1）半数机制：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。</p><p>（2）Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</p><p>（3）以一个简单的例子来说明整个选举的过程。</p><p>​假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。</p><p><img src="/2022/08/28/Zookeper/%E6%9C%AA%E5%91%BD%E5%90%8D/1661691467670.png" alt="1661691467670"></p><p>（1）服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；</p><p>（2）服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的ID比自己目前投票推举的（服务器1）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING</p><p>（3）服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</p><p>（4）服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING；</p><p>（5）服务器5启动，同4一样当小弟。</p><h2 id="2-监听器原理"><a href="#2-监听器原理" class="headerlink" title="2.监听器原理"></a>2.监听器原理</h2><p><img src="/2022/08/28/Zookeper/%E6%9C%AA%E5%91%BD%E5%90%8D/1661691749227.png" alt="1661691749227"></p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> 选举 </tag>
            
            <tag> 监听机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH免密登录</title>
      <link href="/2022/08/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2022/08/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>免密登录原理：</p><p><img src="/2022/08/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/1661657310766.png" alt="1661657310766"></p><ol><li><p>生成公钥和私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 .ssh]$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li><p>把公钥拷贝到需要免密登录的机器上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop102</span><br><span class="line">[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop103</span><br><span class="line">[atguigu@hadoop102 .ssh]$ ssh-copy-id hadoop104</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>known_hosts</th><th>记录ssh访问过计算机的公钥(public   key)</th></tr></thead><tbody><tr><td>id_rsa</td><td>生成的私钥</td></tr><tr><td>id_rsa.pub</td><td>生成的公钥</td></tr><tr><td>authorized_keys</td><td>存放授权过的无密登录服务器公钥</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 离线数仓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH免密登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准备一台模板机</title>
      <link href="/2022/08/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E6%A8%A1%E6%9D%BF%E6%9C%BA/"/>
      <url>/2022/08/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E6%A8%A1%E6%9D%BF%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>本博客用于记录如何准备一台模板虚拟机</p><ol><li><p><strong>安装Linux系统</strong></p><p>其实安装Linux虚拟机还是比较简单的，但是有几个细节总是容易忘记，因此记录一下。</p><p>主要记不住的点在于手动分磁盘</p><ol><li>添加分区&#x2F;boot ,引导分区，建议1GB，修改设备类型为标准分区，文件系统为ext4</li><li>添加分区swap，这部分其实就是把一部分磁盘当作内存的备用空间，当内存不够用的时候，把这部分空间作为内存空间来使用，这部分空间可以设置为2GB，设备类型是标准分区，文件系统是swap</li><li>最后一个分区就是&#x2F; ，把剩余的磁盘全部分配，设备类型选择标准分区，文件系统是ext4</li></ol><p>其它部分就大致按照默认选项来就可以</p></li><li><p><strong>安装必要的环境，为安装Hadoop做准备</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# yum install -y epel-release</span><br><span class="line">[root@hadoop100 ~]# yum install -y psmisc nc net-tools rsync vim lrzsz ntp libzstd openssl-static tree iotop git</span><br></pre></td></tr></table></figure></li><li><p><strong>修改静态IP，教程在之前博客有讲到过</strong></p></li><li><p><strong>关闭防火墙，关闭防火墙开机自启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# systemctl stop firewalld</span><br><span class="line">[root@hadoop100 ~]# systemctl disable firewalld</span><br></pre></td></tr></table></figure></li><li><p><strong>创建新用户，并修改此用户密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# useradd atguigu</span><br><span class="line">[root@hadoop100 ~]# passwd atguigu</span><br></pre></td></tr></table></figure></li><li><p><strong>配置该用户具有root权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/sudoers</span><br></pre></td></tr></table></figure><p> 修改&#x2F;etc&#x2F;sudoers文件，找到下面一行（91行），在root下面添加一行，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line">atguigu   ALL=(ALL)     NOPASSWD:ALL</span><br></pre></td></tr></table></figure></li><li><p><strong>在&#x2F;opt目录下创建文件夹，并修改所属主和所属组</strong></p><p>（1）在&#x2F;opt目录下创建module、software文件夹</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# mkdir /opt/module</span><br><span class="line">[root@hadoop100 ~]# mkdir /opt/software</span><br></pre></td></tr></table></figure><p>   （2）修改module、software文件夹的所有者和所属组均为atguigu用户 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# chown atguigu:atguigu /opt/module </span><br><span class="line">[root@hadoop100 ~]# chown atguigu:atguigu /opt/software</span><br></pre></td></tr></table></figure><p>   （3）查看module、software文件夹的所有者和所属组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# cd /opt/</span><br><span class="line">[root@hadoop100 opt]# ll</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月  28 17:18 module</span><br><span class="line">drwxr-xr-x. 2 root    root    4096 9月   7 2017 rh</span><br><span class="line">drwxr-xr-x. 2 atguigu atguigu 4096 5月  28 17:18 software</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>卸载虚拟机自带的open JDK</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# rpm -qa | grep -i java | xargs -n1 rpm -e --nodeps</span><br></pre></td></tr></table></figure><p>模板机子创建好了之后，我们就可以直接克隆虚拟机，克隆后只需要改静态IP以及主机名就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 离线数仓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离线数仓 </tag>
            
            <tag> 手动分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop各种概念介绍</title>
      <link href="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Hadoop的优势是什么？"><a href="#1-Hadoop的优势是什么？" class="headerlink" title="1.Hadoop的优势是什么？"></a>1.Hadoop的优势是什么？</h2><ol><li>高可靠性：Hadoop底层会维度多个数据副本，即使Hadoop某个存储出现故障，也不会导致数据的丢失</li><li>高扩展性：在集群之间分配任务数据，可以十分方便的扩展数以千计的节点</li><li>高效性：在MR的思想下，Hadoop处理问题的策略是并行的，可以加快任务处理的速度</li><li>高容错性：能够自动把失败的任务重新分配</li></ol><h2 id="2-Hadoop1版本和Hadoop2版本的区别？"><a href="#2-Hadoop1版本和Hadoop2版本的区别？" class="headerlink" title="2.Hadoop1版本和Hadoop2版本的区别？"></a>2.Hadoop1版本和Hadoop2版本的区别？</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661652672746.png" alt="1661652672746"></p><p>在Hadoop1版本的时候，计算和资源调度都是由MR来实现，耦合性太高，在Hadoop2版本增加了Yarn资源调度模块，MR仅仅负责计算</p><h2 id="3-HDFS架构简述？"><a href="#3-HDFS架构简述？" class="headerlink" title="3.HDFS架构简述？"></a>3.HDFS架构简述？</h2><ol><li>NameNode：存储文件的元数据信息，如文件名，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表，还有每个文件所在的块列表和块所在的DateNode等等</li><li>DataNode: 在本地文件系统存储文件快数据，以及块数据的校验和</li><li>Secondary NameNode：每隔一段时间就会对NameNode元数据进行备份，但是是冷备份，治标不治本。</li></ol><h2 id="4-Yarn架构简述？"><a href="#4-Yarn架构简述？" class="headerlink" title="4.Yarn架构简述？"></a>4.Yarn架构简述？</h2><ol><li>ResourceManager: 处理客户端请求、监控NodeManager、启动或者监控ApplicationMaster、资源的分配与调度</li><li>NodeManager: 管理单个节点上的资源、处理来自ResourceManager的命令、处理来自ApplicationMaster的命令</li><li>ApplicationMaster：负责数据的切分、为应用程序申请资源并分配给内部的任务、任务的监控与容错</li><li>Container：他是YARN的资源抽象，封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等等</li></ol><h2 id="5-为什么HDFS文件块设置为128MB？"><a href="#5-为什么HDFS文件块设置为128MB？" class="headerlink" title="5.为什么HDFS文件块设置为128MB？"></a>5.为什么HDFS文件块设置为128MB？</h2><p><a href="https://so.csdn.net/so/search?q=HDFS&spm=1001.2101.3001.7020">HDFS</a>中的文件在物理上是分块存储（<code>Block</code>），块的大小可以通过配置参数(<code>dfs.blocksize</code>）来规定，默认大小在Hadoop2.x版本中是128M，老版本中是64M。</p><p>默认为128M的原因，基于最佳传输损耗理论！</p><p>不论对磁盘的文件进行读还是写，都需要先进行寻址！</p><p>最佳传输损耗理论：在一次传输中，寻址时间占用总传输时间的1%时，本次传输的损耗最小，为最佳性价比传输！<br>目前硬件的发展条件，普通磁盘写的速率大概为100M&#x2F;S, 寻址时间一般为10ms!</p><p><code>10ms / 1% = 1s</code><br><code>1s * 100M/S=100M</code></p><p>块在传输时，<code>每64K还需要校验一次</code>，因此块大小，必须为<code>2的n次方</code>，最接近100M的就是128M！</p><p><strong>为什么块的大小不能设置太小，也不能设置太大？</strong></p><ol><li><p>如果块设置过大，</p><p> 一方面，从磁盘传输数据的时间会明显大于寻址时间，导致程序在处理这块数据时，变得非常慢；</p><p> 另一方面，mapreduce中的map任务通常一次只处理一个块中的数据，如果块过大运行速度也会很慢。</p></li><li><p>如果块设置过小，</p><p>一方面存放大量小文件会占用NameNode中大量内存来存储元数据，而NameNode的内存是有限的，不可取；</p><p>另一方面文件块过小，寻址时间增大，导致程序一直在找block的开始位置。</p></li></ol><p>因而，块适当设置大一些，减少寻址时间，那么传输一个由多个块组成的文件的时间主要取决于磁盘的传输速率。</p><h2 id="6-HDFS的写流程"><a href="#6-HDFS的写流程" class="headerlink" title="6.HDFS的写流程"></a>6.HDFS的写流程</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661661770326.png" alt="1661661770326"></p><ol><li>客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。</li><li>NameNode返回是否可以上传。</li><li>客户端请求第一个 Block上传到哪几个DataNode服务器上。</li><li>NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。</li><li>客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。</li><li>dn1、dn2、dn3逐级应答客户端。</li><li>客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。</li><li>当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。</li></ol><h3 id="6-1-节点距离计算？"><a href="#6-1-节点距离计算？" class="headerlink" title="6.1 节点距离计算？"></a>6.1 节点距离计算？</h3><p>在HDFS写数据的过程中，NameNode会选择距离待上传数据最近距离的DataNode接收数据。那么这个最近距离怎么计算呢？</p><p>节点距离：两个节点到达最近的共同祖先的距离总和。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661661934358.png" alt="1661661934358"></p><h3 id="6-2Hadoop副本节点选择策略"><a href="#6-2Hadoop副本节点选择策略" class="headerlink" title="6.2Hadoop副本节点选择策略"></a>6.2Hadoop副本节点选择策略</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661662094057.png" alt="1661662094057"></p><h2 id="7-HDFS读数据流程"><a href="#7-HDFS读数据流程" class="headerlink" title="7.HDFS读数据流程"></a>7.HDFS读数据流程</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661662132533.png" alt="1661662132533"></p><ol><li>客户端通过DistributedFileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。</li><li>挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。</li><li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。</li><li>客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。</li></ol><h2 id="8-NameNode和SecondaryNameNode"><a href="#8-NameNode和SecondaryNameNode" class="headerlink" title="8.NameNode和SecondaryNameNode"></a>8.NameNode和SecondaryNameNode</h2><h3 id="8-1-NN和2NN的工作机制"><a href="#8-1-NN和2NN的工作机制" class="headerlink" title="8.1 NN和2NN的工作机制"></a>8.1 NN和2NN的工作机制</h3><p>​思考：NameNode中的元数据存储在哪里？</p><p>​首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。</p><p>​这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</p><p>​但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。</p><hr><p><strong>NameNode工作机制</strong></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661669014177.png" alt="1661669014177"></p><p><strong>第一阶段：NameNode启动</strong></p><ol><li>第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</li><li>客户端对元数据进行增删改的请求。</li><li>NameNode记录操作日志，更新滚动日志。</li><li>NameNode在内存中对元数据进行增删改。</li></ol><p><strong>第二阶段：SecondaryNameNode</strong></p><ol><li>Secondary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。</li><li>Secondary NameNode请求执行CheckPoint。</li><li>NameNode滚动正在写的Edits日志。</li><li>将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。</li><li>Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</li><li>生成新的镜像文件fsimage.chkpoint。</li><li>拷贝fsimage.chkpoint到NameNode。</li><li>NameNode将fsimage.chkpoint重新命名成fsimage。</li></ol><p><strong>NN和2NN的工作机制详解：</strong></p><p>Fsimage：NameNode内存中元数据序列化后形成的文件。</p><p>Edits：记录客户端更新元数据信息的每一步操作（可通过Edits运算出元数据）。</p><p>​NameNode启动时，先滚动Edits并生成一个空的edits.inprogress，然后加载Edits和Fsimage到内存中，此时NameNode内存就持有最新的元数据信息。Client开始对NameNode发送元数据的增删改的请求，这些请求的操作首先会被记录到edits.inprogress中（查询元数据的操作不会被记录在Edits中，因为查询操作不会更改元数据信息），如果此时NameNode挂掉，重启后会从Edits中读取元数据的信息。然后，NameNode会在内存中执行元数据的增删改的操作。</p><p>​由于Edits中记录的操作会越来越多，Edits文件会越来越大，导致NameNode在启动加载Edits时会很慢，所以需要对Edits和Fsimage进行合并（所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage）。SecondaryNameNode的作用就是帮助NameNode进行Edits和Fsimage的合并工作。</p><p>​SecondaryNameNode首先会询问NameNode是否需要CheckPoint（触发CheckPoint需要满足两个条件中的任意一个，定时时间到和Edits中数据写满了）。直接带回NameNode是否检查结果。SecondaryNameNode执行CheckPoint操作，首先会让NameNode滚动Edits并生成一个空的edits.inprogress，滚动Edits的目的是给Edits打个标记，以后所有新的操作都写入edits.inprogress，其他未合并的Edits和Fsimage会拷贝到SecondaryNameNode的本地，然后将拷贝的Edits和Fsimage加载到内存中进行合并，生成fsimage.chkpoint，然后将fsimage.chkpoint拷贝给NameNode，重命名为Fsimage后替换掉原来的Fsimage。NameNode在启动时就只需要加载之前未合并的Edits和Fsimage即可，因为合并过的Edits中的元数据信息已经被记录在Fsimage中。</p><h3 id="8-2CheckPoint时间设置"><a href="#8-2CheckPoint时间设置" class="headerlink" title="8.2CheckPoint时间设置"></a>8.2CheckPoint时间设置</h3><ol><li>通常情况下，SecondaryNameNode每隔一小时执行一次。</li><li>一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次。</li></ol><h3 id="8-3集群的安全模式"><a href="#8-3集群的安全模式" class="headerlink" title="8.3集群的安全模式"></a>8.3集群的安全模式</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661670551060.png" alt="1661670551060"></p><h2 id="9-DataNode"><a href="#9-DataNode" class="headerlink" title="9.DataNode"></a>9.DataNode</h2><h3 id="9-1DataNode工作机制"><a href="#9-1DataNode工作机制" class="headerlink" title="9.1DataNode工作机制"></a>9.1DataNode工作机制</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661670644724.png" alt="1661670644724"></p><ol><li>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。</li><li>DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。</li><li>心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。</li><li>集群运行中可以安全加入和退出一些机器。</li></ol><h3 id="9-2DataNode检测数据完整性"><a href="#9-2DataNode检测数据完整性" class="headerlink" title="9.2DataNode检测数据完整性"></a>9.2DataNode检测数据完整性</h3><p>（1）当DataNode读取Block的时候，它会计算CheckSum。</p><p>（2）如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏。</p><p>（3）Client读取其他DataNode上的Block。</p><p>（4）常见的校验算法 crc（32），md5（128），sha1（160）</p><p>（5）DataNode在其文件创建后周期验证CheckSum。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661671111412.png" alt="1661671111412"></p><h3 id="9-3DataNode掉线死亡时间的设置"><a href="#9-3DataNode掉线死亡时间的设置" class="headerlink" title="9.3DataNode掉线死亡时间的设置"></a>9.3DataNode掉线死亡时间的设置</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661671219667.png" alt="1661671219667"></p><p>​需要注意的是hdfs-site.xml 配置文件中的heartbeat.recheck.interval的单位为毫秒，dfs.heartbeat.interval的单位为秒。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.heartbeat.recheck-interval&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;300000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.heartbeat.interval&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h2 id="10-描述一下手写MR程序的大概流程和规范？"><a href="#10-描述一下手写MR程序的大概流程和规范？" class="headerlink" title="10.描述一下手写MR程序的大概流程和规范？"></a>10.描述一下手写MR程序的大概流程和规范？</h2><p>​首先，从MapReduce程序的结构划分可以分为三部分，第一是 程序的执行入口通常简称为驱动类，驱动类主要编写MR作业的提交流程以及自定义的一些配置项。第二是 Map阶段的核心类需要自定并且继承Hadoop提供的Mapper类，重写Mapper类中的map方法，在map方法中遍写自己的业务逻辑代码将数据处理后利用context 上下文对象的写出落盘。第三是 Reduce阶段的核心类同时也需要继承Hadoop提供的Reducer类，并重写reduce 方法，在reduce方法中编写自己的业务逻辑代码，处理完数据后也是通过context上下文对象将数据写出，这也就是最终的结果文件。</p><h2 id="11-如何实现Hadoop中的序列化，以及和Java序列化的区别"><a href="#11-如何实现Hadoop中的序列化，以及和Java序列化的区别" class="headerlink" title="11.如何实现Hadoop中的序列化，以及和Java序列化的区别"></a>11.如何实现Hadoop中的序列化，以及和Java序列化的区别</h2><p>​首先序列化是把内存中的Java对象转化成二进制字节码，反序列化是将二进制字节码转化成Java对象，通常我们在对Java对象进行磁盘持久化写入或者将Java对象作为数据进行网络传输的时候需要进行序列化，相反如果要将J数据从磁盘读出并转化成Java对象需要进行反序列化。实现Hadoop中的序列化需要让JavaBean对象实现Writable接口，并重写write() 方法和readFields()方法，其中write()方法是序列化方法，readFields()方法是反序列化方法。</p><p>​Hadoop序列化和Java序列化的区别在于，Java序列化更重量级，Java序列化的后的结果不仅仅生成二进制字节码文件，同时还会针对当前Java对象生成对应的检验信息以及集成体系结构，这样的话 无形中我们需要维护更多的数据，但是Hadoop序列化不会产生除了Java对象内部属性外的任何信息，整体内容更加简洁紧凑，读写速度相应也会提升很多，这也符合了大数据的处理背景。</p><h2 id="12-描述一下MR程序的执行逻辑"><a href="#12-描述一下MR程序的执行逻辑" class="headerlink" title="12.描述一下MR程序的执行逻辑"></a>12.描述一下MR程序的执行逻辑</h2><p>​简单的描述，MR程序执行先从InputFormat类说起，由InputFormat负责数据读入，并在内部实现切片，每一个切片的数据对应生成一个MapTask任务，MapTask中按照文件的行逐行数据进行处理，每一行数据会调用一次我们自定义的Mapper类的map方法，map方法内部实现具体的业务逻辑，处理完数据会通过context对象将数据写出到磁盘（此处会经历Shuffle过程），接下来ReduceTask会开始执行，首先ReduceTask会将MapTask处理完的数据结果拷贝过来，每一组相同key的values会会调用一次我们自定的Reducer类的reduce方法，当数据处理完成后，会通过context对象将数据结果写出到磁盘上。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661675103915.png" alt="1661675103915"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661675627909.png" alt="1661675627909"></p><p>上面的流程是整个MapReduce最全工作流程，但是Shuffle过程只是从第7步开始到第16步结束，具体Shuffle过程详解，如下：</p><p>（1）MapTask收集我们的map()方法输出的kv对，放到内存缓冲区中</p><p>（2）从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件</p><p>（3）多个溢出文件会被合并成大的溢出文件</p><p>（4）在溢出过程及合并的过程中，都要调用Partitioner进行分区和针对key进行排序</p><p>（5）ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据</p><p>（6）ReduceTask会抓取到同一个分区的来自不同MapTask的结果文件，ReduceTask会将这些文件再进行合并（归并排序）</p><p>（7）合并成大文件后，Shuffle的过程也就结束了，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Group，调用用户自定义的reduce()方法）</p><p><strong>注意：</strong></p><p>（1）Shuffle中的缓冲区大小会影响到MapReduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。</p><p>（2）缓冲区的大小可以通过参数调整，参数：mapreduce.task.io.sort.mb默认100M</p><h2 id="13-描述一下切片逻辑"><a href="#13-描述一下切片逻辑" class="headerlink" title="13.描述一下切片逻辑"></a>13.描述一下切片逻辑</h2><p>​MR中的切片是发生在数据读入的阶段中，所以我们要关注InputFormat的实现，通过追溯源码，在InputFormat这个抽象类中有一个getSplits(),这个方法就是我们实现切片的具体逻辑。首先我们先关注两个变量，分别是 minSize 和 maxSize，通过对源码的跟踪默认情况 minSize &#x3D; 1，maxSize &#x3D; Long.MAX_VALUE，源码中声明了一个集合List<InputSplit> splits &#x3D; new ArrayList<InputSplit>();，用于装载将来的切片对象并返回。接下来我们根据提交的job信息获取到当前要进行切片的文件详情，首先判断点前文件是否可以进行切分，这一步主要考虑到一些不支持切分的压缩文件时不能进行切片操作，否则就破坏了数据的完整性，如果当前文件可以切片的话，那么接下来就要计算切片的大小，计算切片大小一共需要三个因子，分别是minSize 、maxSize 、blocksize ，最后通过Math.max(minSize, Math.min(maxSize, blockSize)); 计算逻辑获取到切片大小，默认情况切片大小和数据库块大小一致，如果我们想改变切片大小可以通过修改一下两个配置参数实现 mapreduce.input.fileinputformat.split.minsize mapreduce.input.fileinputformat.split.maxsize，</p><p>如果把切片大小调大改mapreduce.input.fileinputformat.split.minsize<br>如果把切片大小调小改mapreduce.input.fileinputformat.split.maxsize。</p><p>​当我们可以获取到切片大小后就可以继续往下执行，在最终完成切片之前还有一个关键判断，就是判断剩余文件是否要继续进行切片，如果剩余文件&#x2F;切片大小&gt;1.1 那就继续切片，否则就不会再进行切片，这个规则考虑的情况就就是让将来的切片尽可能资源使用均衡，不至于很小的文件内容也开启一个MapTask。到此整个切片规则就表述完毕了！</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661674494603.png" alt="1661674494603"></p><h2 id="14-CombineTextInputFormat切片机制"><a href="#14-CombineTextInputFormat切片机制" class="headerlink" title="14.CombineTextInputFormat切片机制"></a>14.CombineTextInputFormat切片机制</h2><p>​框架默认的TextInputFormat切片机制是对任务按文件规划切片，不管文件多小，都会是一个单独的切片，都会交给一个MapTask，这样如果有大量小文件，就会产生大量的MapTask，处理效率极其低下。</p><p>​CombineTextInputFormat用于小文件过多的场景，它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个MapTask处理。</p><p>​CombineTextInputFormat.setMaxInputSplitSize(job, 4194304);&#x2F;&#x2F; 4m</p><p>​注意：虚拟存储切片最大值设置最好根据实际的小文件大小情况来设置具体的值。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661674832817.png" alt="1661674832817"></p><p>​将输入目录下所有文件大小，依次和设置的setMaxInputSplitSize值比较，如果不大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍，那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值2倍，此时将文件均分成2个虚拟存储块（防止出现太小切片）。</p><p>​例如setMaxInputSplitSize值为4M，输入文件大小为8.02M，则先逻辑上分成一个4M。剩余的大小为4.02M，如果按照4M逻辑划分，就会出现0.02M的小的虚拟存储文件，所以将剩余的4.02M文件切分成（2.01M和2.01M）两个文件。</p><h2 id="15-MR中的shuffle机制"><a href="#15-MR中的shuffle机制" class="headerlink" title="15.MR中的shuffle机制"></a>15.MR中的shuffle机制</h2><h3 id="15-1概述"><a href="#15-1概述" class="headerlink" title="15.1概述"></a>15.1概述</h3><p>​Map方法之后，Reduce方法之前的数据处理过程称之为Shuffle。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661675886296.png" alt="1661675886296"></p><h3 id="15-2Partion分区"><a href="#15-2Partion分区" class="headerlink" title="15.2Partion分区"></a>15.2Partion分区</h3><p>默认的分区是根据key的hashcode对于ReduceTask的数量取余得到的，用户没办法指定key在哪一个分区</p><p><strong>自定义Partition步骤：</strong></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661676742763.png" alt="1661676742763"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661676800867.png" alt="1661676800867"></p><h3 id="15-3WritableComparable排序"><a href="#15-3WritableComparable排序" class="headerlink" title="15.3WritableComparable排序"></a>15.3WritableComparable排序</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661676891089.png" alt="1661676891089"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661676953729.png" alt="1661676953729"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661676989320.png" alt="1661676989320"></p><p><strong>自定义排序WritableComparable原理分析</strong></p><p>bean对象做为key传输，需要实现WritableComparable接口重写compareTo方法，就可以实现排序。</p><h3 id="15-3Combiner"><a href="#15-3Combiner" class="headerlink" title="15.3Combiner"></a>15.3Combiner</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661677337910.png" alt="1661677337910"></p><h2 id="16-MapTask的工作机制"><a href="#16-MapTask的工作机制" class="headerlink" title="16.MapTask的工作机制"></a>16.MapTask的工作机制</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661677599289.png" alt="1661677599289"></p><p>​（1）Read阶段：MapTask通过InputFormat获得的RecordReader，从输入InputSplit中解析出一个个key&#x2F;value。</p><p>​       （2）Map阶段：该节点主要是将解析出的key&#x2F;value交给用户编写map()函数处理，并产生一系列新的key&#x2F;value。</p><p>​       （3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key&#x2F;value分区（调用Partitioner），并写入一个环形内存缓冲区中。</p><p>​       （4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</p><p>​       溢写阶段详情：</p><p>​       步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号Partition进行排序，然后按照key进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照key有序。</p><p>​       步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件output&#x2F;spillN.out（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。</p><p>​       步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件output&#x2F;spillN.out.index中。</p><p>​       （5）Merge阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</p><p>​       当所有数据处理完后，MapTask会将所有临时文件合并成一个大文件，并保存到文件output&#x2F;file.out中，同时生成相应的索引文件output&#x2F;file.out.index。</p><p>​       在进行文件合并过程中，MapTask以分区为单位进行合并。对于某个分区，它将采用多轮递归合并的方式。每轮合并mapreduce.task.io.sort.factor（默认10）个文件，并将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。</p><p>​       让每个MapTask最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销。</p><h2 id="17-ReduceTask的工作机制"><a href="#17-ReduceTask的工作机制" class="headerlink" title="17.ReduceTask的工作机制"></a>17.ReduceTask的工作机制</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661677648908.png" alt="1661677648908"></p><p>​       （1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p><p>​       （2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</p><p>​       （3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。</p><p>​       （4）Reduce阶段：reduce()函数将计算结果写到HDFS上。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661677707796.png" alt="1661677707796"></p><h2 id="18-Map-Join-和Reduce-Join"><a href="#18-Map-Join-和Reduce-Join" class="headerlink" title="18.Map Join 和Reduce Join"></a>18.Map Join 和Reduce Join</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661678941793.png" alt="1661678941793"></p><p>​Map Join适用于一张表十分小、一张表很大的场景。</p><h2 id="19-Yarn的工作机制"><a href="#19-Yarn的工作机制" class="headerlink" title="19.Yarn的工作机制"></a>19.Yarn的工作机制</h2><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661679074675.png" alt="1661679074675"></p><p>​（1）MR程序提交到客户端所在的节点。</p><p>​       （2）YarnRunner向ResourceManager申请一个Application。</p><p>​       （3）RM将该应用程序的资源路径返回给YarnRunner。</p><p>​       （4）该程序将运行所需资源提交到HDFS上。</p><p>​       （5）程序资源提交完毕后，申请运行mrAppMaster。</p><p>​       （6）RM将用户的请求初始化成一个Task。</p><p>​       （7）其中一个NodeManager领取到Task任务。</p><p>​       （8）该NodeManager创建容器Container，并产生MRAppmaster。</p><p>​       （9）Container从HDFS上拷贝资源到本地。</p><p>​       （10）MRAppmaster向RM 申请运行MapTask资源。</p><p>​       （11）RM将运行MapTask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。</p><p>​       （12）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。</p><p>​（13）MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。</p><p>​       （14）ReduceTask向MapTask获取相应分区的数据。</p><p>​       （15）程序运行完毕后，MR会向RM申请注销自己。</p><hr><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661679214814.png" alt="1661679214814"></p><p>作业提交全过程详解</p><p>（1）作业提交</p><p>第1步：Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业。</p><p>第2步：Client向RM申请一个作业id。</p><p>第3步：RM给Client返回该job资源的提交路径和作业id。</p><p>第4步：Client提交jar包、切片信息和配置文件到指定的资源提交路径。</p><p>第5步：Client提交完资源后，向RM申请运行MrAppMaster。</p><p>（2）作业初始化</p><p>第6步：当RM收到Client的请求后，将该job添加到容量调度器中。</p><p>第7步：某一个空闲的NM领取到该Job。</p><p>第8步：该NM创建Container，并产生MRAppmaster。</p><p>第9步：下载Client提交的资源到本地。</p><p>（3）任务分配</p><p>第10步：MrAppMaster向RM申请运行多个MapTask任务资源。</p><p>第11步：RM将运行MapTask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。</p><p>（4）任务运行</p><p>第12步：MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。</p><p>第13步：MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。</p><p>第14步：ReduceTask向MapTask获取相应分区的数据。</p><p>第15步：程序运行完毕后，MR会向RM申请注销自己。</p><p>（5）进度和状态更新</p><p>YARN中的任务将其进度和状态(包括counter)返回给应用管理器, 客户端每秒(通过mapreduce.client.progressmonitor.pollinterval设置)向应用管理器请求进度更新, 展示给用户。</p><p>（6）作业完成</p><p>除了向应用管理器请求作业进度外, 客户端每5秒都会通过调用waitForCompletion()来检查作业是否完成。时间间隔可以通过mapreduce.client.completion.pollinterval来设置。作业完成之后, 应用管理器和Container会清理工作状态。作业的信息会被作业历史服务器存储以备之后用户核查。</p><h2 id="20-Hadoop中的作业调度器"><a href="#20-Hadoop中的作业调度器" class="headerlink" title="20.Hadoop中的作业调度器"></a>20.Hadoop中的作业调度器</h2><p>​目前，Hadoop作业调度器主要有三种：FIFO、Capacity Scheduler和Fair Scheduler。Hadoop3.1.3默认的资源调度器是Capacity Scheduler。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661679354061.png" alt="1661679354061"></p><p>​Hadoop最初设计目的是支持大数据批处理作业，如日志挖掘、Web索引等作业，</p><p>​为此，Hadoop仅提供了一个非常简单的调度机制：FIFO，即先来先服务，在该调度机制下，所有作业被统一提交到一个队列中，Hadoop按照提交顺序依次运行这些作业。</p><p>​但随着Hadoop的普及，单个Hadoop集群的用户量越来越大，不同用户提交的应用程序往往具有不同的服务质量要求，典型的应用有以下几种：</p><p>​批处理作业：这种作业往往耗时较长，对时间完成一般没有严格要求，如数据挖掘、机器学习等方面的应用程序。</p><p>​交互式作业：这种作业期望能及时返回结果，如SQL查询（Hive）等。</p><p>​生产性作业：这种作业要求有一定量的资源保证，如统计值计算、垃圾数据分析等。</p><p>​此外，这些应用程序对硬件资源需求量也是不同的，如过滤、统计类作业一般为CPU密集型作业，而数据挖掘、机器学习作业一般为I&#x2F;O密集型作业。因此，简单的FIFO调度策略不仅不能满足多样化需求，也不能充分利用硬件资源。</p><hr><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661679393543.png" alt="1661679393543"></p><p>​Capacity Scheduler Capacity Scheduler 是Yahoo开发的多用户调度器，它以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用。而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。</p><p>​总之，Capacity Scheduler 主要有以下几个特点：</p><p>​①容量保证。管理员可为每个队列设置资源最低保证和资源使用上限，而所有提交到该队列的应用程序共享这些资源。</p><p>​②灵活性，如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用程序提交，则其他队列借调的资源会归还给该队列。这种资源灵活分配的方式可明显提高资源利用率。</p><p>​③多重租赁。支持多用户共享集群和多应用程序同时运行。为防止单个应用程序、用户或者队列独占集群中的资源，管理员可为之增加多重约束（比如单个应用程序同时运行的任务数等）。</p><p>​④安全保证。每个队列有严格的ACL列表规定它的访问用户，每个用户可指定哪些用户允许查看自己应用程序的运行状态或者控制应用程序（比如杀死应用程序）。此外，管理员可指定队列管理员和集群系统管理员。</p><p>​⑤动态更新配置文件。管理员可根据需要动态修改各种配置参数，以实现在线集群管理。</p><h2 id="21-Hadoop的数据压缩"><a href="#21-Hadoop的数据压缩" class="headerlink" title="21.Hadoop的数据压缩"></a>21.Hadoop的数据压缩</h2><h3 id="21-1概述"><a href="#21-1概述" class="headerlink" title="21.1概述"></a>21.1概述</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686071085.png" alt="1661686071085"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686077793.png" alt="1661686077793"></p><h3 id="21-2MR支持的压缩编码"><a href="#21-2MR支持的压缩编码" class="headerlink" title="21.2MR支持的压缩编码"></a>21.2MR支持的压缩编码</h3><table><thead><tr><th>压缩格式</th><th>hadoop自带？</th><th>算法</th><th>文件扩展名</th><th>是否可切分</th><th>换成压缩格式后，原来的程序是否需要修改</th></tr></thead><tbody><tr><td>DEFLATE</td><td>是，直接使用</td><td>DEFLATE</td><td>.deflate</td><td>否</td><td>和文本处理一样，不需要修改</td></tr><tr><td>Gzip</td><td>是，直接使用</td><td>DEFLATE</td><td>.gz</td><td>否</td><td>和文本处理一样，不需要修改</td></tr><tr><td>bzip2</td><td>是，直接使用</td><td>bzip2</td><td>.bz2</td><td>是</td><td>和文本处理一样，不需要修改</td></tr><tr><td>LZO</td><td>否，需要安装</td><td>LZO</td><td>.lzo</td><td>是</td><td>需要建索引，还需要指定输入格式</td></tr><tr><td>Snappy</td><td>是，直接使用</td><td>Snappy</td><td>.snappy</td><td>否</td><td>和文本处理一样，不需要修改</td></tr></tbody></table><p>为了支持多种压缩&#x2F;解压缩算法，Hadoop引入了编码&#x2F;解码器，如下表所示。</p><table><thead><tr><th>压缩格式</th><th>对应的编码&#x2F;解码器</th></tr></thead><tbody><tr><td>DEFLATE</td><td>org.apache.hadoop.io.compress.DefaultCodec</td></tr><tr><td>gzip</td><td>org.apache.hadoop.io.compress.GzipCodec</td></tr><tr><td>bzip2</td><td>org.apache.hadoop.io.compress.BZip2Codec</td></tr><tr><td>LZO</td><td>com.hadoop.compression.lzo.LzopCodec</td></tr><tr><td>Snappy</td><td>org.apache.hadoop.io.compress.SnappyCodec</td></tr></tbody></table><p>压缩性能的比较</p><table><thead><tr><th>压缩算法</th><th>原始文件大小</th><th>压缩文件大小</th><th>压缩速度</th><th>解压速度</th></tr></thead><tbody><tr><td>gzip</td><td>8.3GB</td><td>1.8GB</td><td>17.5MB&#x2F;s</td><td>58MB&#x2F;s</td></tr><tr><td>bzip2</td><td>8.3GB</td><td>1.1GB</td><td>2.4MB&#x2F;s</td><td>9.5MB&#x2F;s</td></tr><tr><td>LZO</td><td>8.3GB</td><td>2.9GB</td><td>49.3MB&#x2F;s</td><td>74.6MB&#x2F;s</td></tr></tbody></table><h3 id="21-3压缩方式的选择"><a href="#21-3压缩方式的选择" class="headerlink" title="21.3压缩方式的选择"></a>21.3压缩方式的选择</h3><h4 id="21-3-1Gzip压缩"><a href="#21-3-1Gzip压缩" class="headerlink" title="21.3.1Gzip压缩"></a>21.3.1Gzip压缩</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686251985.png" alt="1661686251985"></p><h4 id="21-3-2Bzip2压缩"><a href="#21-3-2Bzip2压缩" class="headerlink" title="21.3.2Bzip2压缩"></a>21.3.2Bzip2压缩</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686270207.png" alt="1661686270207"></p><h4 id="21-3-3Lzo压缩"><a href="#21-3-3Lzo压缩" class="headerlink" title="21.3.3Lzo压缩"></a>21.3.3Lzo压缩</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686290319.png" alt="1661686290319"></p><h4 id="21-3-4-Snappy压缩"><a href="#21-3-4-Snappy压缩" class="headerlink" title="21.3.4 Snappy压缩"></a>21.3.4 Snappy压缩</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686312779.png" alt="1661686312779"></p><h3 id="21-4压缩位置选择"><a href="#21-4压缩位置选择" class="headerlink" title="21.4压缩位置选择"></a>21.4压缩位置选择</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686358694.png" alt="1661686358694"></p><h3 id="21-5压缩参数配置"><a href="#21-5压缩参数配置" class="headerlink" title="21.5压缩参数配置"></a>21.5压缩参数配置</h3><p>​要在Hadoop中启用压缩，可以配置如下参数：</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686428791.png" alt="1661686428791"></p><h2 id="22-Hadoop企业优化"><a href="#22-Hadoop企业优化" class="headerlink" title="22.Hadoop企业优化"></a>22.Hadoop企业优化</h2><h3 id="22-1MapReduce跑的慢的原因"><a href="#22-1MapReduce跑的慢的原因" class="headerlink" title="22.1MapReduce跑的慢的原因"></a>22.1MapReduce跑的慢的原因</h3><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686500161.png" alt="1661686500161"></p><h3 id="22-2MapReduce优化方法"><a href="#22-2MapReduce优化方法" class="headerlink" title="22.2MapReduce优化方法"></a>22.2MapReduce优化方法</h3><p>​MapReduce优化方法主要从六个方面考虑：数据输入、Map阶段、Reduce阶段、IO传输、数据倾斜问题和常用的调优参数。</p><h4 id="22-2-1数据输入"><a href="#22-2-1数据输入" class="headerlink" title="22.2.1数据输入"></a>22.2.1数据输入</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686594807.png" alt="1661686594807"></p><h4 id="22-2-2Map阶段"><a href="#22-2-2Map阶段" class="headerlink" title="22.2.2Map阶段"></a>22.2.2Map阶段</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686606515.png" alt="1661686606515"></p><h4 id="22-2-3-Reduce阶段"><a href="#22-2-3-Reduce阶段" class="headerlink" title="22.2.3 Reduce阶段"></a>22.2.3 Reduce阶段</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686621134.png" alt="1661686621134"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686630210.png" alt="1661686630210"></p><h4 id="22-2-4IO阶段"><a href="#22-2-4IO阶段" class="headerlink" title="22.2.4IO阶段"></a>22.2.4IO阶段</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686637490.png" alt="1661686637490"></p><h4 id="22-2-5数据倾斜问题"><a href="#22-2-5数据倾斜问题" class="headerlink" title="22.2.5数据倾斜问题"></a>22.2.5数据倾斜问题</h4><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686653447.png" alt="1661686653447"></p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661686661689.png" alt="1661686661689"></p><h3 id="22-3常用的调优参数"><a href="#22-3常用的调优参数" class="headerlink" title="22.3常用的调优参数"></a>22.3常用的调优参数</h3><p>（1）以下参数是在用户自己的MR应用程序中配置就可以生效（mapred-default.xml）</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>mapreduce.map.memory.mb</td><td>一个MapTask可使用的资源上限（单位:MB），默认为1024。如果MapTask实际使用的资源量超过该值，则会被强制杀死。</td></tr><tr><td>mapreduce.reduce.memory.mb</td><td>一个ReduceTask可使用的资源上限（单位:MB），默认为1024。如果ReduceTask实际使用的资源量超过该值，则会被强制杀死。</td></tr><tr><td>mapreduce.map.cpu.vcores</td><td>每个MapTask可使用的最多cpu core数目，默认值: 1</td></tr><tr><td>mapreduce.reduce.cpu.vcores</td><td>每个ReduceTask可使用的最多cpu   core数目，默认值: 1</td></tr><tr><td>mapreduce.reduce.shuffle.parallelcopies</td><td>每个Reduce去Map中取数据的并行数。默认值是5</td></tr><tr><td>mapreduce.reduce.shuffle.merge.percent</td><td>Buffer中的数据达到多少比例开始写入磁盘。默认值0.66</td></tr><tr><td>mapreduce.reduce.shuffle.input.buffer.percent</td><td>Buffer大小占Reduce可用内存的比例。默认值0.7</td></tr><tr><td>mapreduce.reduce.input.buffer.percent</td><td>指定多少比例的内存用来存放Buffer中的数据，默认值是0.0</td></tr></tbody></table><p>（2）应该在YARN启动之前就配置在服务器的配置文件中才能生效（yarn-default.xml）</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>yarn.scheduler.minimum-allocation-mb</td><td>给应用程序Container分配的最小内存，默认值：1024</td></tr><tr><td>yarn.scheduler.maximum-allocation-mb</td><td>给应用程序Container分配的最大内存，默认值：8192</td></tr><tr><td>yarn.scheduler.minimum-allocation-vcores</td><td>每个Container申请的最小CPU核数，默认值：1</td></tr><tr><td>yarn.scheduler.maximum-allocation-vcores</td><td>每个Container申请的最大CPU核数，默认值：32</td></tr><tr><td>yarn.nodemanager.resource.memory-mb</td><td>给Containers分配的最大物理内存，默认值：8192</td></tr></tbody></table><p>（3）Shuffle性能优化的关键参数，应在YARN启动之前就配置好（mapred-default.xml）</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>mapreduce.task.io.sort.mb</td><td>Shuffle的环形缓冲区大小，默认100m</td></tr><tr><td>mapreduce.map.sort.spill.percent</td><td>环形缓冲区溢出的阈值，默认80%</td></tr></tbody></table><p>容错相关配置</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>mapreduce.map.maxattempts</td><td>每个Map Task最大重试次数，一旦重试次数超过该值，则认为Map Task运行失败，默认值：4。</td></tr><tr><td>mapreduce.reduce.maxattempts</td><td>每个Reduce Task最大重试次数，一旦重试次数超过该值，则认为Map Task运行失败，默认值：4。</td></tr><tr><td>mapreduce.task.timeout</td><td>Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个Task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该Task处于Block状态，可能是卡住了，也许永远会卡住，为了防止因为用户程序永远Block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000（10分钟）。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大，该参数过小常出现的错误提示是：“AttemptID:attempt_14267829456721_123456_m_000224_0 Timed out after   300 secsContainer killed by the ApplicationMaster.”。</td></tr></tbody></table><h3 id="22-4Hadoop小文件优化方法"><a href="#22-4Hadoop小文件优化方法" class="headerlink" title="22.4Hadoop小文件优化方法"></a>22.4Hadoop小文件优化方法</h3><h4 id="22-4-1Hadoop小文件弊端"><a href="#22-4-1Hadoop小文件弊端" class="headerlink" title="22.4.1Hadoop小文件弊端"></a>22.4.1Hadoop小文件弊端</h4><p>​HDFS上每个文件都要在NameNode上创建对应的元数据，这个元数据的大小约为150byte，这样当小文件比较多的时候，就会产生很多的元数据文件，一方面会大量占用NameNode的内存空间，另一方面就是元数据文件过多，使得寻址索引速度变慢。</p><p>​小文件过多，在进行MR计算时，会生成过多切片，需要启动过多的MapTask。每个MapTask处理的数据量小，导致MapTask的处理时间比启动时间还小，白白消耗资源。</p><h4 id="22-4-2Hadoop小文件解决方法"><a href="#22-4-2Hadoop小文件解决方法" class="headerlink" title="22.4.2Hadoop小文件解决方法"></a>22.4.2Hadoop小文件解决方法</h4><ol><li><pre><code>  小文件优化的方向：</code></pre></li></ol><p>（1）在数据采集的时候，就将小文件或小批数据合成大文件再上传HDFS。</p><p>（2）在业务处理之前，在HDFS上使用MapReduce程序对小文件进行合并。</p><p>（3）在MapReduce处理时，可采用CombineTextInputFormat提高效率。</p><p>（4）开启uber模式，实现jvm重用</p><ol start="2"><li><pre><code>  Hadoop Archive</code></pre></li></ol><p>是一个高效的将小文件放入HDFS块中的文件存档工具，能够将多个小文件打包成一个HAR文件，从而达到减少NameNode的内存使用</p><ol start="3"><li><pre><code>  SequenceFile</code></pre></li></ol><p>SequenceFile是由一系列的二进制k&#x2F;v组成，如果为key为文件名，value为文件内容，可将大批小文件合并成一个大文件</p><ol start="4"><li><pre><code>  CombineTextInputFormat</code></pre></li></ol><p>CombineTextInputFormat用于将多个小文件在切片过程中生成一个单独的切片或者少量的切片。 </p><ol start="5"><li><pre><code>  开启uber模式，实现jvm重用。默认情况下，每个Task任务都需要启动一个jvm来运行，如果Task任务计算的数据量很小，我们可以让同一个Job的多个Task运行在一个Jvm中，不必为每个Task都开启一个Jvm.</code></pre></li></ol><p>开启uber模式，在mapred-site.xml中添加如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  开启uber模式 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.job.ubertask.enable&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- uber模式中最大的mapTask数量，可向下修改  --&gt; </span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.job.ubertask.maxmaps&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;9&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- uber模式中最大的reduce数量，可向下修改 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.job.ubertask.maxreduces&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- uber模式中最大的输入数据量，默认使用dfs.blocksize 的值，可向下修改 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.job.ubertask.maxbytes&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h2 id="23-Hadoop3-x的新特性"><a href="#23-Hadoop3-x的新特性" class="headerlink" title="23.Hadoop3.x的新特性"></a>23.Hadoop3.x的新特性</h2><h3 id="23-1多NN的HA架构"><a href="#23-1多NN的HA架构" class="headerlink" title="23.1多NN的HA架构"></a>23.1多NN的HA架构</h3><p>​ HDFS NameNode高可用性的初始实现为单个活动NameNode和单个备用NameNode，将edits复制到三个JournalNode。该体系结构能够容忍系统中一个NN或一个JN的故障。</p><p>​但是，某些部署需要更高程度的容错能力。Hadoop3.x允许用户运行多个备用NameNode。例如，通过配置三个NameNode和五个JournalNode，群集能够容忍两个节点而不是一个节点的故障。</p><h3 id="23-2纠删码"><a href="#23-2纠删码" class="headerlink" title="23.2纠删码"></a>23.2纠删码</h3><pre><code> HDFS中的默认3副本方案在存储空间和其他资源（例如，网络带宽）中具有200％的开销。但是，对于I / O活动相对较低暖和冷数据集，在正常操作期间很少访问其他块副本，但仍会消耗与第一个副本相同的资源量。</code></pre><p>​ 纠删码（Erasure Coding）能够在不到50% 的数据冗余情况下提供和3副本相同的容错能力，因此，使用纠删码作为副本机制的改进是自然而然的。</p><p>​查看集群支持的纠删码策略：hdfs ec -listPolicies</p><h2 id="24-Hadoop-HA高可用"><a href="#24-Hadoop-HA高可用" class="headerlink" title="24.Hadoop HA高可用"></a>24.Hadoop HA高可用</h2><h3 id="24-1概述"><a href="#24-1概述" class="headerlink" title="24.1概述"></a>24.1概述</h3><p>（1）所谓HA（High Availablity），即高可用（7*24小时不中断服务）。</p><p>（2）实现高可用最关键的策略是消除单点故障。HA严格来说应该分成各个组件的HA机制：HDFS的HA和YARN的HA。</p><p>（3）Hadoop2.0之前，在HDFS集群中NameNode存在单点故障（SPOF）。</p><p>（4）NameNode主要在以下两个方面影响HDFS集群</p><p>​Ø  NameNode机器发生意外，如宕机，集群将无法使用，直到管理员重启</p><p>​Ø  NameNode机器需要升级，包括软件、硬件升级，此时集群也将无法使用</p><p>​</p><p>​HDFS HA功能通过配置Active&#x2F;Standby两个NameNodes实现在集群中对NameNode的热备来解决上述问题。如果出现故障，如机器崩溃或机器需要升级维护，这时可通过此种方式将NameNode很快的切换到另外一台机器。</p><h3 id="24-2工作原理"><a href="#24-2工作原理" class="headerlink" title="24.2工作原理"></a>24.2工作原理</h3><p>1）元数据管理方式需要改变</p><p>​内存中各自保存一份元数据；</p><p>​Edits日志只有Active状态的NameNode节点可以做写操作；</p><p>​所有的NameNode都可以读取Edits；</p><p>​共享的Edits放在一个共享存储中管理（qjournal和NFS两个主流实现）；</p><p>2）需要一个状态管理功能模块</p><p>​实现了一个zkfailover，常驻在每一个namenode所在的节点，每一个zkfailover负责监控自己所在NameNode节点，利用zk进行状态标识，当需要进行状态切换时，由zkfailover来负责切换，切换时需要防止brain split现象的发生。</p><p>3）必须保证两个NameNode之间能够ssh无密码登录</p><p>4）隔离（Fence），即同一时刻仅仅有一个NameNode对外提供服务</p><h3 id="24-3HDFS-HA自动故障转移工作机制"><a href="#24-3HDFS-HA自动故障转移工作机制" class="headerlink" title="24.3HDFS-HA自动故障转移工作机制"></a>24.3HDFS-HA自动故障转移工作机制</h3><p>自动故障转移为HDFS部署增加了两个新组件：ZooKeeper和ZKFailoverController（ZKFC）进程，如图3-20所示。ZooKeeper是维护少量协调数据，通知客户端这些数据的改变和监视客户端故障的高可用服务。HA的自动故障转移依赖于ZooKeeper的以下功能：</p><p><strong>1．故障检测</strong></p><p>集群中的每个NameNode在ZooKeeper中维护了一个会话，如果机器崩溃，ZooKeeper中的会话将终止，ZooKeeper通知另一个NameNode需要触发故障转移。</p><p><strong>2．现役NameNode选择</strong></p><p>ZooKeeper提供了一个简单的机制用于唯一的选择一个节点为active状态。如果目前现役NameNode崩溃，另一个节点可能从ZooKeeper获得特殊的排外锁以表明它应该成为现役NameNode。</p><p>ZKFC是自动故障转移中的另一个新组件，是ZooKeeper的客户端，也监视和管理NameNode的状态。每个运行NameNode的主机也运行了一个ZKFC进程，ZKFC负责：</p><p><strong>1）健康监测</strong></p><p>ZKFC使用一个健康检查命令定期地ping与之在相同主机的NameNode，只要该NameNode及时地回复健康状态，ZKFC认为该节点是健康的。如果该节点崩溃，冻结或进入不健康状态，健康监测器标识该节点为非健康的。</p><p><strong>2）ZooKeeper会话管理</strong></p><p>当本地NameNode是健康的，ZKFC保持一个在ZooKeeper中打开的会话。如果本地NameNode处于active状态，ZKFC也保持一个特殊的znode锁，该锁使用了ZooKeeper对短暂节点的支持，如果会话终止，锁节点将自动删除。</p><p><strong>3）基于ZooKeeper的选择</strong></p><p>如果本地NameNode是健康的，且ZKFC发现没有其它的节点当前持有znode锁，它将为自己获取该锁。如果成功，则它已经赢得了选择，并负责运行故障转移进程以使它的本地NameNode为Active。</p><p><img src="/2022/08/28/Hadoop/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/1661687659347.png" alt="1661687659347"></p>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MR </tag>
            
            <tag> HDFS </tag>
            
            <tag> Yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell的一些基本用法</title>
      <link href="/2022/08/27/shell/shell/"/>
      <url>/2022/08/27/shell/shell/</url>
      
        <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><h3 id="1-1基本规则"><a href="#1-1基本规则" class="headerlink" title="1.1基本规则"></a>1.1基本规则</h3><p>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</p><p>（2）等号两侧不能有空格</p><p>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</p><p>（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p><h3 id="1-2特殊变量"><a href="#1-2特殊变量" class="headerlink" title="1.2特殊变量"></a>1.2特殊变量</h3><h4 id="1-2-1-n"><a href="#1-2-1-n" class="headerlink" title="1.2.1$n"></a>1.2.1$n</h4><p>$n   （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ touch parameter.sh </span><br><span class="line">[atguigu@hadoop101 datas]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;$0  $1   $2&quot;</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ chmod 777 parameter.sh</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ ./parameter.sh cls  xz</span><br><span class="line">./parameter.sh  cls   xz</span><br></pre></td></tr></table></figure><h4 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2.2 $#"></a>1.2.2 $#</h4><p>$#      （功能描述：获取所有输入参数个数，常用于循环）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;$0  $1   $2&quot;</span><br><span class="line">echo $#</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ chmod 777 parameter.sh</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ ./parameter.sh cls  xz</span><br><span class="line">parameter.sh cls xz </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="1-2-3-、"><a href="#1-2-3-、" class="headerlink" title="1.2.3 $* 、$@"></a>1.2.3 $* 、$@</h4><p>$*   （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@  （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p><p> *<em>注意：如果想让$<em>和$@ 体现区别必须用双引号括起来才生效</em></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;$0  $1   $2&quot;</span><br><span class="line">echo $#</span><br><span class="line">echo $*</span><br><span class="line">echo $@</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ bash parameter.sh 1 2 3</span><br><span class="line">parameter.sh  1   2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p>$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n的形式输出所有参数。</p><p>当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输出所有参数；“$@”会将各个参数分开，以“$1” “$2”…”$n”的形式输出所有参数。</p><h4 id="1-2-4"><a href="#1-2-4" class="headerlink" title="1.2.4 $?"></a>1.2.4 $?</h4><p>$？  （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ ./helloworld.sh </span><br><span class="line">hello world</span><br><span class="line">[atguigu@hadoop101 datas]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2.条件判断"></a>2.条件判断</h2><p>（1）两个整数之间比较</p><p>&#x3D;&#x3D; 字符串比较</p><p>-lt 小于（less than）                  -le 小于等于（less equal）</p><p>-eq 等于（equal）                     -gt 大于（greater than）</p><p>-ge 大于等于（greater equal）   -ne 不等于（Not equal）</p><p>（2）按照文件权限进行判断</p><p>-r 有读的权限（read）              -w 有写的权限（write）</p><p>-x 有执行的权限（execute）</p><p>（3）按照文件类型进行判断</p><p>-f 文件存在并且是一个常规的文件（file）</p><p>-e 文件存在（existence）          -d 文件存在并是一个目录（directory）</p><h2 id="3-流程判断"><a href="#3-流程判断" class="headerlink" title="3.流程判断"></a>3.流程判断</h2><h3 id="3-1if判断"><a href="#3-1if判断" class="headerlink" title="3.1if判断"></a>3.1if判断</h3><p>输入一个数字，如果是1，则输出banzhang zhen shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ touch if.sh</span><br><span class="line">[atguigu@hadoop101 datas]$ vim if.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq &quot;1&quot; ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;banzhang zhen shuai&quot;</span><br><span class="line">elif [ $1 -eq &quot;2&quot; ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;cls zhen mei&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ chmod 777 if.sh </span><br><span class="line">[atguigu@hadoop101 datas]$ ./if.sh 1</span><br><span class="line">banzhang zhen shuai</span><br></pre></td></tr></table></figure><h3 id="3-2-case语句"><a href="#3-2-case语句" class="headerlink" title="3.2 case语句"></a>3.2 case语句</h3><p>输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ touch case.sh</span><br><span class="line">[atguigu@hadoop101 datas]$ vim case.sh</span><br><span class="line"></span><br><span class="line">!/bin/bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">        echo &quot;banzhang&quot;</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">&quot;2&quot;)</span><br><span class="line">        echo &quot;cls&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">        echo &quot;renyao&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ chmod 777 case.sh</span><br><span class="line">[atguigu@hadoop101 datas]$ ./case.sh 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="3-3-for循环"><a href="#3-3-for循环" class="headerlink" title="3.3 for循环"></a>3.3 for循环</h3><p>从1加到100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for((i=0;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">s=$[$s+$i]</span><br><span class="line">done</span><br><span class="line">echo $s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ touch for2.sh</span><br><span class="line">[atguigu@hadoop101 datas]$ vim for2.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印数字</span></span><br><span class="line"></span><br><span class="line">for i in $*</span><br><span class="line">    do</span><br><span class="line">      echo &quot;ban zhang love $i &quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ chmod 777 for2.sh </span><br><span class="line">[atguigu@hadoop101 datas]$ bash for2.sh cls xz bd</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love bd</span><br></pre></td></tr></table></figure><h3 id="3-4-while循环"><a href="#3-4-while循环" class="headerlink" title="3.4 while循环"></a>3.4 while循环</h3><p>从1加到100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ touch while.sh</span><br><span class="line">[atguigu@hadoop101 datas]$ vim while.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">        s=$[$s+$i]</span><br><span class="line">        i=$[$i+1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 datas]$ chmod 777 while.sh </span><br><span class="line">[atguigu@hadoop101 datas]$ ./while.sh </span><br><span class="line">5050</span><br></pre></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><h3 id="4-1-basename"><a href="#4-1-basename" class="headerlink" title="4.1 basename"></a>4.1 basename</h3><p>该函数的作用就是用来获取某一个路径下文件的名字，其实就是把最后一个&#x2F;字符后的字符串显示出来。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt </span><br><span class="line">banzhang.txt</span><br><span class="line">[atguigu@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure><h3 id="4-2-dirname"><a href="#4-2-dirname" class="headerlink" title="4.2 dirname"></a>4.2 dirname</h3><p>  dirname 文件绝对路径       （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt </span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure><h2 id="5-shell工具"><a href="#5-shell工具" class="headerlink" title="5.shell工具"></a>5.shell工具</h2><h3 id="5-1-cut"><a href="#5-1-cut" class="headerlink" title="5.1 cut"></a>5.1 cut</h3><p>​cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><p>cut [选项参数]  filename</p><p>说明：默认分隔符是制表符</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>列号，提取第几列</td></tr><tr><td>-d</td><td>分隔符，按照指定分隔符分割列</td></tr><tr><td>-c</td><td>指定具体的字符</td></tr></tbody></table><p>（1）数据准备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ touch cut.txt</span><br><span class="line">[atguigu@hadoop101 datas]$ vim cut.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line">le  le</span><br></pre></td></tr></table></figure><p>（2）切割cut.txt第一列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ cut -d &quot; &quot; -f 1 cut.txt </span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><p>（3）切割cut.txt第二、三列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ cut -d &quot; &quot; -f 2,3 cut.txt </span><br><span class="line">shen</span><br><span class="line">zhen</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><p>（4）在cut.txt文件中切割出guan</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ cat cut.txt | grep &quot;guan&quot; | cut -d &quot; &quot; -f 1</span><br><span class="line"></span><br><span class="line">guan</span><br></pre></td></tr></table></figure><p>（5）选取系统PATH变量值，第2个“：”开始后的所有路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 datas]$ echo $PATH</span><br><span class="line">/usr/lib64/qt3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</span><br><span class="line">[atguigu@hadoop102 datas]$ echo $PATH | cut -d: -f 2-</span><br><span class="line">/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</span><br></pre></td></tr></table></figure><h3 id="5-2-awk"><a href="#5-2-awk" class="headerlink" title="5.2 awk"></a>5.2 awk</h3><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><p>awk [选项参数] ‘pattern1{action1}  pattern2{action2}…’ filename</p><p>pattern：表示AWK在数据中查找的内容，就是匹配模式</p><p>action：在找到匹配内容时所执行的一系列命令</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件折分隔符</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><p>（1）数据准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ sudo cp /etc/passwd ./</span><br></pre></td></tr></table></figure><p>（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ awk -F: &#x27;/^root/&#123;print $7&#125;&#x27; passwd </span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>（3）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ awk -F: &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; passwd </span><br><span class="line"></span><br><span class="line">root,/bin/bash</span><br></pre></td></tr></table></figure><p>注意：只有匹配了pattern的行才会执行action</p><p>（4）只显示&#x2F;etc&#x2F;passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，&#x2F;bin&#x2F;zuishuai”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ awk -F : &#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27; passwd</span><br><span class="line">user, shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">bin,/sbin/nologin</span><br><span class="line">atguigu,/bin/bash</span><br><span class="line">dahaige,/bin/zuishuai</span><br></pre></td></tr></table></figure><p>注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p><p>（5）将passwd文件中的用户id增加数值1并输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ awk -v i=1 -F: &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数（行数）</td></tr><tr><td>NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ awk -F: &#x27;&#123;print &quot;filename:&quot;  FILENAME &quot;, linenumber:&quot; NR  &quot;,columns:&quot; NF&#125;&#x27; passwd </span><br><span class="line">filename:passwd, linenumber:1,columns:7</span><br><span class="line">filename:passwd, linenumber:2,columns:7</span><br><span class="line">filename:passwd, linenumber:3,columns:7</span><br></pre></td></tr></table></figure><p>查询cut.txt中空行所在的行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ awk &#x27;/^$/&#123;print NR&#125;&#x27; cut.txt </span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="5-3-sort"><a href="#5-3-sort" class="headerlink" title="5.3 sort"></a>5.3 sort</h3><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>依照数值的大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><p>（1）数据准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ touch sort.sh</span><br><span class="line">[atguigu@hadoop102 datas]$ vim sort.sh </span><br><span class="line">bb:40:5.4</span><br><span class="line">bd:20:4.2</span><br><span class="line">xz:50:2.3</span><br><span class="line">cls:10:3.5</span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure><p>（2）按照“：”分割后的第三列倒序排序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ sort -t : -nrk 3  sort.sh </span><br><span class="line">bb:40:5.4</span><br><span class="line">bd:20:4.2</span><br><span class="line">cls:10:3.5</span><br><span class="line">xz:50:2.3</span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure><h2 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6.正则表达式"></a>6.正则表达式</h2><p><strong>^</strong></p><p>该字符匹配一行的开头，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ cat /etc/passwd | grep ^a</span><br></pre></td></tr></table></figure><p>会匹配所以以a开头的行</p><p><strong>$</strong></p><p>该字符匹配一行的结束，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ cat /etc/passwd | grep t$</span><br></pre></td></tr></table></figure><p>会匹配出所有以t结尾的行</p><p><strong>^$同时出现代表匹配空行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt | grep -v &quot;^$&quot;  //这句话表示过滤test.txt文件内容中的所有空格并输出其他内容</span><br></pre></td></tr></table></figure><p><strong>.</strong></p><p>该字符匹配一个任意的字符，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ cat /etc/passwd | grep r..t</span><br></pre></td></tr></table></figure><p>会匹配包含rabt,rbbt,rxdt,root等的所有行</p><p><strong>*</strong></p><p>* 不单独使用，他和左边第一个字符连用，表示匹配上一个字符0次或多次，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ cat /etc/passwd | grep ro*t</span><br></pre></td></tr></table></figure><p>会匹配rt, rot, root, rooot, roooot等所有行</p><p>.*代表任意字符串</p><p><strong>[]</strong></p><p>[ ] 表示匹配某个范围内的一个字符，例如</p><p>[6,8]——匹配6或者8</p><p>[a-z]——匹配一个a-z之间的字符</p><p>[a-z]*—–匹配任意字母字符串</p><p>[a-c, e-f]-匹配a-c或者e-f之间的任意字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ cat /etc/passwd | grep r[a,b,c]*t</span><br></pre></td></tr></table></figure><p>会匹配rat, rbt, rabt, rbact等等所有行</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> awk </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用指令</title>
      <link href="/2022/08/27/Linux/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/08/27/Linux/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-帮助指令"><a href="#1-帮助指令" class="headerlink" title="1.帮助指令"></a>1.帮助指令</h2><h3 id="1-1-man-获得帮助信息"><a href="#1-1-man-获得帮助信息" class="headerlink" title="1.1 man 获得帮助信息"></a>1.1 man 获得帮助信息</h3><p><strong>基本用法</strong></p><p>man [命令或者配置文件]</p><p><strong>显示说明</strong></p><table><thead><tr><th>信息</th><th>功能</th></tr></thead><tbody><tr><td>NAME</td><td>命令的名称和单行描述</td></tr><tr><td>SYNOPSIS</td><td>怎样使用命令</td></tr><tr><td>DESCRIPTION</td><td>命令功能的深入讨论</td></tr><tr><td>EXAMPLES</td><td>怎样使用命令的例子</td></tr><tr><td>SEE ALSO</td><td>相关主题（通常是手册页）</td></tr></tbody></table><p><strong>实例操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure><h3 id="1-2-help获得shell内置命令的帮助信息"><a href="#1-2-help获得shell内置命令的帮助信息" class="headerlink" title="1.2 help获得shell内置命令的帮助信息"></a>1.2 help获得shell内置命令的帮助信息</h3><p><strong>基本语法</strong></p><p>help  命令</p><h3 id="1-3-常用快捷键"><a href="#1-3-常用快捷键" class="headerlink" title="1.3 常用快捷键"></a>1.3 常用快捷键</h3><table><thead><tr><th>常用快捷键</th><th>功能</th></tr></thead><tbody><tr><td>ctrl + c</td><td>停止进程</td></tr><tr><td>ctrl+l</td><td>清屏；彻底清屏是：reset</td></tr><tr><td>ctrl + q</td><td>退出</td></tr><tr><td>善于用tab键</td><td>提示(更重要的是可以防止敲错)</td></tr><tr><td>上下键</td><td>查找执行过的命令</td></tr><tr><td>ctrl +alt</td><td>linux和Windows之间切换</td></tr></tbody></table><h2 id="2-文件目录类"><a href="#2-文件目录类" class="headerlink" title="2.文件目录类"></a>2.文件目录类</h2><p>自己熟悉的一些指令就不再整理，记录一些自己没有掌握的指令</p><h3 id="2-1more-文件内容分屏查看器"><a href="#2-1more-文件内容分屏查看器" class="headerlink" title="2.1more 文件内容分屏查看器"></a>2.1more 文件内容分屏查看器</h3><p>​more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键，详见操作说明。</p><p><strong>基本用法</strong></p><p>more 要查看的文件</p><p><strong>操作说明</strong></p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键 (space)</td><td>代表向下翻一页；</td></tr><tr><td>Enter</td><td>代表向下翻『一行』；</td></tr><tr><td>q</td><td>代表立刻离开 more ，不再显示该文件内容。</td></tr><tr><td>Ctrl+F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl+B</td><td>返回上一屏</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><h3 id="2-2-less-分屏显示文件内容"><a href="#2-2-less-分屏显示文件内容" class="headerlink" title="2.2 less 分屏显示文件内容"></a>2.2 less 分屏显示文件内容</h3><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p><strong>基本用法</strong></p><p>less 要查看的文件</p><p><strong>操作用法</strong></p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻动一页；</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页；</td></tr><tr><td>&#x2F;字串</td><td>向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td></tr><tr><td>?字串</td><td>向上搜寻『字串』的功能；n：向上查找；N：向下查找；</td></tr><tr><td>q</td><td>离开 less 这个程序；</td></tr></tbody></table><h3 id="2-3-gt-输出重定向和-gt-gt-追加"><a href="#2-3-gt-输出重定向和-gt-gt-追加" class="headerlink" title="2.3 &gt; 输出重定向和 &gt;&gt; 追加"></a>2.3 &gt; 输出重定向和 &gt;&gt; 追加</h3><p><strong>基本语法:</strong></p><ol><li>ls -l &gt; 文件   （功能描述：把查询出来的列表内容写入到文件中去，覆盖写）</li><li>ls -al  &gt;&gt; 文件   （功能描述：把查询出来的列表内容写入到文件中去，追加写）</li><li>cat 文件1 &gt; 文件2     （功能描述：将文件1的内容覆盖到文件2）</li></ol><h3 id="2-4-history-查看以及执行过的历史命令"><a href="#2-4-history-查看以及执行过的历史命令" class="headerlink" title="2.4 history 查看以及执行过的历史命令"></a>2.4 history 查看以及执行过的历史命令</h3><p><strong>基本语法</strong>:</p><p>history</p><h2 id="3-时间日期类"><a href="#3-时间日期类" class="headerlink" title="3.时间日期类"></a>3.时间日期类</h2><h3 id="3-1date显示当前时间"><a href="#3-1date显示当前时间" class="headerlink" title="3.1date显示当前时间"></a>3.1date显示当前时间</h3><p><strong>基本用法：</strong></p><ul><li>date                                                       （功能描述：显示当前时间）</li><li>date +%Y                                               （功能描述：显示当前年份）</li><li>date +%m                                              （功能描述：显示当前月份）</li><li>date +%d                                               （功能描述：显示当前是哪一天）</li><li>date “+%Y-%m-%d %H:%M:%S”         （功能描述：显示年月日时分秒）</li></ul><h3 id="3-2date显示非当前时间"><a href="#3-2date显示非当前时间" class="headerlink" title="3.2date显示非当前时间"></a>3.2date显示非当前时间</h3><p><strong>基本用法：</strong></p><ul><li>date -d ‘1 days ago’               （功能描述：显示前一天时间）</li><li>date -d ‘-1 days ago’               （功能描述：显示后一天时间）</li></ul><p><img src="/2022/08/27/Linux/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/1661590484981.png" alt="1661590484981"></p><h3 id="3-3date设置系统时间"><a href="#3-3date设置系统时间" class="headerlink" title="3.3date设置系统时间"></a>3.3date设置系统时间</h3><p><strong>基本用法：</strong> </p><p>date -s 字符串时间</p><h3 id="3-4-cal查看日历"><a href="#3-4-cal查看日历" class="headerlink" title="3.4 cal查看日历"></a>3.4 cal查看日历</h3><p>基本用法：</p><ul><li>cal</li><li>cal   时间</li></ul><h2 id="4-用户管理命令"><a href="#4-用户管理命令" class="headerlink" title="4.用户管理命令"></a>4.用户管理命令</h2><h3 id="4-1-useradd添加新用户"><a href="#4-1-useradd添加新用户" class="headerlink" title="4.1 useradd添加新用户"></a>4.1 useradd添加新用户</h3><p><strong>基本用法：</strong></p><ul><li>useradd 用户名                   （功能描述：添加新用户）</li><li>useradd -g 组名 用户名      （功能描述：添加新用户到某个组）</li></ul><h3 id="4-2-passwd设置用户密码"><a href="#4-2-passwd设置用户密码" class="headerlink" title="4.2 passwd设置用户密码"></a>4.2 passwd设置用户密码</h3><p><strong>基本用法：</strong></p><p>​passwd 用户名     （功能描述：设置用户密码）</p><h3 id="4-3-su-切换用户"><a href="#4-3-su-切换用户" class="headerlink" title="4.3 su 切换用户"></a>4.3 su 切换用户</h3><p><strong>基本用法</strong></p><ul><li>su 用户名称   （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量）</li><li>su - 用户名称       （功能描述：切换到用户并获得该用户的环境变量及执行权限）</li></ul><h3 id="4-4userdel删除用户"><a href="#4-4userdel删除用户" class="headerlink" title="4.4userdel删除用户"></a>4.4userdel删除用户</h3><p><strong>基本用法</strong></p><ul><li>userdel  用户名         （功能描述：删除用户但保存用户主目录）</li><li>userdel -r 用户名       （功能描述：用户和用户主目录，都删除）</li></ul><h3 id="4-5-who-查看登录用户信息"><a href="#4-5-who-查看登录用户信息" class="headerlink" title="4.5 who 查看登录用户信息"></a>4.5 who 查看登录用户信息</h3><p><strong>基本用法</strong></p><ul><li>whoami                （功能描述：显示自身用户名称）</li><li>who am i             （功能描述：显示登录用户的用户名以及登陆时间）</li></ul><h3 id="4-6-sudo-设置普通用户具有root权限"><a href="#4-6-sudo-设置普通用户具有root权限" class="headerlink" title="4.6 sudo 设置普通用户具有root权限"></a>4.6 sudo 设置普通用户具有root权限</h3><p>（1）修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>修改 &#x2F;etc&#x2F;sudoers 文件，找到下面一行(91行)，在root下面添加一行，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root       ALL=(ALL)     ALL</span><br><span class="line">用户名   ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>或者配置成采用sudo命令时，不需要输入密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root       ALL=(ALL)     ALL</span><br><span class="line">用户名   ALL=(ALL)     NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>修改完毕，现在可以用此用户登录，然后用命令 sudo ，即可获得root权限进行</p><h2 id="5-用户组管理命令"><a href="#5-用户组管理命令" class="headerlink" title="5.用户组管理命令"></a>5.用户组管理命令</h2><p>​每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，</p><p>​如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>​用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。</p><h3 id="5-1groupdel删除组"><a href="#5-1groupdel删除组" class="headerlink" title="5.1groupdel删除组"></a>5.1groupdel删除组</h3><p><strong>基本用法</strong></p><p>​groupdel 组名</p><h3 id="5-2-groupadd增加组"><a href="#5-2-groupadd增加组" class="headerlink" title="5.2 groupadd增加组"></a>5.2 groupadd增加组</h3><p><strong>基本用法</strong></p><p>​groupadd组名</p><h3 id="5-3-groupmod-修改组"><a href="#5-3-groupmod-修改组" class="headerlink" title="5.3 groupmod 修改组"></a>5.3 groupmod 修改组</h3><p><strong>基本用法：</strong></p><p>​groupmod -n 新组名 老组名</p><h2 id="6-文件权限类"><a href="#6-文件权限类" class="headerlink" title="6.文件权限类"></a>6.文件权限类</h2><h3 id="6-1文件属性"><a href="#6-1文件属性" class="headerlink" title="6.1文件属性"></a>6.1文件属性</h3><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组。</p><p><strong>从左到右的10个字符表示，如下所示</strong></p><p><img src="/2022/08/27/Linux/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/1661591332772.png" alt="1661591332772"></p><p>（1）0首位表示类型</p><p>​在Linux中第一个字符代表这个文件是目录、文件或链接文件等等</p><p>​<strong>- 代表文件</strong></p><p>​ <strong>d 代表目录</strong></p><p>​ <strong>l 链接文档(link file)；</strong></p><p>（2）第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User</p><p>（3）第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group</p><p>（4）第7-9位确定其他用户拥有该文件的权限 —Other</p><p><strong>rxw作用文件和目录的不同解释</strong></p><p>（1）作用到文件：</p><p>​[ r ]代表可读(read): 可以读取，查看</p><p>​[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.</p><p>​[ x ]代表可执行(execute):可以被系统执行</p><p>（2）作用到目录：</p><p>​[ r ]代表可读(read): 可以读取，ls查看目录内容</p><p>​[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</p><p>​[ x ]代表可执行(execute):可以进入该目录</p><h3 id="6-2chmod改变权限"><a href="#6-2chmod改变权限" class="headerlink" title="6.2chmod改变权限"></a>6.2chmod改变权限</h3><p>有两种改变权限的方式</p><p><strong>第一种:</strong></p><p>​chown  [{ugoa}{+-&#x3D;}{rwx}] 文件或目录</p><p>​u 就是当前用户 g是当前用户组  o是其它用户 a是所有</p><p>​使用案例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x houge.txt</span><br></pre></td></tr></table></figure><p><strong>第二种（较为常用）：</strong></p><p>​例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown 777 a.txt</span><br></pre></td></tr></table></figure><p>​r&#x3D;4 w&#x3D;2 x&#x3D;1        rwx&#x3D;4+2+1&#x3D;7</p><p>​上述这个777代表用户组 用户 其它用户对于该文件都有读、写、执行权限</p><h3 id="6-3-chown改变所有者"><a href="#6-3-chown改变所有者" class="headerlink" title="6.3 chown改变所有者"></a>6.3 chown改变所有者</h3><p><strong>基本用法：</strong></p><p>​chown [选项] [最终用户] [文件或目录]            （功能描述：改变文件或者目录的所有者）</p><p><strong>选项说明：</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-R</td><td>递归操作</td></tr></tbody></table><h3 id="6-4-chgrp改变用户所属组"><a href="#6-4-chgrp改变用户所属组" class="headerlink" title="6.4 chgrp改变用户所属组"></a>6.4 chgrp改变用户所属组</h3><p><strong>基本用法：</strong></p><p>​chgrp [最终用户组] [文件或目录]      （功能描述：改变文件或者目录的所属组）</p><h2 id="7-搜索查找类"><a href="#7-搜索查找类" class="headerlink" title="7.搜索查找类"></a>7.搜索查找类</h2><h3 id="7-1find查找问而建或目录"><a href="#7-1find查找问而建或目录" class="headerlink" title="7.1find查找问而建或目录"></a>7.1find查找问而建或目录</h3><p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><p><strong>基本用法</strong></p><p>​find [搜索范围] [选项]</p><p><strong>选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件,单位为:    <strong>b</strong> —— 块（512字节）   <strong>c</strong> —— 字节   <strong>w</strong> —— 字（2字节）   <strong>k</strong> —— 千字节   <strong>M</strong> —— 兆字节   <strong>G</strong> —— 吉字节</td></tr></tbody></table><p><strong>案例实操</strong></p><p>按文件大小：在&#x2F;home目录下查找大于200m的文件（+n 大于  -n小于   n等于）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -size +204800</span><br></pre></td></tr></table></figure><h3 id="7-2-grep-过滤查找以及“-”管道符"><a href="#7-2-grep-过滤查找以及“-”管道符" class="headerlink" title="7.2 grep 过滤查找以及“|”管道符"></a>7.2 grep 过滤查找以及“|”管道符</h3><p>​管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理</p><p><strong>基本语法</strong></p><p>​grep 选项 查找内容 源文件</p><h2 id="8-压缩和解压类"><a href="#8-压缩和解压类" class="headerlink" title="8.压缩和解压类"></a>8.压缩和解压类</h2><h3 id="8-1gzip-x2F-gunzip压缩"><a href="#8-1gzip-x2F-gunzip压缩" class="headerlink" title="8.1gzip&#x2F;gunzip压缩"></a>8.1gzip&#x2F;gunzip压缩</h3><p><strong>基本用法</strong></p><ul><li>gzip 文件             （功能描述：压缩文件，只能将文件压缩为*.gz文件）</li><li>gunzip 文件.gz     （功能描述：解压缩文件命令）</li></ul><p><strong>详细说明</strong></p><p>（1）只能压缩文件不能压缩目录</p><p>（2）不保留原来的文件</p><p>（3）同时多个文件会产生多个压缩包</p><h3 id="8-2-zip-x2F-unzip压缩"><a href="#8-2-zip-x2F-unzip压缩" class="headerlink" title="8.2 zip&#x2F;unzip压缩"></a>8.2 zip&#x2F;unzip压缩</h3><p><strong>基本用法</strong></p><ul><li>zip  [选项] XXX.zip  将要压缩的内容           （功能描述：压缩文件和目录的命令）</li><li>unzip [选项] XXX.zip                                      （功能描述：解压缩文件）</li></ul><table><thead><tr><th>zip选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>压缩目录</td></tr></tbody></table><table><thead><tr><th>unzip选项</th><th>功能</th></tr></thead><tbody><tr><td>-d&lt;目录&gt;</td><td>指定解压后文件的存放目录</td></tr></tbody></table><h3 id="8-3-tar打包"><a href="#8-3-tar打包" class="headerlink" title="8.3 tar打包"></a>8.3 tar打包</h3><p><strong>选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr><tr><td>-C</td><td>解压到指定目录</td></tr></tbody></table><p><strong>案例实操</strong></p><p>（1）压缩多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 opt]# tar -zcvf houma.tar.gz houge.txt bailongma.txt </span><br><span class="line">houge.txt</span><br><span class="line">bailongma.txt</span><br><span class="line">[root@hadoop101 opt]# ls</span><br><span class="line">houma.tar.gz houge.txt bailongma.txt </span><br></pre></td></tr></table></figure><p>（2）压缩目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tar -zcvf xiyou.tar.gz xiyou/</span><br><span class="line">xiyou/</span><br><span class="line">xiyou/mingjie/</span><br><span class="line">xiyou/dssz/</span><br><span class="line">xiyou/dssz/houge.txt</span><br></pre></td></tr></table></figure><p>（3）解压到指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 ~]# tar -zxvf xiyou.tar.gz -C /opt</span><br><span class="line">[root@hadoop101 ~]# ll /opt/</span><br></pre></td></tr></table></figure><h2 id="9-磁盘分区类"><a href="#9-磁盘分区类" class="headerlink" title="9.磁盘分区类"></a>9.磁盘分区类</h2><h3 id="9-1df-查看磁盘空间使用情况"><a href="#9-1df-查看磁盘空间使用情况" class="headerlink" title="9.1df 查看磁盘空间使用情况"></a>9.1df 查看磁盘空间使用情况</h3><p><strong>常用指令</strong></p><p>df -h</p><p><img src="/2022/08/27/Linux/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/1661594172359.png" alt="1661594172359"></p><h3 id="9-2fdisk查看分区"><a href="#9-2fdisk查看分区" class="headerlink" title="9.2fdisk查看分区"></a>9.2fdisk查看分区</h3><p>fdisk -l                  （功能描述：查看磁盘分区详情）</p><p><img src="/2022/08/27/Linux/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/1661594255981.png" alt="1661594255981"></p><h3 id="9-3-mount-x2F-umount-挂载-x2F-卸载"><a href="#9-3-mount-x2F-umount-挂载-x2F-卸载" class="headerlink" title="9.3 mount&#x2F;umount 挂载&#x2F;卸载"></a>9.3 mount&#x2F;umount 挂载&#x2F;卸载</h3><p>对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构。</p><p>Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得。</p><h2 id="10-进程线程类"><a href="#10-进程线程类" class="headerlink" title="10.进程线程类"></a>10.进程线程类</h2><p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p><h3 id="10-1-ps查看当前系统进程状态"><a href="#10-1-ps查看当前系统进程状态" class="headerlink" title="10.1 ps查看当前系统进程状态"></a>10.1 ps查看当前系统进程状态</h3><p>基本指令</p><ul><li>ps -aux | grep xxx          （功能描述：查看系统中所有进程）</li><li>ps -ef | grep xxx           （功能描述：可以查看子父进程之间的关系）</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>选择所有进程</td></tr><tr><td>-u</td><td>显示所有用户的所有进程</td></tr><tr><td>-x</td><td>显示没有终端的进程</td></tr></tbody></table><h3 id="10-2-kill终止进程"><a href="#10-2-kill终止进程" class="headerlink" title="10.2 kill终止进程"></a>10.2 kill终止进程</h3><ul><li>kill  [选项] 进程号            （功能描述：通过进程号杀死进程）</li><li>killall 进程名称                  （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-9</td><td>表示强迫进程立即停止</td></tr></tbody></table><h3 id="10-3-pstree-查看进程树"><a href="#10-3-pstree-查看进程树" class="headerlink" title="10.3 pstree 查看进程树"></a>10.3 pstree 查看进程树</h3><p>pstree [选项]</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>显示进程的PID</td></tr><tr><td>-u</td><td>显示进程的所属用户</td></tr></tbody></table><h3 id="10-4-top查看系统健康状态"><a href="#10-4-top查看系统健康状态" class="headerlink" title="10.4 top查看系统健康状态"></a>10.4 top查看系统健康状态</h3><p>top [选项]</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令：</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程。</td></tr><tr><td>-p</td><td>通过指定监控进程ID来仅仅监控某个进程的状态。</td></tr></tbody></table><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop101 atguigu]# top -d 1</span><br><span class="line">[root@hadoop101 atguigu]# top -i</span><br><span class="line">[root@hadoop101 atguigu]# top -p 2575</span><br></pre></td></tr></table></figure><p>执行上述命令后，可以按P、M、N对查询出的进程结果进行排序。</p><h3 id="10-5-netstat-显示网络统计信息和端口占用情况"><a href="#10-5-netstat-显示网络统计信息和端口占用情况" class="headerlink" title="10.5 netstat 显示网络统计信息和端口占用情况"></a>10.5 netstat 显示网络统计信息和端口占用情况</h3><ul><li>netstat -anp | grep 进程号     （功能描述：查看该进程网络信息）</li><li>netstat –nlp | grep 端口号     （功能描述：查看网络端口号占用情况）</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n</td><td>拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td>-l</td><td>仅列出有在listen（监听）的服务状态</td></tr><tr><td>-p</td><td>表示显示哪个进程在调用</td></tr></tbody></table><h2 id="11-RPM"><a href="#11-RPM" class="headerlink" title="11.RPM"></a>11.RPM</h2><h3 id="11-1RPM概述"><a href="#11-1RPM概述" class="headerlink" title="11.1RPM概述"></a>11.1RPM概述</h3><p>RPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe</p><p> 是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p><p>RPM包的名称格式</p><p>Apache-1.3.23-11.i386.rpm</p><p>-        “apache” 软件名称</p><p>-        “1.3.23-11”软件的版本号，主版本和此版本</p><p>-        “i386”是软件所运行的硬件平台，Intel 32位处理器的统称</p><p>-        “rpm”文件扩展名，代表RPM包</p><h3 id="11-2RPM查询命令（rpm-qa）"><a href="#11-2RPM查询命令（rpm-qa）" class="headerlink" title="11.2RPM查询命令（rpm -qa）"></a>11.2RPM查询命令（rpm -qa）</h3><p>rpm -qa                        （功能描述：查询所安装的所有rpm软件包）</p><p>由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包</p><h3 id="11-3RPM卸载命令（rpm-e）"><a href="#11-3RPM卸载命令（rpm-e）" class="headerlink" title="11.3RPM卸载命令（rpm -e）"></a>11.3RPM卸载命令（rpm -e）</h3><p>（1）rpm -e RPM软件包   </p><p>（2） rpm -e –nodeps 软件包  </p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>卸载软件包</td></tr><tr><td>–nodeps</td><td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了。</td></tr></tbody></table><h3 id="11-4RPM安装命令（rpm-ivh）"><a href="#11-4RPM安装命令（rpm-ivh）" class="headerlink" title="11.4RPM安装命令（rpm -ivh）"></a>11.4RPM安装命令（rpm -ivh）</h3><p>rpm -ivh RPM包全名</p><table><thead><tr><th>-i</th><th>-i&#x3D;install，安装</th></tr></thead><tbody><tr><td>-v</td><td>-v&#x3D;verbose，显示详细信息</td></tr><tr><td>-h</td><td>-h&#x3D;hash，进度条</td></tr><tr><td>–nodeps</td><td>–nodeps，不检测依赖进度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络配置以及系统管理操作</title>
      <link href="/2022/08/27/Linux/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/08/27/Linux/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-修改静态IP地址"><a href="#1-修改静态IP地址" class="headerlink" title="1.修改静态IP地址"></a>1.修改静态IP地址</h2><p>查看IP配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/Linux/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C/1661588159742.png" alt="1661588159742"></p><p>修改完配置文件之后执行service network restart 重启网络然后就修改成功</p><h2 id="2-修改主机名称"><a href="#2-修改主机名称" class="headerlink" title="2.修改主机名称"></a>2.修改主机名称</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>修改完成之后需要重启电脑才能生效</p><h2 id="3-修改hosts映射文件"><a href="#3-修改hosts映射文件" class="headerlink" title="3.修改hosts映射文件"></a>3.修改hosts映射文件</h2><h3 id="3-1修改Linux的映射文件"><a href="#3-1修改Linux的映射文件" class="headerlink" title="3.1修改Linux的映射文件"></a>3.1修改Linux的映射文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>添加如下内容即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.100 hadoop100</span><br><span class="line">192.168.2.101 hadoop101</span><br><span class="line">192.168.2.102 hadoop102</span><br><span class="line">192.168.2.103 hadoop103</span><br><span class="line">192.168.2.104 hadoop104</span><br><span class="line">192.168.2.105 hadoop105</span><br></pre></td></tr></table></figure><h3 id="3-2修改Windows的主机映射文件"><a href="#3-2修改Windows的主机映射文件" class="headerlink" title="3.2修改Windows的主机映射文件"></a>3.2修改Windows的主机映射文件</h3><p>（1）进入C:\Windows\System32\drivers\etc路径</p><p>（2）拷贝hosts文件到桌面</p><p>（3）打开桌面hosts文件并添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.2.100 hadoop100</span><br><span class="line">192.168.2.101 hadoop101</span><br><span class="line">192.168.2.102 hadoop102</span><br><span class="line">192.168.2.103 hadoop103</span><br><span class="line">192.168.2.104 hadoop104</span><br><span class="line">192.168.2.105 hadoop105</span><br></pre></td></tr></table></figure><p>（4）将桌面hosts文件覆盖C:\Windows\System32\drivers\etc路径hosts文件</p><h2 id="4-关闭防火墙"><a href="#4-关闭防火墙" class="headerlink" title="4.关闭防火墙"></a>4.关闭防火墙</h2><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start|stop|restart|status  服务名</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable service_name  （功能描述：关掉指定服务的自动启动）</span><br><span class="line">systemctl enable service_name   （功能描述：开启指定服务的自动启动）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 静态IP </tag>
            
            <tag> 修改windos主机映射 </tag>
            
            <tag> 关闭防火墙 </tag>
            
            <tag> systemctl指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim编辑器</title>
      <link href="/2022/08/27/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2022/08/27/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-VIM编辑器是什么"><a href="#1-VIM编辑器是什么" class="headerlink" title="1.VIM编辑器是什么"></a>1.VIM编辑器是什么</h2><p>VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。</p><p>VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI编辑器完全兼容。</p><h2 id="2-VIM编辑器的三种模式的切换"><a href="#2-VIM编辑器的三种模式的切换" class="headerlink" title="2.VIM编辑器的三种模式的切换"></a>2.VIM编辑器的三种模式的切换</h2><p><img src="/2022/08/27/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8/1661585762482.png" alt="1661585762482"></p><p>主要包括三种模式：一般模式、编辑模式、命令模式</p><p>一般模式就是进入一个文件的状态，然后我们可以按i、a、o进入编辑模式，在编辑模式下可以操作文件内容，然后使用ESC进入一般模式，一般模式下使用：可以进入命令模式，在命令模式下我们可以对文件进行保存更改等</p><h2 id="3-一般模式下常用命令"><a href="#3-一般模式下常用命令" class="headerlink" title="3.一般模式下常用命令"></a>3.一般模式下常用命令</h2><p>以vi打开一个档案就直接进入一般模式了（这是默认的模式）。在这个模式中，<br>你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、粘贴』来处理你的文件数据。</p><table><thead><tr><th>语法</th><th>功能描述</th></tr></thead><tbody><tr><td>yy</td><td>复制光标当前一行</td></tr><tr><td>y数字y</td><td>复制一段（从第几行到第几行）</td></tr><tr><td>p</td><td>箭头移动到目的行粘贴</td></tr><tr><td>u</td><td>撤销上一步</td></tr><tr><td>dd</td><td>删除光标当前行</td></tr><tr><td>d数字d</td><td>删除光标（含）后多少行</td></tr><tr><td>x</td><td>剪切一个字母，相当于del</td></tr><tr><td>X</td><td>剪切一个字母，相当于Backspace</td></tr><tr><td>yw</td><td>复制一个词</td></tr><tr><td>dw</td><td>删除一个词</td></tr><tr><td>shift+6（^）</td><td>移动到行头</td></tr><tr><td>shift+4 （$）</td><td>移动到行尾</td></tr><tr><td>1+shift+g</td><td>移动到页头，数字</td></tr><tr><td>shift+g</td><td>移动到页尾</td></tr><tr><td>数字+shift+g</td><td>移动到目标行</td></tr></tbody></table><h2 id="4-编辑模式"><a href="#4-编辑模式" class="headerlink" title="4.编辑模式"></a>4.编辑模式</h2><p>在一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容的！要等到你按下『i, I, o, O, a, A』等任何一个字母之后才会进入编辑模式。</p><p>注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。</p><h2 id="5-指令模式"><a href="#5-指令模式" class="headerlink" title="5.指令模式"></a>5.指令模式</h2><p>在一般模式当中，输入『 : &#x2F; ?』3个中的任何一个按钮，就可以将光标移动到最底下那一行。</p><p>在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等动作是在此模式中达成的！</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:!</td><td>强制执行</td></tr><tr><td>&#x2F;要查找的词</td><td>n 查找下一个，N 往上查找</td></tr><tr><td>:noh</td><td>取消高亮显示</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>关闭行号</td></tr><tr><td>:%s&#x2F;old&#x2F;new&#x2F;g</td><td>替换内容   &#x2F;g就是把找到的老的字符全部匹配成新的字符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VIM </tag>
            
            <tag> VI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2022/08/27/Linux/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/27/Linux/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>在Linux中万物皆是文件</p><p>其目录结构如下图所示：</p><p><img src="/2022/08/27/Linux/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/1661584969351.png" alt="1661584969351"></p><p>其目录结构简介如下：</p><ul><li><p>&#x2F;bin</p><p>是Binary的缩写，这个目录下存放着最经常使用的命令</p></li><li><p>&#x2F;sbin</p><p>s 就是Super User的意思，这里存放的是系统管理员所使用的系统管理程序</p></li><li><p>&#x2F;home</p><p>存放普通用户的主目录，在Linux中每一个用户都有自己的一个目录，一般这个目录名就是此用户的账号名字</p></li><li><p>&#x2F;root</p><p>该目录就是系统管理员，也称为超级权限者的用户主目录</p></li><li><p>&#x2F;etc</p><p>所有的系统管理所需要的配置文件和子目录</p></li><li><p>&#x2F;usr</p><p>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows下的program files文件夹</p></li><li><p>&#x2F;boot</p><p>这里存放的是启动Linux的一些核心文件，包括一些连接文件以及镜像文件，自己的安装不要放在此目录下</p></li><li><p>&#x2F;mnt</p><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载到&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里面的内容了</p></li><li><p>&#x2F;opt</p><p>这是给主机额外安装软件所摆放的目录，比如你安装一个MySQL数据库就可以放到这个目录下。这个目录是一些大型软件的安装目录，或者是一些服务程序的安装目录 。</p></li><li><p>&#x2F;var</p><p>这个目录存放着不断扩充的东西，我们习惯把那些经常被修改的目录放到这个目录下面，包括各种文件日志</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux中的文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接池</title>
      <link href="/2022/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2022/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库连接池"><a href="#1-数据库连接池" class="headerlink" title="1.数据库连接池"></a>1.数据库连接池</h2><h3 id="1-1数据库连接池的必要性"><a href="#1-1数据库连接池的必要性" class="headerlink" title="1.1数据库连接池的必要性"></a>1.1数据库连接池的必要性</h3><p>不使用数据库连接池存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li>对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而<strong>未能关闭</strong>，将会导致<strong>数据库系统中的内存泄漏</strong>，最终将导致重启数据库。</li><li>这种开发不能控制被创建的<strong>连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接<strong>过多</strong>，也可能导致<strong>内存泄漏，服务器崩溃</strong>。</li></ul><p>为解决传统开发中的数据库连接问题，可以采用<strong>数据库连接池技术（<strong><strong>connection pool</strong></strong>）</strong>。</p><p>​    <strong>数据库连接池的基本思想</strong>就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p><p><img src="/2022/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1661572039707.png" alt="1661572039707"></p><p>数据库连接池技术的优点：</p><ul><li><p><strong>资源重用：</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p></li><li><p><strong>更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p></li><li><p><strong>新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p></li><li><p><strong>统一的连接管理，避免数据库连接泄露</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="1-2Druid数据源"><a href="#1-2Druid数据源" class="headerlink" title="1.2Druid数据源"></a>1.2Druid数据源</h3><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">         <span class="comment">//测试获取超过最大连接数的连接数量（连接关闭、未关闭的情况）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2.ThreadLocal"></a>2.ThreadLocal</h2><p>JDK 1.2的版本中就提供java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p><p>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</p><p>1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。</p><p>2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。</p><p>3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tools</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 从当前线程中获取数字</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line"><span class="keyword">if</span> (num == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//随机产生一个</span></span><br><span class="line">num = rand.nextInt(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 将数字与当前线程绑定</span></span><br><span class="line">threadLocal.set(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeNumber</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 获取当前线程中的数字</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line"><span class="keyword">if</span> (num != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将数字从当前线程中移除</span></span><br><span class="line">threadLocal.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocal</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;B--&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + Tools.getNumber());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">Tools.removeNumber();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">3</span></span><br><span class="line">B--:<span class="number">53</span></span><br><span class="line">a:<span class="number">3</span></span><br><span class="line">B--:<span class="number">53</span></span><br><span class="line">a:<span class="number">3</span></span><br><span class="line">B--:<span class="number">53</span></span><br><span class="line">remove后</span><br><span class="line">a:<span class="number">9</span></span><br><span class="line">remove后</span><br><span class="line">B--:<span class="number">40</span></span><br><span class="line">a:<span class="number">9</span></span><br><span class="line">B--:<span class="number">40</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现ThreadLocal用于保存每一个线程共享变量，只要不删除remove，那么该值在该线程的生命周期中一直存在。</p><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。</p><h2 id="3-封装JDBCTools"><a href="#3-封装JDBCTools" class="headerlink" title="3.封装JDBCTools"></a>3.封装JDBCTools</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取连接或释放连接的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTools</span> &#123;</span><br><span class="line"><span class="comment">// 1、数据源,即连接池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、ThreadLocal对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1、读取druip.properties文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(JDBCTools.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、连接连接池</span></span><br><span class="line">dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、创 建 线 程 池</span></span><br><span class="line">threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 从当前线程中获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line"><span class="keyword">if</span> (connection == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 从连接池中获取一个连接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">connection = dataSource.getConnection();</span><br><span class="line"><span class="comment">// 将连接与当前线程绑定</span></span><br><span class="line">threadLocal.set(connection);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放连接的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseConnection</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 获取当前线程中的连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line"><span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">connection.close();</span><br><span class="line"><span class="comment">// 将已经关闭的连接从当前线程中移除</span></span><br><span class="line">threadLocal.remove();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-封装VasicDAOImpl"><a href="#4-封装VasicDAOImpl" class="headerlink" title="4.封装VasicDAOImpl"></a>4.封装VasicDAOImpl</h2><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</p><p>作用：为了实现功能的模块化，更有利于代码的维护和升级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.utils.JdbcUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicDAOImpl</span> &#123;</span><br><span class="line"><span class="comment">//适用于insert,update,delete语句</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql,Object... args)</span> &#123;</span><br><span class="line"><span class="comment">//1、获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line"><span class="comment">//2、创建PreparedStatement</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、设置？的值</span></span><br><span class="line"><span class="keyword">if</span>(args!=<span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;<span class="comment">//数组的下标从0开始</span></span><br><span class="line">pst.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//？的序号从1开始</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、执行更新sql</span></span><br><span class="line"><span class="keyword">return</span> pst.executeUpdate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//5、关闭</span></span><br><span class="line">pst.close();</span><br><span class="line">JdbcUtils.free();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T可能代表Department，Employee等各种Javabean的对象</span></span><br><span class="line"><span class="comment">//clazz是决定你查询的结果是Department，Employee类型中的那个对象</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ArrayList&lt;T&gt; <span class="title function_">getBeanList</span><span class="params">(Class&lt;T&gt; clazz, String sql,Object... args)</span>&#123;</span><br><span class="line"><span class="comment">//1、获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建PreparedStatement</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、设置？的值</span></span><br><span class="line"><span class="keyword">if</span>(args!=<span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;<span class="comment">//数组的下标从0开始</span></span><br><span class="line">pst.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//？的序号从1开始</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、执行查询</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取结果集的元数据对象，该对象有对结果集的数据进行描述的相关信息</span></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsm</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="comment">//(1)获取结果集的列数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rsm.getColumnCount();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line"><span class="comment">//5、把ResultSet结果集中的数据封装到一个一个JavaBean对象中，并且存到list中</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;<span class="comment">//循环一次，代表一行，一行就是一个JavaBean对象</span></span><br><span class="line"><span class="comment">//(2)创建一个JavaBean的对象</span></span><br><span class="line"><span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有几列，就代表有几个属性</span></span><br><span class="line"><span class="comment">//为obj的每一个属性赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="comment">//通过反射设置属性的值</span></span><br><span class="line"><span class="comment">//(3)从结果集的元数据对象中获取第几列的字段名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsm.getColumnLabel(i+<span class="number">1</span>);<span class="comment">//mysql的序号从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)获取属性对象</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);<span class="comment">//根据字段名称，获取属性对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)设置属性可以被访问</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(6)设置属性的值</span></span><br><span class="line">field.set(obj, rs.getObject(i+<span class="number">1</span>));<span class="comment">//从结果集中获取第i+1的值，赋值给该属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7、返回结果</span></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//6、关闭</span></span><br><span class="line">pst.close();</span><br><span class="line">JdbcUtils.free();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; type,String sql, Object... params)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getBeanList(type,sql,params).get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-Employee的增删改查"><a href="#5-Employee的增删改查" class="headerlink" title="5.Employee的增删改查"></a>5.Employee的增删改查</h2><p><img src="/2022/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1661572607708.png" alt="1661572607708"></p><p>通过给列取别名的方式，来告知数据库的列名与其对应实体的属性名</p><p><img src="/2022/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1661572638458.png" alt="1661572638458"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"><span class="comment">//查询对象</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findOne</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"><span class="comment">//查询集合</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_t values(null,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setString(<span class="number">1</span>, user.getUsername());</span><br><span class="line">psmt.setString(<span class="number">2</span>, user.getPassword());</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate();</span><br><span class="line">System.out.println(count);</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_t set username=? where id=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setString(<span class="number">1</span>, user.getUsername());</span><br><span class="line">psmt.setInt(<span class="number">2</span>, user.getId());</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate();</span><br><span class="line">System.out.println(count);</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_t where id=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setInt(<span class="number">1</span>, id);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate();</span><br><span class="line">System.out.println(count);</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findOne</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_t where id=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setInt(<span class="number">1</span>, id);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> psmt.executeQuery();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">user.setId(id);</span><br><span class="line">user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_t&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> psmt.executeQuery();</span><br><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">list.add(user);</span><br><span class="line">&#125;</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_t values(null,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setString(<span class="number">1</span>, user.getUsername());</span><br><span class="line">psmt.setString(<span class="number">2</span>, user.getPassword());</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate();</span><br><span class="line">System.out.println(count);</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_t set username=? where id=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setString(<span class="number">1</span>, user.getUsername());</span><br><span class="line">psmt.setInt(<span class="number">2</span>, user.getId());</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate();</span><br><span class="line">System.out.println(count);</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_t where id=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setInt(<span class="number">1</span>, id);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> psmt.executeUpdate();</span><br><span class="line">System.out.println(count);</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findOne</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_t where id=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">psmt.setInt(<span class="number">1</span>, id);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> psmt.executeQuery();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">user.setId(id);</span><br><span class="line">user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_t&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">psmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> psmt.executeQuery();</span><br><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">list.add(user);</span><br><span class="line">&#125;</span><br><span class="line">psmt.close();</span><br><span class="line">JDBCTools.releaseConnection();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEmployeeDAOImpl</span> &#123;</span><br><span class="line"><span class="type">EmployeeDAOImpl</span> <span class="variable">ed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeDAOImpl</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"> List&lt;Employee&gt; all = ed.getAllEmployee();</span><br><span class="line"><span class="keyword">for</span> (Employee employee : all) &#123;</span><br><span class="line">System.out.println(employee);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库连接池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> JDBC </tag>
            
            <tag> Durid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/08/27/JDBC/learingJDBC/"/>
      <url>/2022/08/27/JDBC/learingJDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1什么是JDBC"><a href="#1-1什么是JDBC" class="headerlink" title="1.1什么是JDBC"></a>1.1什么是JDBC</h3><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p><p>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p><p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p><p><img src="/2022/08/27/JDBC/learingJDBC/1661565904830.png" alt="1661565904830"></p><p>那么有了JDBC之后</p><p><img src="/2022/08/27/JDBC/learingJDBC/1661566276625.png" alt="1661566276625"></p><p><strong>结论：</strong></p><p>JDBC是SUN公司（Oracle公司甲骨文）提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。</p><p>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p><h2 id="2-获取数据库连接"><a href="#2-获取数据库连接" class="headerlink" title="2.获取数据库连接"></a>2.获取数据库连接</h2><h3 id="2-1引入JDBC驱动"><a href="#2-1引入JDBC驱动" class="headerlink" title="2.1引入JDBC驱动"></a>2.1引入JDBC驱动</h3><p>有两种方式，一种就是从网络上下载jar包，然后把jar包添加到项目的类路径下，这种方法不推荐使用</p><p>另外一种就是使用Maven统一管理</p><p><img src="/2022/08/27/JDBC/learingJDBC/1661566446813.png" alt="1661566446813"></p><h3 id="2-2-加载并注册驱动"><a href="#2-2-加载并注册驱动" class="headerlink" title="2.2 加载并注册驱动"></a>2.2 加载并注册驱动</h3><p><strong>1.Class.forName（）</strong></p><p>这种方式其实就是通过反射来加载与注册驱动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>2.自动注册</strong></p><p>即不需要我们自己写代码，帮我们自动实现，不过这个有版本的要求，但目前我们使用的大部分都已经支持</p><h3 id="2-3获取数据库连接"><a href="#2-3获取数据库连接" class="headerlink" title="2.3获取数据库连接"></a>2.3获取数据库连接</h3><p>可以通过 DriverManager 类建立到数据库的连接Connection：</p><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><p>jdbc:&lt;子协议&gt;:&lt;子名称&gt;</p><ul><li>协议：JDBC URL中的协议总是jdbc </li><li>子协议：子协议用于标识一个数据库驱动程序，就比如mysql</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息</li></ul><p> <img src="/2022/08/27/JDBC/learingJDBC/1661566791612.png" alt="1661566791612"></p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://192.168.213.102:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br></pre></td></tr></table></figure><h3 id="2-4-操作或访问数据库"><a href="#2-4-操作或访问数据库" class="headerlink" title="2.4 操作或访问数据库"></a>2.4 操作或访问数据库</h3><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。</p><p>其实一个数据库连接就是一个Socket连接。</p><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，然后可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul><p>对于statement一般使用两个函数，一个是executeUpdate、一个是executeQuery，第一个函数用来执行更新操作，结果返回一个数字，如果这个数字大于0，那么代表执行成功，一旦数字不大于0，那么代表执行失败，第二个函数用于执行查询操作，返回值类型是ResultSet对象。</p><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现</p><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过ResultSet 对象的next() 方法移动到下一行</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sql);<span class="comment">//select语句用query方法</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;<span class="comment">//是否有下一行</span></span><br><span class="line">    <span class="comment">//取这一行的单元格</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getString(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(id+<span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-释放资源"><a href="#2-5-释放资源" class="headerlink" title="2.5 释放资源"></a>2.5 释放资源</h3><p>Connection、Statement、ResultSet都是应用程序和数据库服务器的连接资源，使用后一定要关闭，可以在finally中关闭</p><h3 id="2-6-增删改查代码示例"><a href="#2-6-增删改查代码示例" class="headerlink" title="2.6 增删改查代码示例"></a>2.6 增删改查代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 网络编程：tcp</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 服务器端：</span></span><br><span class="line"><span class="comment"> * 1、ServerSocket server = new ServerSocket(3306);</span></span><br><span class="line"><span class="comment"> * 2、Socket socket = server.accept();</span></span><br><span class="line"><span class="comment"> * 3、InputStream input = socket.getInputStream();//接收sql，客户端传过来的</span></span><br><span class="line"><span class="comment"> * 4、在服务器执行sql</span></span><br><span class="line"><span class="comment"> * 5、把结果给客户端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * 1、Socket socket = new Socket(服务器的IP地址，3306);</span></span><br><span class="line"><span class="comment"> * 2、传sql</span></span><br><span class="line"><span class="comment"> * 3、OutputStream out = socket.getOutputStream();</span></span><br><span class="line"><span class="comment"> * 4、out.write(sql);</span></span><br><span class="line"><span class="comment"> * 5、接收结果</span></span><br><span class="line"><span class="comment"> * 6、断开连接  out.close();socket.close();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStatement</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">             <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO t_department(dname,description) VALUES(&#x27;财务部&#x27;,&#x27;负责发钱工作&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> st.executeUpdate(sql);<span class="comment">//把insert,update,delete都用这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE t_department SET description = &#x27;负责发工资、社保、公积金工作&#x27; WHERE dname =&#x27;财务部&#x27;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> st.executeUpdate(sql);<span class="comment">//把insert,update,delete都用这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM t_department WHERE did =6&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> st.executeUpdate(sql);<span class="comment">//把insert,update,delete都用这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM t_department&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sql);<span class="comment">//select语句用query方法</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;<span class="comment">//是否有下一行</span></span><br><span class="line"><span class="comment">//取这一行的单元格</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getString(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(id+<span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect2</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT did,dname FROM t_department&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sql);<span class="comment">//select语句用query方法</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;<span class="comment">//是否有下一行</span></span><br><span class="line"><span class="comment">//取这一行的单元格</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;did&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">System.out.println(id+<span class="string">&quot;\t&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-PreparedStatement"><a href="#3-PreparedStatement" class="headerlink" title="3.PreparedStatement"></a>3.PreparedStatement</h2><h3 id="3-1Statement的不足"><a href="#3-1Statement的不足" class="headerlink" title="3.1Statement的不足"></a>3.1Statement的不足</h3><h4 id="3-1-1-SQL拼接问题"><a href="#3-1-1-SQL拼接问题" class="headerlink" title="3.1.1 SQL拼接问题"></a>3.1.1 SQL拼接问题</h4><p>简单来说就是当sql语句拼接的时候设计字符串的拼接操作，操作十分繁琐</p><p><strong>下面使用一个登录的场景来说明这个弊端</strong></p><p>引用自<a href="https://blog.csdn.net/pison007/article/details/113485127">(69条消息) Statement操作sql语句的弊端_pison007的博客-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">get</span><span class="params">(String sql)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//获取基本的配置信息</span></span><br><span class="line">InputStream input=StatementCase.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">Properties pro=<span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(input);</span><br><span class="line">String url=pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">String user=pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">String password=pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">String driverClass=pro.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载驱动类</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection con=DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">Statement statement=con.createStatement();</span><br><span class="line">ResultSet rs=statement.executeQuery(sql);</span><br><span class="line">User login_user=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">String username=rs.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">String password1=rs.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">login_user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">login_user.setUsername(username);</span><br><span class="line">login_user.setPassword(password1); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> login_user;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>用户输入用户名和密码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;用户名:&quot;</span>);</span><br><span class="line">String user=scanner.next();</span><br><span class="line">System.out.print(<span class="string">&quot;密码:&quot;</span>);</span><br><span class="line">String password=scanner.next();</span><br><span class="line"></span><br><span class="line">String sql=<span class="string">&quot;select username,password from userinfo where  username=&#x27;&quot;</span>+user+<span class="string">&quot;&#x27; and password= &#x27;&quot;</span>+password+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">User result=get(sql);</span><br><span class="line"><span class="keyword">if</span>(result!=<span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前为止看起来都一切良好，这个时候问题来了，我必须把变量名user,password放进我的sql语句中去。也就是这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username,password from userinfo where  username=<span class="string">&#x27;变量user&#x27;</span>  and  password= <span class="string">&#x27;变量password&#x27;</span></span><br></pre></td></tr></table></figure><p>由于在java中执行的SQL语句必须以字符串的形式书写，那么就涉及到字符串的拼接,就会变成这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">&quot;select username,password from userinfo where  username=&#x27;&quot;</span>+user+<span class="string">&quot;&#x27; and password= &#x27;&quot;</span>+password+<span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>上述代码的可读性会非常差，而且SQL注入问题是最不能接收的。</p><h4 id="3-1-2-SQL注入问题"><a href="#3-1-2-SQL注入问题" class="headerlink" title="3.1.2 SQL注入问题"></a>3.1.2 SQL注入问题</h4><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement 取代 Statement 就可以了。</p><p>用一个比较简单的例子来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接数据库获取账号和密码登录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=true&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;XXXX&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入用户名: &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">un</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入密 码: &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pw</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 下面代码存在 sql 注入问题</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name = &#x27;&quot;</span> + un</span><br><span class="line">                    + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pw + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">// 下面这个代码的含义为: 将sql语句给DBMS, DBMS进行编译</span></span><br><span class="line">            <span class="comment">// 是先提交后编译, 所以如果用户提供了非法信息, 就导致了 sql 语句含义被扭曲</span></span><br><span class="line">            <span class="comment">// 从而出现不符合用户需求的情况</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/27/JDBC/learingJDBC/1661570625202.png" alt="1661570625202"></p><p>当我输入用户名为 “xxx”  密码为 “XXX’ or ‘1’ &#x3D; ‘1” 时, 也可以显示登录成功, 但是根据上面显示, 数据库中显然没有这个账户和密码. </p><p>根据这一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name = &#x27;&quot;</span> + un + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + pw + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p> 我们还原一下 sql 语句, 拼接后的 sql 语句为 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> <span class="type">and</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>那么PreparedStatement是如何解决这个SQL注入问题的呢？</p><p><strong>他会预先对 sql 语句的框架进行编译, 然后再给 sql 语句进行传值.</strong></p><p>例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name = ? and password = ?&quot;</span>;</span><br><span class="line"><span class="comment">// 下面一行执行完, DBMS会将框架先编译好</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><h3 id="2-PreparedStatement"><a href="#2-PreparedStatement" class="headerlink" title="2.PreparedStatement"></a>2.PreparedStatement</h3><p>可以通过调用 Connection 对象的 preparedStatement(<strong>String sql</strong>) 方法获取 PreparedStatement 对象</p><p>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</p><ul><li>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</li><li>ResultSet executeQuery()执行查询，并返回该查询生成的 ResultSet 对象。</li><li>int executeUpdate()：执行更新，包括增、删、该</li></ul><p>演示代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.preparedstatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PreparedStatement：是Statement子接口</span></span><br><span class="line"><span class="comment"> * 1、SQL不需要拼接</span></span><br><span class="line"><span class="comment"> * 2、SQL不会出现注入</span></span><br><span class="line"><span class="comment"> * 3、可以处理Blob类型的数据</span></span><br><span class="line"><span class="comment"> * tinyblob：255字节以内</span></span><br><span class="line"><span class="comment"> * blob：65K以内</span></span><br><span class="line"><span class="comment"> * mediumblob:16M以内</span></span><br><span class="line"><span class="comment"> * longblob：4G以内</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果还是报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：</span></span><br><span class="line"><span class="comment"> * max_allowed_packet=16M</span></span><br><span class="line"><span class="comment"> * 注意：修改了my.ini文件，一定要重新启动服务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPreparedStatement</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入姓名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入手机号码：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入性别：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入薪资：&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> input.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入部门编号：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">did</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、连接数据库</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、编写带？的SQL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、准备一个PreparedStatement：预编译sql</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);<span class="comment">// 对带？的sql进行预编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、把?用具体的值进行代替</span></span><br><span class="line">pst.setString(<span class="number">1</span>, name);</span><br><span class="line">pst.setString(<span class="number">2</span>, tel);</span><br><span class="line">pst.setString(<span class="number">3</span>, gender);</span><br><span class="line">pst.setDouble(<span class="number">4</span>, salary);</span><br><span class="line">pst.setInt(<span class="number">5</span>, did);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、执行sql</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;<span class="number">0</span>?<span class="string">&quot;添加成功&quot;</span>:<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、释放资源</span></span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入姓名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、连接数据库</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、编写带?的sql</span></span><br><span class="line"><span class="comment">//孙红雷  &#x27; or &#x27;1&#x27; = &#x27;1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、把带？的sql语句进行预编译</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、把？用具体的变量的赋值</span></span><br><span class="line">pst.setString(<span class="number">1</span>, name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、执行sql</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;eid&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">ename</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;tel&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(id + <span class="string">&quot;\t&quot;</span> + ename + <span class="string">&quot;\t&quot;</span> + tel + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、释放资源</span></span><br><span class="line">rs.close();</span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBlob</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请指定照片的路径：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、连接数据库</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 INSERT INTO `user` VALUES(NULL,用户名,密码,照片)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO `user` (username,`password`,head_picture)VALUES(?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、准备一个PreparedStatement：预编译sql</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);<span class="comment">// 对带？的sql进行预编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、对？进行设置</span></span><br><span class="line">pst.setString(<span class="number">1</span>, username);</span><br><span class="line">pst.setString(<span class="number">2</span>, pwd);</span><br><span class="line">pst.setBlob(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(photoPath));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、执行sql</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pst.executeUpdate();</span><br><span class="line">System.out.println(len &gt; <span class="number">0</span> ? <span class="string">&quot;添加成功&quot;</span> : <span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、释放资源</span></span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-PreparedStatement-和Statement的对比"><a href="#3-PreparedStatement-和Statement的对比" class="headerlink" title="3.PreparedStatement 和Statement的对比"></a>3.PreparedStatement 和Statement的对比</h3><ul><li><p>代码的可读性和可维护性. Statement的sql拼接是个难题。</p></li><li><p>PreparedStatement 可以防止 SQL 注入 </p></li><li><p>PreparedStatement 可以处理Blob类型的数据</p></li><li><p>PreparedStatement 能最大可能提高性能：<strong>（Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高）</strong></p><p>​DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</p></li></ul><h3 id="4-批处理"><a href="#4-批处理" class="headerlink" title="4.批处理"></a>4.批处理</h3><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><p>JDBC的批量处理语句包括下面两个方法：</p><ul><li>addBatch()：添加需要批量处理的SQL语句或参数</li><li>executeBatch()：执行批量处理语句；</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><p>注意：</p><p><strong>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements&#x3D;true</strong></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.preparedstatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBatch</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">noBatch</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        st.setString(<span class="number">1</span>, <span class="string">&quot;测试部门&quot;</span> + i);</span><br><span class="line">        st.setString(<span class="number">2</span>, <span class="string">&quot;测试部门描述&quot;</span>  + i);</span><br><span class="line">        </span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useBatch</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        st.setString(<span class="number">1</span>, <span class="string">&quot;测试部门&quot;</span> + i);</span><br><span class="line">        st.setString(<span class="number">2</span>, <span class="string">&quot;测试部门描述&quot;</span>  + i);</span><br><span class="line">        </span><br><span class="line">        st.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st.executeBatch();</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">st</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">        st.setString(<span class="number">1</span>, <span class="string">&quot;测试部门&quot;</span> + i);</span><br><span class="line">        st.setString(<span class="number">2</span>, <span class="string">&quot;测试部门描述&quot;</span>  + i);</span><br><span class="line">        </span><br><span class="line">        st.addBatch(); <span class="comment">//加入batch</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st.executeBatch(); <span class="comment">//执行一批sql语句</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> JDBC </tag>
            
            <tag> statement </tag>
            
            <tag> preparedStatement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字字符串转换成IP地址</title>
      <link href="/2022/08/26/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BAIP%E5%9C%B0%E5%9D%80/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
      <url>/2022/08/26/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BAIP%E5%9C%B0%E5%9D%80/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong></p><p>现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。</p><p>例如：</p><p>给出的字符串为”25525522135”,</p><p>返回[“255.255.22.135”, “255.255.221.35”]. (顺序没有关系)</p><p>数据范围：字符串长度 0 \le n \le 120≤<em>n</em>≤12</p><p>要求：空间复杂度 O(n!)<em>O</em>(<em>n</em>!),时间复杂度 O(n!)<em>O</em>(<em>n</em>!)</p><p>注意：ip地址是由四段数字组成的数字序列，格式如 “x.x.x.x”，其中 x 的范围应当是 [0,255]。</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;25525522135&quot;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;255.255.22.135&quot;,&quot;255.255.221.35&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1111&quot;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;000256&quot;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[]&quot;</span><br></pre></td></tr></table></figure><hr><p><strong>本题思路：</strong></p><p>本题目采用递归+回溯算法解决。</p><p><strong>递归我们需要确定递归函数的几个参数</strong></p><p>首先两个变量是确定的，一个是保存最后结果的list数组，一个是原始字符串，其它变量需要我们自行设计，我又使用了两个变量，一个用来判断我们目前是在取ip地址的第几个数字，一个用来判断我们目前使用到了字符串的哪一个下标。</p><p><strong>递归还需要判断递归结束条件</strong>，IP地址的规律我们需要清楚，最大是三个数字不能超过255，如果只有一个数字，那么可以为0，如果是2个或者三个数字，那么第一个数字不能为0，因此我们对于每一个IP地址的数字使用一次for循环，for循环最多3次，代表最多加入3个数字，每一次加上一个数字之后，我们需要判断此时的数字是否满足那几个条件，满足，那么我们就接着当时的情况接着取遍历，如果不满足，那么直接continue。</p><p>因此最后的递归结束条件就是当我们已经取了四次IP地址三位数字了，如果四次以后，index并没有把原始字符串取完，那么就结束此次结果，如果取完了，证明四次IP地址都满足条件，因此加入结果数组，最终把数组返回即可得到最后的结果。</p><p>下面是代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//用于回溯的变量</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">restoreIpAddresses</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//结果数组</span></span><br><span class="line">        dfs(res,s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(ArrayList&lt;String&gt; res,String s, <span class="type">int</span> ipNumber, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ipNumber==<span class="number">4</span>)&#123; <span class="comment">// 一旦为4，证明已经判断过4次IP地址</span></span><br><span class="line">            <span class="keyword">if</span>(index!=s.length())&#123; <span class="comment">// 看看原始字符串有没有取完</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(nums); <span class="comment">//取完了就把此次情况加入结果数组</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//构建一个临时变量用来存储一次IP地址的情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;index+<span class="number">3</span> &amp;&amp;i&lt;s.length();i++)&#123; <span class="comment">//for循环，一个IP地址的一次最多取三个数组</span></span><br><span class="line">                cur += s.charAt(i);</span><br><span class="line">                <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(cur);</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> nums; <span class="comment">//临时变量用来存储nums，用于回溯</span></span><br><span class="line">                <span class="keyword">if</span>(number&lt;=<span class="number">255</span> &amp;&amp; (cur.length()==<span class="number">1</span> || cur.charAt(<span class="number">0</span>)!=<span class="string">&#x27;0&#x27;</span>))&#123; <span class="comment">//判断条件</span></span><br><span class="line">                    <span class="keyword">if</span>(ipNumber!=<span class="number">3</span>)&#123; <span class="comment">//判断是不是最后一次</span></span><br><span class="line">                        nums+=cur+<span class="string">&quot;.&quot;</span>; </span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        nums+=cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dfs(res,s,ipNumber+<span class="number">1</span>,i+<span class="number">1</span>); <span class="comment">//接着递归</span></span><br><span class="line">                    nums = temp; <span class="comment">// 回溯</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/26/%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BAIP%E5%9C%B0%E5%9D%80/%E6%9C%AA%E5%91%BD%E5%90%8D/1661517343582.png" alt="hello"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> top100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/08/17/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/08/17/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">zhuanHuan</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">strNuber</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + number;</span><br><span class="line">        <span class="type">char</span>[] numberChar = strNuber.toCharArray();</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;numberChar.length;i++)&#123;</span><br><span class="line">            s.push(numberChar[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">geWei</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> geWei;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                res.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">shiWei</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;shiWei;i++)&#123;</span><br><span class="line">                res.append(<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">baiWei</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;baiWei;i++)&#123;</span><br><span class="line">                res.append(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res.reverse();</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> learing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
