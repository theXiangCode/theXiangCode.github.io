<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络知识点介绍 | The Xiang Blog</title><meta name="keywords" content="OSI七层模式,TCP/IP模式,五层体系接收,HTTP,FTP,SMTP,DNS,URL,根域名服务器,org域名服务器,edu域名服务器,ack,三次握手,四次挥手,Socket,洪范攻击,HTTP状态码,GET和POST,Session,Cookie,TCP,IP,URI,拥塞控制,重传机制,TCP和UDP,ICMP,IGMP,XSS,Ping,数字签名,SSL,RSA"><meta name="author" content="Xiang Liu"><meta name="copyright" content="Xiang Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍了计算机网络中的一些知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络知识点介绍">
<meta property="og:url" content="http://example.com/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="The Xiang Blog">
<meta property="og:description" content="介绍了计算机网络中的一些知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/bg.jpg">
<meta property="article:published_time" content="2022-09-10T12:26:42.061Z">
<meta property="article:modified_time" content="2022-09-10T12:39:16.986Z">
<meta property="article:author" content="Xiang Liu">
<meta property="article:tag" content="OSI七层模式">
<meta property="article:tag" content="TCP&#x2F;IP模式">
<meta property="article:tag" content="五层体系接收">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="FTP">
<meta property="article:tag" content="SMTP">
<meta property="article:tag" content="DNS">
<meta property="article:tag" content="URL">
<meta property="article:tag" content="根域名服务器">
<meta property="article:tag" content="org域名服务器">
<meta property="article:tag" content="edu域名服务器">
<meta property="article:tag" content="ack">
<meta property="article:tag" content="三次握手">
<meta property="article:tag" content="四次挥手">
<meta property="article:tag" content="Socket">
<meta property="article:tag" content="洪范攻击">
<meta property="article:tag" content="HTTP状态码">
<meta property="article:tag" content="GET和POST">
<meta property="article:tag" content="Session">
<meta property="article:tag" content="Cookie">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="IP">
<meta property="article:tag" content="URI">
<meta property="article:tag" content="拥塞控制">
<meta property="article:tag" content="重传机制">
<meta property="article:tag" content="TCP和UDP">
<meta property="article:tag" content="ICMP">
<meta property="article:tag" content="IGMP">
<meta property="article:tag" content="XSS">
<meta property="article:tag" content="Ping">
<meta property="article:tag" content="数字签名">
<meta property="article:tag" content="SSL">
<meta property="article:tag" content="RSA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/bg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络知识点介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-10 20:39:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/title.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../image/bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">The Xiang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络知识点介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-10T12:26:42.061Z" title="发表于 2022-09-10 20:26:42">2022-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-10T12:39:16.986Z" title="更新于 2022-09-10 20:39:16">2022-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>95分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络知识点介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络知识点整理"><a href="#计算机网络知识点整理" class="headerlink" title="计算机网络知识点整理"></a>计算机网络知识点整理</h1><h3 id="1-计算机网络体系结构？"><a href="#1-计算机网络体系结构？" class="headerlink" title="1.计算机网络体系结构？"></a>1.计算机网络体系结构？</h3><p>计算机网络体系结构，一般有三种：OSI七层模型、TCP&#x2F;IP模型、五层体系结构</p>
<p>  <img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656853006626.png" alt="1656853006626"></p>
<p>简单的来说，OSI是理论上的网络通信模型，TCP&#x2F;IP是实际上的网络通信模型，五层网络结构就是为了介绍网络原理而折中的网络通信模型</p>
<hr>
<p><strong>七层模型</strong></p>
<p>OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<ul>
<li><p>应用层：</p>
<p>应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互的规则，常见的协议有：<strong>HTTP FTP  SMTP SNMP DNS</strong>.</p>
</li>
<li><p>表示层：</p>
<p>表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。</p>
</li>
<li><p>会话层：</p>
<p>虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，自动寻址的功能。于是会话层出现了：它的作用就是建立和管理应用程序之间的通信。</p>
</li>
<li><p>传输层：</p>
<p>当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。</p>
<p>简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。</p>
</li>
<li><p>网络层：</p>
<p>计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。</p>
<p>该层的主要任务就是：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。</p>
</li>
<li><p>数据链路层：</p>
<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p>
<p>它的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。</p>
</li>
<li><p>物理层：</p>
<p>解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等。它主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。</p>
<p>它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p>
<hr>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656902115939.png" alt="1656902115939"></p>
</li>
</ul>
<h3 id="2-说一下每一层对应的网络协议有哪些？"><a href="#2-说一下每一层对应的网络协议有哪些？" class="headerlink" title="2.说一下每一层对应的网络协议有哪些？"></a>2.说一下每一层对应的网络协议有哪些？</h3><table>
<thead>
<tr>
<th>OSI七层网络模型</th>
<th>对应的网络协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>FTP、HTTP、DNS 、SMTP、DHCP、Telent</td>
</tr>
<tr>
<td>表示层</td>
<td>TIFF、GIF、JPEG</td>
</tr>
<tr>
<td>会话层</td>
<td>PC、SQL、names、AppleTalk、NFS</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP、ICMP、ARP、RARP、RIP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>FDDI、PPP、HDLC</td>
</tr>
<tr>
<td>物理层</td>
<td>IEEE802.1A 、IEEE802.2-IEEE8.2.11</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>FDDI：</strong></p>
<p>光纤分布式数据接口（FDDI）是由美国国家标准化组织（ANSI）制定的<strong>在光缆上发送数字信号的一组协议</strong>。 FDDI使用双环令牌，传输速率可以达到100Mb&#x2F;s。 由于支持高宽带和远距离通信网络，FDDI通常用作骨干网。光纤分布式数据接口FDDI是一种以光纤作为传输介质的高速主干网，它可以用来互连单个计算机与局域网。</p>
</li>
<li><p><strong>PPP：</strong></p>
<p>PPP（Point-to-Point Protocol点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。</p>
</li>
<li><p><strong>HDLC：</strong></p>
<p>HDLC（High-Level Data Link Control，高级数据链路控制），是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E5%B1%82/10624635">链路层</a>协议的一项国际标准，用以实现远程用户间资源共享以及信息交互。HDLC协议用以保证传送到下一层的数据在传输过程中能够准确地被接收，也就是差错释放中没有任何损失，并且序列正确。HDLC协议的另一个重要功能是流量控制，即一旦接收端收到数据，便能立即进行传输。</p>
</li>
</ul>
<h3 id="3-数据是如何在各层之间传输的？"><a href="#3-数据是如何在各层之间传输的？" class="headerlink" title="3.数据是如何在各层之间传输的？"></a>3.数据是如何在各层之间传输的？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656902800902.png" alt="1656902800902"></p>
<p>整体来说就是发送方首先要把需要发送的数据层层包装，自上层到下层层层包装，知道物理层比特流传输到接收方，然后接收方自下层层层解开包装，直到获取数据。</p>
<ol>
<li>首先某个进程（也就是应用层）准备好需要传输的数据，然后准备发送给接收方，如果接受方是域名那么还需要通过DNS解析成IP地址</li>
<li>把需要传输的数据交付到传输层（TCP&#x2F;UDP层），传输层对数据需要进行适当的分组操作，然后对于每一个分组数据加上首部字段形成一个报文段（或者叫做用户数据报），首部字段包括有源端口号、目的端口号以及一些其它的校验和等数据</li>
<li>把报文段交付到网际层（IP层），对分组数据加上首部形成IP数据报，首部包括源地址、目的地址以及校验和等数据</li>
<li>将数据交付到数据链路层（mac层），这一步需要把IP数据报封装成帧（添加首部【SOH】和尾部【EOT】），然后进行透明传输（也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节&#x2F;字符填充），在这一步首部字段包括源地址、目的地址（都是mac地址）以及尾部的字段CRC校验和</li>
<li>然后把数据交付到物理层，根据数据链路层提供的mac地址，通过特定的传输介质传送到下一个地址</li>
<li>如果源主机和最终的目的主机在同一个网段，那么就在这个网段找到自己的目的主机，将数据发送给目的主机，如果不再同一个网段，那么需要通过路由器转发数据，一直到找到目的主机所在的网段为止，这样就找到了目的主机</li>
<li>然后将数据交付到数据链路层，对于数据进行解封装，并且对于接收的数据进行差错检测，产生差错的数据都会被丢弃掉</li>
<li>传送到IP层，解帧校验</li>
<li>交付到传输层，在目的主机上，根据端口找到对应的应用，当使用的TCP协议时，提供一种面向连接的可靠的传输服务，可以说是建立了一个虚拟通道，源主机的数据通过该虚拟通道进行传输；若是使用的UDP协议时，提供一种面向的非连接的尽最大努力的不可靠的传输服务，数据传输快，但是无法保证数据100%传输</li>
<li>建立了传输连接后，应用开始接收数据，发送方数据和接收方都必须满足相同的标准应用层协议，如http、ftp、smtp等，通过标准协议应用即可正确的接收源主机发送过来的数据</li>
</ol>
<h3 id="4-从浏览器地址栏输入一个URL到显示主页的过程？"><a href="#4-从浏览器地址栏输入一个URL到显示主页的过程？" class="headerlink" title="4.从浏览器地址栏输入一个URL到显示主页的过程？"></a>4.从浏览器地址栏输入一个URL到显示主页的过程？</h3><p>这道题，大概的过程比较简单，但是有很多点可以细挖：DNS解析、TCP三次握手、HTTP报文格式、TCP四次挥手等等。</p>
<ol>
<li>DNS需要解析域名：将输入的URL解析成对应的IP地址</li>
<li>TCP连接：与服务器通过三次握手，建立TCP连接</li>
<li>向服务器发送HTTP请求</li>
<li>服务器处理请求，返回HTTP响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开TCP连接：TCP四次挥手，连接结束</li>
</ol>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656919478648.png" alt="1656919478648"></p>
<p>各个过程中使用到的协议：</p>
<p>DNS：获取域名对应的IP地址</p>
<p>TCP：与服务器建立连接和断开连接</p>
<p>IP：使用TCP协议时需要使用IP协议，用于寻找到对应主机所在位置</p>
<p>OPSF：IP数据包再路由器之间，路由之间如何选择，需要使用OPSF协议</p>
<p>ARP：路由器与服务器通信的时候需要把IP地址转换为IP地址，因此需要使用到ARP协议</p>
<p>HTTP协议：TCP连接建立完成之后，需要使用HTTP协议传递HTTP报文</p>
<h3 id="5-说说DNS解析的过程？"><a href="#5-说说DNS解析的过程？" class="headerlink" title="5.说说DNS解析的过程？"></a>5.说说DNS解析的过程？</h3><p>DNS是域名解析系统，由于IP地址四个数据不容易记忆，因此人们便使用英文等容易记忆的网站来代替IP地址的记忆，但是在传输数据的过程中，实际还是IP地址，因此需要DNS域名解析系统将网站解析为IP地址。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656918479625.png" alt="1656918479625"></p>
<p>就拿<a href="http://www.baidu.com网站的IP地址查询过程如下：">www.baidu.com网站的IP地址查询过程如下：</a></p>
<ul>
<li>首先第一步会查询浏览器的缓存，看看能否查询到该域名对应的IP地址，找到就返回，找不到就进行下一步</li>
<li>然后将请求发往本地DNS服务器（存放在C盘某个目录下 C:WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts.sam），如果查到就直接返回，否则进行下一步</li>
</ul>
<p><img src="F:\带数据学习\大数据开发八股文\计算机网络\计算机网络知识点整理.assets\011bdcdebece49b0a8e428f81eba7551_tplv-k3u1fbpfcp-zoom-in-crop-mark_3780_0_0_0.awebp" alt="域名服务器层级"></p>
<ul>
<li>本地DNS服务器向根域名服务器发送请求，根域名服务器返回负责com的顶级域名服务器的IP地址的列表</li>
<li>本地DNS服务器再向其中一个负责com的顶级域名服务器发送一个请求，返回负责baidu.com的权限域名服务器的IP地址列表</li>
<li>本地DNS服务器再向其中一个权限域名服务器发送一个请求，请求返回网站所对应的IP地址。</li>
</ul>
<h3 id="6-详解TCP三次握手以及四次挥手？"><a href="#6-详解TCP三次握手以及四次挥手？" class="headerlink" title="6.详解TCP三次握手以及四次挥手？"></a>6.详解TCP三次握手以及四次挥手？</h3><h5 id="6-1详解三次握手？"><a href="#6-1详解三次握手？" class="headerlink" title="6.1详解三次握手？"></a>6.1详解三次握手？</h5><p>TCP是面向连接的服务，在传送数据之前必须要建立连接，而TCP连接是通过三次握手来建立的</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656986424748.png" alt="1656986424748"></p>
<p>三次握手过程：</p>
<ul>
<li>最开始的时候，客户端和服务器端都是处于close的状态（应该是服务器关机的时候是close），然后服务器端监听客户端的请求（服务器开机监听某个端口变为listen状态），变为listen状态</li>
<li>客户端发送连接请求，申请第一次握手（SYN&#x3D;1，seq&#x3D;x），发送完毕之后，客户端进入SYN_SENT状态</li>
<li>服务端确认连接，第二次握手（SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ACKnum&#x3D;x+1），发送完毕后，客户端进入SYN_RCV状态</li>
<li>客户端收到服务端的确认之后，再次向服务端确认，这就是第三次握手（ACK&#x3D;1，ACKnum&#x3D;y+1），发送完毕后，客户端进入established状态，当服务器端接收到这个包的时候，也会进入established状态</li>
</ul>
<p>注释：<br>第一段的意思是<br>SYN同步序号&#x3D;1：(A)要建立连接了！<br>seq序号&#x3D;x（随机）：因为还没有数据，所以写什么都无所谓</p>
<p>第二段的意思是<br>SYN同步序号&#x3D;1：我(B)同意你(A)建立连接！<br>ACK确认序号&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq序号&#x3D;y（随机）：因为还没有数据，所以写什么都无所谓<br>ack确认号&#x3D;x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据</p>
<p>第三段的意思是<br>SYN&#x3D;0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK&#x3D;1：连接建立了，之后的ACK必须都置为1<br>seq&#x3D;x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack&#x3D;y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p>
<p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方</p>
<ol>
<li><p>序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记，发送方此次发送的数据，在整个数据中的位置</p>
</li>
<li><p>确认号：ack，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1</p>
</li>
<li><p>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等</p>
<p>URG：紧急指针（urgent pointer）有效。</p>
<p>ACK：确认序号有效。（为了与<strong>确认号ack</strong>区分开，我们用大写表示）</p>
<p>PSH：接收方应该尽快将这个报文交给应用层。</p>
<p>RST：重置连接。</p>
<p>SYN：发起一个新连接。</p>
<p>FIN：释放一个连接。</p>
</li>
</ol>
<h5 id="6-2三次握手为什么不能是两次或者是四次？"><a href="#6-2三次握手为什么不能是两次或者是四次？" class="headerlink" title="6.2三次握手为什么不能是两次或者是四次？"></a>6.2三次握手为什么不能是两次或者是四次？</h5><p><strong>为什么不是两次？</strong></p>
<ul>
<li>为了防止服务器端开启一些无用的连接增加服务器开销</li>
<li>防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li>
</ul>
<p>如果是两次握手，会产生上述两种问题。</p>
<ol>
<li><p>客户端首先给服务器端发送了SYN&#x3D;1的第一次握手，服务器端收到请求后，如果是两次握手，那么服务器就直接创建了这个TCP连接，然后返回SYN、ACK、Seq等内容的数据包给客户端，但是由于网络传输的原因丢失掉了，丢失之后客户端一直没有接收到服务器返回的数据包。</p>
<p>如果没有第三次握手来告诉服务器端，客户端已经收到了服务器端传送的数据，服务器端是不会知道客户端没有收到他传输的信息的，因此服务端会认为这个连接有效，会一直开着端口，等到客户端由于超时重传发出新的请求时，服务器端又会开启一个新的端口，这样就会造成很多无效端口的开启，导致资源的浪费。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657013308985.png" alt="1657013308985"></p>
</li>
<li><p>还有一种情况就是由于网络波动，客户端第一次发送的连接请求服务器端一直没有收到，然后超时重传机制，客户端发送第二次请求，但是第一次请求先于第二次请求到达服务器端，服务器端以为时客户端发出的有效请求，从而发生错误。</p>
</li>
</ol>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657018232670.png" alt="1657018232670"></p>
<p>所以我们需要第三次握手来确认这个过程：</p>
<p>通过第三次握手的数据来告诉服务器，客户端是否收到了服务器“第二次握手”时传过去的数据，以及这个连接的序号是否有效。若发送的数据时“收到且没有问题”，那么服务器就正常建立TCP连接，否则TCP连接失败，服务器关闭连接端口，由此减少服务器开销以及接收到失效请求发生的错误。</p>
<p><strong>为什么不是四次？</strong></p>
<p>三次挥手已经足够创建可靠的连接，没有必要再多一次握手导致花费更多的时间建立连接。</p>
<h5 id="6-3-三次握手中每一次没有收到报文会发生什么？"><a href="#6-3-三次握手中每一次没有收到报文会发生什么？" class="headerlink" title="6.3 三次握手中每一次没有收到报文会发生什么？"></a>6.3 三次握手中每一次没有收到报文会发生什么？</h5><ul>
<li><p>第一次握手，服务器端没有收到SYN报文</p>
<p>服务器端不会有任何的操作，而客户端由于没有收到服务器端传来的确认报文，等待一段时间之后就会重新发送SYN报文，如果仍然没有回应，会一直重复这个过程，一直到发送次数超过最大重传次数限制，就会返回连接建立失败</p>
</li>
<li><p>第二次握手，客户端没有收到服务端响应的报文</p>
<p>客户端会继续重传，一直到次数限制，而服务端会阻塞在accept()处，等待客户端发送ACK报文</p>
</li>
<li><p>第三次握手服务端没有收到客户端发送过来的ACK报文</p>
<p>服务器会采取类似客户端的超时重传机制，如果重试次数超过限制，那么accept()调用返回-1，服务器建立连接失败，而此时客户端认为自己已经建立连接成功，因此开始向服务器发送数据，但是服务器端的accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送过来的数据之后会发送RST报文（<strong>用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求</strong>）给客户端，告知客户端TCP连接失败</p>
</li>
</ul>
<h5 id="6-4第二次握手传回了-ACK，为什么还要传回-SYN？"><a href="#6-4第二次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="6.4第二次握手传回了 ACK，为什么还要传回 SYN？"></a>6.4第二次握手传回了 ACK，为什么还要传回 SYN？</h5><p>ACK是为了告诉客户端传来的数据已经接收无误。</p>
<p>而传回SYN是为了告诉客户端，服务端响应的确实是客户端发送的报文。</p>
<h5 id="6-5-第3次握手可以携带数据吗？"><a href="#6-5-第3次握手可以携带数据吗？" class="headerlink" title="6.5 第3次握手可以携带数据吗？"></a>6.5 第3次握手可以携带数据吗？</h5><p>第3次握手是可以携带数据的。</p>
<p>此时客户端已经处于ESTABLISHED状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p>
<p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在SYN报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成CPU和内存的消耗。</p>
<h5 id="6-6-说说半连接队列和-SYN-Flood-攻击的关系？"><a href="#6-6-说说半连接队列和-SYN-Flood-攻击的关系？" class="headerlink" title="6.6 说说半连接队列和 SYN Flood 攻击的关系？"></a>6.6 说说半连接队列和 SYN Flood 攻击的关系？</h5><p><strong>什么是半连接队列？</strong></p>
<p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657020088935.png" alt="1657020088935"></p>
<p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p>
<ul>
<li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 <strong>ACK 和 SYN</strong>，状态由 <strong>LISTEN 变为 SYN_RCVD</strong>，此时这个连接就被推入了 <strong>SYN 队列</strong>，即半连接队列。</li>
<li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。</li>
</ul>
<p><strong>什么是SYN Flood ？</strong></p>
<p>SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造<strong>不存在的 IP 地址</strong>, 向服务器发送大量SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么SYN队列里的连接旧不会出对队，久⽽久之就会占满服务端的 <strong>SYN</strong> 接收队列（半连接队列），使得服务器不能为正常⽤户服务。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657020182492.png" alt="1657020182492"></p>
<p><strong>那有什么应对方案呢？</strong></p>
<p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p>
<p><strong>syn cookie</strong>：SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃</p>
<p><strong>SYN Proxy 防火墙</strong>：SYN Proxy则是管家式的防御，它站在攻击者和目标服务器之间，伪装成目标服务器对所有的SYN报文进行应答，包括攻击者在内。当三次握手正确的建立起来后，就伪装成客户端IP地址与后端的目标服务器建立三次握手，然后转发数据，需要注意的是，TCP三次握手在这里变成了6次握手，而且两个握手内的ACK号肯定不一致，需要做一个修正。</p>
<h5 id="6-7-说说TCP四次挥手的过程？"><a href="#6-7-说说TCP四次挥手的过程？" class="headerlink" title="6.7 说说TCP四次挥手的过程？"></a>6.7 说说TCP四次挥手的过程？</h5><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657021916995.png" alt="1657021916995"></p>
<p>TCP 四次挥手过程：</p>
<ul>
<li>数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起</li>
<li>客户端发送释放连接报文，<strong>第一次挥手</strong> (FIN&#x3D;1，seq&#x3D;u)，发送完毕后，客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>服务端发送确认报文，<strong>第二次挥手</strong> (ACK&#x3D;1，ack&#x3D;u+1,seq &#x3D;v)，发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li>
<li>服务端发送释放连接报文，<strong>第三次挥手</strong> (FIN&#x3D;1，ACK1,seq&#x3D;w,ack&#x3D;u+1)，发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li>
<li>客户端发送确认报文，<strong>第四次挥手</strong> (ACK&#x3D;1，seq&#x3D;u+1,ack&#x3D;w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657022248999.png" alt="1657022248999"></p>
<h5 id="6-8TCP-挥手为什么需要四次呢？"><a href="#6-8TCP-挥手为什么需要四次呢？" class="headerlink" title="6.8TCP 挥手为什么需要四次呢？"></a>6.8TCP 挥手为什么需要四次呢？</h5><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h5 id="6-9TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？"><a href="#6-9TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？" class="headerlink" title="6.9TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？"></a>6.9TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h5><p><strong>为什么需要等待？</strong></p>
<ol>
<li><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<p><strong>为什么等待的时间是2MSL？</strong></p>
<p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最长时间，超过这个时间报⽂将被丢弃。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657022839580.png" alt="1657022839580"></p>
<p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p>
<p>⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p>
<h5 id="6-10保活计时器有什么用？"><a href="#6-10保活计时器有什么用？" class="headerlink" title="6.10保活计时器有什么用？"></a>6.10保活计时器有什么用？</h5><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。</p>
<p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<p><strong>6.11CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</strong></p>
<p><strong>CLOSE-WAIT状态有什么意义？</strong></p>
<hr>
<p>服务端收到客户端关闭连接的请求并确认之后，就会进入CLOSE-WAIT状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT状态就是为了保证服务端在关闭连接之前将待发送的数据处理完。</p>
<p> <strong>TIME-WAIT有什么意义？</strong></p>
<p>TIME-WAIT状态发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入TIME-WAIT状态。</p>
<p>它存在的意义主要是两个：</p>
<ul>
<li><p><strong>防⽌旧连接的数据包</strong></p>
<p>如果客户端收到服务端的FIN报文之后立即关闭连接，但是此时服务端对应的端口并没有关闭，如果客户端在相同端口建立新的连接，可能会导致新连接收到旧连接残留的数据包，导致不可预料的异常发生。</p>
</li>
<li><p><strong>保证连接正确关闭</strong></p>
<p>假设客户端最后一次发送的ACK包在传输的时候丢失了，由于TCP协议的超时重传机制，服务端将重发FIN报文，如果客户端没有维持TIME-WAIT状态而直接关闭的话，当收到服务端重新发送的FIN包时，客户端就会使用RST包来响应服务端，导致服务端以为有错误发生，然而实际关闭连接过程是正常的</p>
</li>
</ul>
<h3 id="7-说说-WebSocket-与-Socket-的区别？"><a href="#7-说说-WebSocket-与-Socket-的区别？" class="headerlink" title="7.说说 WebSocket 与 Socket 的区别？"></a>7.说说 WebSocket 与 Socket 的区别？</h3><ul>
<li>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。</li>
</ul>
<p>具体来说，Socket 是一套标准，它完成了对 TCP&#x2F;IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p>
<ul>
<li>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li>
<li>Socket 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li>
</ul>
<h3 id="8-说一下你了解的端口以及对应的服务？"><a href="#8-说一下你了解的端口以及对应的服务？" class="headerlink" title="8.说一下你了解的端口以及对应的服务？"></a>8.说一下你了解的端口以及对应的服务？</h3><table>
<thead>
<tr>
<th>端口</th>
<th>服务</th>
</tr>
</thead>
<tbody><tr>
<td>21</td>
<td>FTP（文件传输协议）</td>
</tr>
<tr>
<td>22</td>
<td>SSH</td>
</tr>
<tr>
<td>23</td>
<td>Telnet（远程登录服务）</td>
</tr>
<tr>
<td>53</td>
<td>DNS域名解析服务</td>
</tr>
<tr>
<td>80</td>
<td>HTTP超文本传输协议</td>
</tr>
<tr>
<td>443</td>
<td>HTTPS</td>
</tr>
<tr>
<td>1080</td>
<td>Sockets</td>
</tr>
<tr>
<td>3306</td>
<td>MySQL 默认端口号</td>
</tr>
<tr>
<td>25</td>
<td>SMTP（简单邮件传输协议）</td>
</tr>
<tr>
<td>6</td>
<td>TCP传输协议</td>
</tr>
<tr>
<td>17</td>
<td>UDP传输协议</td>
</tr>
<tr>
<td>89</td>
<td>OSPF 最短路径优先协议</td>
</tr>
</tbody></table>
<h3 id="9-HTTP常用状态码以及其含义？"><a href="#9-HTTP常用状态码以及其含义？" class="headerlink" title="9.HTTP常用状态码以及其含义？"></a>9.HTTP常用状态码以及其含义？</h3><p>大致分类如下：</p>
<ul>
<li>1XX：信息性状态码（信息。服务器收到请求，请继续执行请求）</li>
<li>2XX：成功状态码（成功。请求被成功接收并处理）</li>
<li>3XX：重定向状态码（重定向。需要进一步操作来完成请求）</li>
<li>4XX：客户端错误状态码（客户端错误。无法完成请求，或请求包含语法错误）</li>
<li>5XX：服务端错误状态码（服务器错误。服务器在处理请求的过程中发生错误）</li>
</ul>
<p>101：切换请求协议，服务器端根据客户端的请求来切换协议，切换到更高级的协议，如HTTP的新版本协议</p>
<p>200：请求成功</p>
<p>301：请求资源永久移动，返回新的URI，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址</p>
<p>302：请求资源临时移动，继续使用原有的URI，服务器从另外的地址响应资源，但是客户端还应该使用这个地址</p>
<p>400：客户端请求的语法错误，服务端无法理解</p>
<p>401：当前请求需要进行认证，对于需要登录的网页，服务器可能返回此响应</p>
<p>403：服务器禁止访问，拒绝此请求</p>
<p>404：服务器找不到请求的网页</p>
<p>500：服务器遇到错误，无法完成请求</p>
<p>505：服务器不支持请求中所用的 HTTP 协议版本</p>
<h3 id="10-HTTP有哪些请求方式？"><a href="#10-HTTP有哪些请求方式？" class="headerlink" title="10.HTTP有哪些请求方式？"></a>10.HTTP有哪些请求方式？</h3><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法</p>
<ol>
<li>Get：请求指定的页面信息，并返回实体主体。</li>
<li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li>
<li>PUT：从客户端向服务器传送的数据取代指定的文档的内容（修改指定资源）。</li>
<li>DELETE：请求服务器删除指定的页面（删除指定URL的资源）。</li>
<li>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法</li>
<li>TRACE：主要用于回环测试</li>
<li>PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新 。</li>
</ol>
<h3 id="11-说一下GET和POST的区别？"><a href="#11-说一下GET和POST的区别？" class="headerlink" title="11.说一下GET和POST的区别？"></a>11.说一下GET和POST的区别？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656928083239.png" alt="1656928083239"></p>
<ol>
<li>从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET  请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET  请求把数据放 URL 上不太安全，而 POST 请求把数据放在请求体里想比较而言安全一些。</li>
<li>从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和 GET&#x2F;POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET  请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据</li>
<li>从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL  能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET  请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN  缓存起来了，大大减少了 Web 服务器的负担。</li>
</ol>
<h3 id="12-GET的长度限制是多少？"><a href="#12-GET的长度限制是多少？" class="headerlink" title="12.GET的长度限制是多少？"></a>12.GET的长度限制是多少？</h3><p>HTTP中的GET方法是通过URL传递数据的，但是URL本身其实并没有对数据的长度进行限制，真正限制GET长度的是浏览器。</p>
<p>例如IE浏览器对URL的最大限制是2000多个字符，大概2kb左右，像Chrome、Firefox等浏览器支持的URL字符数更多，其中FireFox中URL的最大长度限制是65536个字符，Chrome则是8182个字符。</p>
<p>这个长度限制也不是针对数据部分，而是针对整个URL。</p>
<h3 id="13-HTTP请求的过程与原理？"><a href="#13-HTTP请求的过程与原理？" class="headerlink" title="13.HTTP请求的过程与原理？"></a>13.HTTP请求的过程与原理？</h3><p>HTTP协议定义了浏览器如何向服务器请求文档，以及服务器如何把文档传给浏览器</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656931575904.png" alt="1656931575904"></p>
<ul>
<li>每个服务器都有一个进程，它不断监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求</li>
<li>监听到连接请求，就会建立TCP连接</li>
<li>浏览器向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应</li>
<li>最后，释放TCP连接</li>
</ul>
<p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议HTTP。</p>
<h3 id="14-HTTP的报文结构？"><a href="#14-HTTP的报文结构？" class="headerlink" title="14.HTTP的报文结构？"></a>14.HTTP的报文结构？</h3><p>HTTP报文有两种，HTTP请求报文和HTTP响应报文</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656931718378.png" alt="1656931718378"></p>
<p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。</p>
<p>请求行包含三个字段：</p>
<ul>
<li>方法字段：包括POST、GET等请方法。</li>
<li>URL 字段</li>
<li>HTTP 版本字段</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656931726039.png" alt="1656931726039"></p>
<p>HTTP 响应报文的第一行叫做<strong>状态行</strong>，后面的行是<strong>首部行</strong>，最后是<strong>实体主体</strong>。</p>
<ul>
<li><p><strong>状态行</strong>包含了三个字段：协议版本字段、状态码和相应的状态信息。</p>
</li>
<li><p><strong>实体部分</strong>是报文的主要部分，它包含了所请求的对象。</p>
</li>
<li><p><strong>首部行</strong></p>
<p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。 </p>
<ul>
<li>常见的请求首部有 Accept ：可接收媒体资源的类型、Accept-Charset： 可接收的字符集、Host ：请求的主机名，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</li>
<li>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</li>
</ul>
</li>
</ul>
<h3 id="15-URI和URL的区别？"><a href="#15-URI和URL的区别？" class="headerlink" title="15.URI和URL的区别？"></a>15.URI和URL的区别？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656933075929.png" alt="1656933075929"></p>
<p>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是Web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都是由一个URI进行标识的。</p>
<p>URL，统一资源定位符（Uniform Resource Location)，它是URI的一种子集，主要作用是提供资源的路径。</p>
<p>它们的主要区别在于，URL除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人。</p>
<p>最好的说明就是java的继承关系。url继承了uri，因为url继承了所有uri的内容，所以它比uri更加详细，但是uri是它的父级。</p>
<h3 id="16-HTTP-x2F-1-0、1-1、2-0、3-0的区别"><a href="#16-HTTP-x2F-1-0、1-1、2-0、3-0的区别" class="headerlink" title="16.HTTP&#x2F;1.0、1.1、2.0、3.0的区别."></a>16.HTTP&#x2F;1.0、1.1、2.0、3.0的区别.</h3><p>关键需要记住 <strong>HTTP&#x2F;1.0</strong> 默认是短连接，可以强制开启，HTTP&#x2F;1.1 默认长连接，HTTP&#x2F;2.0 采用<strong>多路复用</strong>。</p>
<p><strong>HTTP&#x2F;1.0:</strong></p>
<ul>
<li>默认使用<strong>短连接</strong>，每次请求都需要建立一个 TCP 连接。它可以设置<code>Connection: keep-alive</code> 这个字段，强制开启长连接。</li>
</ul>
<p> HTTP&#x2F;1.0浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求简单来讲，每次与服务器交互，都需要新开一个连接.</p>
<p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接,这种形式明显造成了性能上的缺陷</p>
<p><strong>HTTP&#x2F;1.1:</strong></p>
<ol>
<li><p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟,这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p>
</li>
<li><p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p>
</li>
<li><p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善功能，引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略</p>
</li>
<li><p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code></p>
</li>
</ol>
<p><strong>HTTP&#x2F;2.0:</strong></p>
<p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一些特性：</p>
<ol>
<li>多路复用：在一个连接里，客户端和浏览器都可以<strong>同时</strong>发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</li>
<li>二进制分帧：1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。</li>
<li>首部压缩：HTTP&#x2F;2对消息头采用压缩传输，能够节省消息头占用的网络的流量，而HTTP&#x2F;1.x每次请求都会携带大量的冗余头信息，浪费了很多带宽资源。HTTP&#x2F;2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;只有第一次请求需要把所有头部的键值对发送过去，后面的请求仅仅需要发送差异数据即可。</li>
<li>服务器推送：允许服务端推送资源给客户端，服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源，免得客户端再次创建连接发送请求到服务器端获取。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</li>
</ol>
<p><strong>HTTP&#x2F;3.0:</strong></p>
<p>HTTP3.0主要有两大变化，传输层基于UDP、使用QUIC来保证UDP的可靠性</p>
<h3 id="17-HTTP如何实现长连接？在什么时候会超时？"><a href="#17-HTTP如何实现长连接？在什么时候会超时？" class="headerlink" title="17.HTTP如何实现长连接？在什么时候会超时？"></a>17.HTTP如何实现长连接？在什么时候会超时？</h3><p>HTTP分为长连接和短连接本质上指的是TCP的长短连接，TCP连接是一个双向的通道，它可以保持一段时间内不关闭，因此TCP连接具有真正的长连接和短连接这一说法.</p>
<p>TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样可以减少资源消耗</p>
<p>在HTTP1.0阶段默认是短连接，可以通过设置头部的字段Connection字段为keep-alive，从HTTP1.1之后，连接默认都是长连接。</p>
<ul>
<li>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li>
<li>TCP的keep-alive也包含了三个参数，当TCP连接之后，一旦闲置了<strong>tcp_keepalive_time</strong>，那么服务器需要向客户端确认是否存活，因此需要向客户端发送帧测包，如果没有收到对方的ACK应答，那么就每隔tcp_keepalive_intvl时间再发一次，一直到发送了<strong>tcp_keepalive_probes</strong>次，就会丢弃该连接</li>
</ul>
<h3 id="18-HTTP和HTTPS的区别？"><a href="#18-HTTP和HTTPS的区别？" class="headerlink" title="18.HTTP和HTTPS的区别？"></a>18.HTTP和HTTPS的区别？</h3><ol>
<li>安全问题：HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题，HTTPS较为安全，在HTTP和TCP之间加入了SSL&#x2F;TLS安全协议，使得报文能够加密传输</li>
<li>连接的复杂性：HTTP连接相对简单，TCP三次握手之后就可以进行HTTP的报文传输，而HTTPS在TCP三次握手之后，还需要进行SSL&#x2F;TLS的握手过程，才可以进入加密报文传输</li>
<li>端口号不同：HTTP是80端口号，HTTPS是443</li>
<li>HTTPS需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<h3 id="19-为什么要用HTTPS？解决了哪些问题？"><a href="#19-为什么要用HTTPS？解决了哪些问题？" class="headerlink" title="19.为什么要用HTTPS？解决了哪些问题？"></a>19.为什么要用HTTPS？解决了哪些问题？</h3><p>因为HTTP 是明⽂传输，存在安全上的风险：</p>
<ul>
<li><strong>窃听⻛险</strong>，⽐如通信链路上可以获取通信内容，用户账号被盗。</li>
<li><strong>篡改⻛险</strong>，⽐如强制植⼊垃圾⼴告，视觉污染。</li>
<li><strong>冒充⻛险</strong>，⽐如冒充淘宝⽹站，用户金钱损失。</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943343057.png" alt="1656943343057"></p>
<p>所以引入了HTTPS，HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL&#x2F;TLS 协议，可以很好的解决了这些风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息⽆法被窃取。</li>
<li><strong>校验机制</strong>：⽆法篡改通信内容，篡改了就不能正常显示。</li>
<li><strong>身份证书</strong>：能证明淘宝是真淘宝。</li>
</ul>
<h3 id="20-HTTPS的工作流程？"><a href="#20-HTTPS的工作流程？" class="headerlink" title="20.HTTPS的工作流程？"></a>20.HTTPS的工作流程？</h3><ol>
<li>客户端发起 HTTPS 请求，连接到服务端的 443 端口。</li>
<li>服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</li>
<li>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</li>
<li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</li>
<li>客户端将公钥加密后的密钥发送到服务器。</li>
<li>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</li>
<li>服务器将加密后的密文返回到客户端。</li>
<li>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</li>
</ol>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943742361.png" alt="1656943742361"></p>
<h3 id="21-客户端怎么去校验证书的合法性？"><a href="#21-客户端怎么去校验证书的合法性？" class="headerlink" title="21.客户端怎么去校验证书的合法性？"></a>21.客户端怎么去校验证书的合法性？</h3><p>为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943844348.png" alt="1656943844348"></p>
<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li>
<li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li><p>⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate</p>
<p>Signature 内容，得到⼀个 Hash 值 H2 ；</p>
</li>
<li><p>最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ul>
<p>假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。</p>
<h3 id="22-如何理解-HTTP-协议是无状态的？"><a href="#22-如何理解-HTTP-协议是无状态的？" class="headerlink" title="22.如何理解 HTTP 协议是无状态的？"></a>22.如何理解 HTTP 协议是无状态的？</h3><p>这个<code>无状态</code>的的<code>状态</code>值的是什么？是客户端的状态，所以字面意思，就是HTTP协议中服务端不会保存客户端的任何信息。</p>
<p>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p>
<p><strong>那有什么办法记录状态呢</strong>？</p>
<p>主要有两个办法，Session和Cookie。</p>
<h3 id="23-说说Session-和-Cookie-有什么联系和区别"><a href="#23-说说Session-和-Cookie-有什么联系和区别" class="headerlink" title="23.说说Session 和 Cookie 有什么联系和区别?"></a>23.说说Session 和 Cookie 有什么联系和区别?</h3><p><strong>什么是Session 和 Cookie</strong></p>
<ul>
<li>Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务端可以根据这个Cookie判断用户的身份和状态。</li>
<li>Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656944261698.png" alt="1656944261698"></p>
<p><strong>Session 和 Cookie 到底有什么不同呢？</strong></p>
<ul>
<li>存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。</li>
<li>存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。</li>
</ul>
<p><strong>Session 和 Cookie有什么关联呢？</strong></p>
<p>可以使用Cookie记录Session的标识。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656945589033.png" alt="1656945589033"></p>
<ul>
<li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。</li>
<li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
<p><strong>客户端无法使用Cookie怎么办？</strong></p>
<ul>
<li>拼接到URL里：直接把SessionID作为URL的请求参数</li>
<li>放到请求头里：把SessionID放到请求的Header里，比较常用。</li>
</ul>
<h3 id="24-说说-TCP-报文首部的格式？"><a href="#24-说说-TCP-报文首部的格式？" class="headerlink" title="24.说说 TCP 报文首部的格式？"></a>24.说说 TCP 报文首部的格式？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657024288352.png" alt="1657024288352"></p>
<ul>
<li><strong>16 位端口号</strong>：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li>
<li><strong>32 位序号</strong>：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号</li>
<li><strong>32 位确认号</strong>：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1，即期望对面发送的序号</li>
<li><strong>4 位首部长度</strong>：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节</li>
<li><strong>6 位标志位</strong>：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PST（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li>
<li><strong>16 位窗口大小</strong>：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16 位校验和</strong>：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li>
<li><strong>16 位紧急指针</strong>：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<h3 id="25-TCP-是如何保证可靠性的？"><a href="#25-TCP-是如何保证可靠性的？" class="headerlink" title="25.TCP 是如何保证可靠性的？"></a>25.TCP 是如何保证可靠性的？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025308270.png" alt="1657025308270"></p>
<ol>
<li><p><strong>连接管理</strong>：TCP使用三次握手和四次挥手保证可靠地建立连接和释放连接</p>
</li>
<li><p><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025342064.png" alt="1657025342064"></p>
</li>
<li><p><strong>序列号&#x2F;确认应答</strong>：TCP 给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。就像老师上课，会问一句，这一章听懂了吗？没听懂再讲一遍。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025375370.png" alt="1657025375370"></p>
</li>
<li><p><strong>流量控制：</strong>TCP  连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025416818.png" alt="1657025416818"></p>
</li>
<li><p><strong>最大消息长度</strong>：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p>
</li>
</ol>
<p>​	<img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025452055.png" alt="1657025452055"></p>
<ol start="6">
<li><p><strong>超时重传：</strong>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657025505337.png" alt="1657025505337"></p>
<ol start="7">
<li><p><strong>拥塞控制：</strong>如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657026424971.png" alt="1657026424971"></p>
</li>
</ol>
</li>
</ol>
<h5 id="25-1-说说-TCP-的流量控制？"><a href="#25-1-说说-TCP-的流量控制？" class="headerlink" title="25.1 说说 TCP 的流量控制？"></a>25.1 说说 TCP 的流量控制？</h5><p>TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是<strong>流量控制</strong></p>
<p>TCP 通过<strong>滑动窗口</strong>来控制流量，我们看下简要流程：</p>
<ul>
<li><p>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657027472769.png" alt="1657027472769"></p>
</li>
<li><p>假如当前发送方给接收方发送了 200 个字节，那么，发送方的<code>SND.NXT</code>会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。</p>
</li>
<li><p>接受方收到后，放到缓冲队列里面，REV.WND &#x3D;400-200&#x3D;200 字节，所以 win&#x3D;200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</p>
</li>
<li><p>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND &#x3D; 400-200-100&#x3D;100 字节，即 win&#x3D;100 返回发送方。</p>
</li>
<li><p>发送方继续发送 100 字节过来，这时候，接收窗口 win 变为 0。</p>
</li>
<li><p>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</p>
</li>
</ul>
<h5 id="25-2详细说说-TCP-的滑动窗口"><a href="#25-2详细说说-TCP-的滑动窗口" class="headerlink" title="25.2详细说说 TCP 的滑动窗口?"></a>25.2详细说说 TCP 的滑动窗口?</h5><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p>
<p>“用一个比喻，我们在微信上聊天，你打完一句话，我回复一句之后，你才能打下一句。假如我没有及时回复呢？你是把话憋着不说吗？然后傻傻等到我回复之后再接着发下一句？”</p>
<p>为了解决这个问题，TCP 引入了<strong>窗口</strong>，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p>
<p>TCP 头部有个字段叫 win，也即那个 <strong>16 位的窗口大小</strong>，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p>
<p>“通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是 win。”</p>
<p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p>
<ul>
<li>已发送且已收到 ACK 确认</li>
<li>已发送但未收到 ACK 确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657029289716.png" alt="1657029289716"></p>
<ul>
<li>深蓝色框里就是发送窗口。</li>
<li>SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 10个，即发送窗口大小是 10。</li>
<li>SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li>
<li>SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li>
</ul>
<p>接收方的滑动窗口包含三大部分，如下：</p>
<ul>
<li>已成功接收并确认</li>
<li>未收到数据但可以接收</li>
<li>未收到数据并不可以接收的数据</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657029386995.png" alt="1657029386995"></p>
<ul>
<li>蓝色框内，就是接收窗口。</li>
<li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li>
<li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li>
</ul>
<h3 id="26-了解Nagle-算法和延迟确认吗？"><a href="#26-了解Nagle-算法和延迟确认吗？" class="headerlink" title="26.了解Nagle 算法和延迟确认吗？"></a>26.了解Nagle 算法和延迟确认吗？</h3><p><strong>Nagle 算法和延迟确认是干什么的？</strong></p>
<p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657029521819.png" alt="1657029521819"></p>
<p>这就好像快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费。</p>
<p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p>
<ul>
<li>Nagle 算法</li>
<li>延迟确认</li>
</ul>
<p><strong>Nagle 算法</strong></p>
<hr>
<p>Nagle 算法：<strong>任意时刻，最多只能有一个未被确认的小段</strong>。所谓 “小段”，指的是小于 MSS 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。</p>
<p>Nagle 算法的策略：</p>
<ul>
<li>没有已发送未确认报⽂时，⽴刻发送数据。</li>
<li>存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据。</li>
</ul>
<p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。</p>
<p><strong>延迟确认</strong></p>
<hr>
<p>事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。</p>
<p>为了解决 ACK 传输效率低问题，所以就衍⽣出了 <strong>TCP</strong> 延迟确认。</p>
<p>TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅</li>
<li>当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送</li>
<li>如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK</li>
</ul>
<p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p>
<h3 id="27-说说TCP-的拥塞控制？"><a href="#27-说说TCP-的拥塞控制？" class="headerlink" title="27.说说TCP 的拥塞控制？"></a>27.说说TCP 的拥塞控制？</h3><p><strong>什么是拥塞控制？不是有了流量控制吗？</strong></p>
<p>前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。</p>
<p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p>
<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤….</p>
<p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p>
<p>于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p>
<p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，调节所要发送数据的量。</p>
<p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong></p>
<p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p>
<p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p>
<p>拥塞窗⼝ cwnd 变化的规则：</p>
<ul>
<li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li>
<li>但⽹络中出现了拥塞， cwnd 就减少；</li>
</ul>
<p><strong>拥塞控制有哪些常用算法？</strong></p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657030810370.png" alt="1657030810370"></p>
<hr>
<p><strong>慢启动算法</strong></p>
<p>它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p>
<p>举个例子：</p>
<ul>
<li>连接建⽴完成后，⼀开始初始化 cwnd &#x3D; 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li>
<li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发4 个，所以这⼀次能够发送 8 个。</li>
</ul>
<p>发包的个数是指数性的增⻓。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657031515801.png" alt="1657031515801"></p>
<p>为了防止 cwnd 增长过大引起网络拥塞，还需设置一个<strong>慢启动阀值 ssthresh</strong>（slow start threshold）状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 <strong>cwnd &gt;ssthresh</strong> 时，进入了<strong>拥塞避免</strong>算法。</p>
<hr>
<p><strong>拥塞避免算法</strong></p>
<p>一般来说，慢启动阀值 ssthresh 是 65535 字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p>
<ul>
<li>每收到一个 ACK 时，cwnd &#x3D; cwnd + 1&#x2F;cwnd</li>
<li>当每过一个 RTT（往返时间） 时，cwnd &#x3D; cwnd + 1</li>
</ul>
<p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p>
<p>接着上面慢启动的例子，假定 ssthresh 为 8 ： ：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9个 MSS ⼤⼩的数据，变成了线性增⻓</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657031788159.png" alt="1657031788159"></p>
<hr>
<p><strong>拥塞发生</strong></p>
<p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p>
<ul>
<li>RTO 超时重传</li>
<li>快速重传</li>
</ul>
<p>如果是发生了 <strong>RTO（Retransmission Timeout） 超时重传</strong>，就会使用拥塞发生算法</p>
<ul>
<li>慢启动阀值 sshthresh &#x3D;  cwnd &#x2F;2</li>
<li>cwnd 重置为 1</li>
<li>进入新的慢启动过程</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657031957004.png" alt="1657031957004"></p>
<p>其实还有更好的处理方式，就是<strong>快速重传</strong>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 <strong>RTO 超时</strong>再重传。</p>
<p>发⽣快速重传的拥塞发⽣算法：</p>
<ul>
<li>拥塞窗口大小 cwnd &#x3D; cwnd&#x2F;2</li>
<li>慢启动阀值 ssthresh &#x3D; cwnd</li>
<li>进入快速恢复算法</li>
</ul>
<hr>
<p><strong>快速恢复</strong></p>
<p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：</p>
<ul>
<li>cwnd &#x3D; cwnd &#x2F;2</li>
<li>sshthresh &#x3D; cwnd</li>
</ul>
<p>然后，进⼊快速恢复算法如下：</p>
<ul>
<li>cwnd &#x3D; sshthresh  + 3</li>
<li>重传重复的那几个 ACK（即丢失的那几个数据包）</li>
<li>如果再收到重复的 ACK，那么 cwnd &#x3D; cwnd +1</li>
<li>如果收到新数据的 ACK 后, cwnd &#x3D; sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657032229484.png" alt="1657032229484"></p>
<h3 id="28-说说-TCP-的重传机制？"><a href="#28-说说-TCP-的重传机制？" class="headerlink" title="28.说说 TCP 的重传机制？"></a>28.说说 TCP 的重传机制？</h3><p>重传包括<strong>超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种</strong>。</p>
<p>超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。</p>
<p><strong>超时时间应该设置为多少呢？</strong></p>
<p>先来看下什么叫 <strong>RTT（Round-Trip Time，往返时间）</strong>。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033574911.png" alt="1657033574911"></p>
<p>RTT 就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。</p>
<p>超时重传时间，就是 RTO（Retransmission Timeout)。那么，<strong>RTO 到底设置多大呢？</strong></p>
<ul>
<li>如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。</li>
<li>如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。</li>
</ul>
<p>一般来说，RTO 略微大于 RTT，效果是最佳的。</p>
<p>其实，RTO 有个标准方法的计算公式，也叫 <strong>Jacobson &#x2F; Karels 算法</strong>。</p>
<ol>
<li>首先计算 SRTT（即计算平滑的 RTT）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均</span><br></pre></td></tr></table></figure>

<ol>
<li>其次，计算 RTTVAR (round-trip time variation)</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距</span><br></pre></td></tr></table></figure>

<ol>
<li>最后，得出最终的 RTO</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  </span><br></pre></td></tr></table></figure>

<p>在 Linux 下，<strong>α &#x3D; 0.125</strong>，<strong>β &#x3D; 0.25</strong>， <strong>μ &#x3D; 1</strong>，<strong>∂ &#x3D; 4</strong>。别问这些参数是怎么来的，它们是大量实践，调出的最优参数。</p>
<p>超时重传不是十分完美的重传方案，它有这些缺点：</p>
<ul>
<li>当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。</li>
<li>当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li>
</ul>
<p><strong>快速重传</strong></p>
<p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它不以时间为驱动，⽽是以数据驱动重传。</p>
<p>它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。</p>
<p>可以用它来解决超时重发的时间等待问题，快速重传流程如下：</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033685703.png" alt="1657033685703"></p>
<p>在上图，发送⽅发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li>发送端收到了三个 <strong>Ack &#x3D; 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。</p>
<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。</p>
<p>为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。</p>
<p><strong>带选择确认的重传（SACK）</strong></p>
<p>为了解决应该重传多少个包的问题? TCP 提供了<strong>带选择确认的重传</strong>（即 SACK，Selective Acknowledgment）。</p>
<p><strong>SACK 机制</strong>就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033741917.png" alt="1657033741917"></p>
<p>如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。</p>
<p><strong>重复 SACK（D-SACK）</strong></p>
<p>D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。</p>
<p>DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p>
<p>例如ACK丢包导致的数据包重复：</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657033787704.png" alt="1657033787704"></p>
<ul>
<li>接收⽅发给发送⽅的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~</li>
</ul>
<p>3499）</p>
<ul>
<li>于是接收⽅发现数据是重复收到的，于是回了⼀个 <strong>SACK &#x3D; 3000~3500</strong>，告诉「发送⽅」 3000~3500的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个SACK 就代表着 D-SACK 。这样发送⽅就知道了，数据没有丢，是接收⽅的 ACK 确认报⽂丢了。</li>
</ul>
<h3 id="29-说说TCP-的粘包和拆包？"><a href="#29-说说TCP-的粘包和拆包？" class="headerlink" title="29.说说TCP 的粘包和拆包？"></a>29.说说TCP 的粘包和拆包？</h3><p><strong>什么是TCP粘包和拆包？</strong></p>
<p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被 TCP 拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的 TCP 粘包和拆包问题。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657034152293.png" alt="1657034152293"></p>
<p><strong>为什么会产生粘包和拆包呢?</strong></p>
<ul>
<li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li>
</ul>
<p><strong>如何解决粘包和拆包呢?</strong></p>
<ul>
<li>发送端将每个数据包封装为固定长度</li>
<li>在数据尾部增加特殊字符进行分割</li>
<li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li>
</ul>
<h3 id="30-说说-TCP-和-UDP-的区别？"><a href="#30-说说-TCP-和-UDP-的区别？" class="headerlink" title="30.说说 TCP 和 UDP 的区别？"></a>30.说说 TCP 和 UDP 的区别？</h3><p>最根本区别：<strong>TCP 是面向连接，而 UDP 是无连接</strong>。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657034396605.png" alt="1657034396605"></p>
<p><strong>说说TCP和UDP的应用场景？</strong></p>
<p><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、收发邮件、远程登录。</p>
<p><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</p>
<h3 id="31-为什么QQ采用UDP协议？"><a href="#31-为什么QQ采用UDP协议？" class="headerlink" title="31.为什么QQ采用UDP协议？"></a>31.为什么QQ采用UDP协议？</h3><p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657034519504.png" alt="1657034519504"></p>
<ul>
<li>首先，QQ并不是完全基于UDP实现。比如在使用QQ进行文件传输等活动的时候，就会使用TCP作为可靠传输的保证。</li>
<li>使用UDP进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP是一个全双工协议，需要建立连接，所以网络开销也会相对大。</li>
<li>如果使用QQ语音和QQ视频的话，UDP的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li>
<li>由于QQ的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务</li>
</ul>
<p>简单总结一下：UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。</p>
<h3 id="32-UDP协议为什么不可靠？"><a href="#32-UDP协议为什么不可靠？" class="headerlink" title="32.UDP协议为什么不可靠？"></a>32.UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="33-DNS为什么要用UDP"><a href="#33-DNS为什么要用UDP" class="headerlink" title="33.DNS为什么要用UDP?"></a>33.DNS为什么要用UDP?</h3><p>更准确地说，DNS既使用TCP又使用UDP。</p>
<p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而TCP允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的TCP。</p>
<p>当客户端想DNS服务器查询域名（域名解析）的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节，用UDP传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<h3 id="34-IP-协议的定义和作用？"><a href="#34-IP-协议的定义和作用？" class="headerlink" title="34.IP 协议的定义和作用？"></a>34.IP 协议的定义和作用？</h3><p><strong>IP协议是什么？</strong></p>
<p>IP协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在<strong>网际层</strong>，主要目的就是为了提高网络的可扩展性。</p>
<p>通过<strong>网际协议IP</strong>，可以把参与互联的，性能各异的网络<strong>看作一个统一的网络</strong>。</p>
<p>和传输层TCP相比，IP协议是一种无连接&#x2F;不可靠、尽力而为的数据包传输服务，和TCP协议一起构成了TCP&#x2F;IP协议的核心。</p>
<p><strong>IP协议有哪些作用？</strong></p>
<p>IP协议主要有以下几个作用：</p>
<ul>
<li><strong>寻址和路由</strong>：在IP数据报中携带源IP地址和目的IP地址来表示该数据包的源主机和目标主机。IP数据报在传输过程中，每个中间节点（IP网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP协议根据路由选择协议提供的路由信息对IP数据报进行转发，直至目标主机。</li>
<li><strong>分段和重组</strong>：IP数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP协议通过给每个IP数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的IP数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的IP数据报。</li>
</ul>
<p><strong>传输层协议和网络层协议有什么区别？</strong></p>
<p>网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。</p>
<h3 id="35-IP-地址有哪些分类？"><a href="#35-IP-地址有哪些分类？" class="headerlink" title="35.IP 地址有哪些分类？"></a>35.IP 地址有哪些分类？</h3><p>一个IP地址在这个互联网范围内是唯一的，一般可以这么认为，IP 地址 &#x3D; {&lt;网络号&gt;，&lt;主机号&gt;}</p>
<ol>
<li><strong>网络号</strong>：它标志主机所连接的网络地址表示属于互联网的哪一个网络。</li>
<li><strong>主机号</strong>：它标志主机地址表示其属于该网络中的哪一台主机</li>
</ol>
<p>IP 地址分为 A，B，C，D，E 五大类：</p>
<ul>
<li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。</li>
<li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。</li>
<li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。</li>
<li>D 类地址 (224~239)：以 1110 开头，保留为多播地址。</li>
<li>E 类地址 (240~255)：以 1111开头，保留位为将来使用</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657072903791.png" alt="1657072903791"></p>
<h3 id="36-域名和-IP-的关系？一个-IP-可以对应多个域名吗？"><a href="#36-域名和-IP-的关系？一个-IP-可以对应多个域名吗？" class="headerlink" title="36.域名和 IP 的关系？一个 IP 可以对应多个域名吗？"></a>36.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</h3><ul>
<li>IP地址在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号</li>
<li>域名在同一个网络中也是唯一的，就像是一个人的名字、绰号</li>
</ul>
<p>假如你有多个不用的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是惟一的。但同时你的绰号也可能和别人重复，假如你不在，有人叫你的绰号，其它人可能就答应了。</p>
<p>一个域名可以对应多个IP，但这种情况DNS做负载均衡的，在用户访问过程中，一个域名只能对应一个IP。</p>
<p>而一个IP却可以对应多个域名，是一对多的关系。</p>
<h3 id="37-IPV4-地址不够如何解决？"><a href="#37-IPV4-地址不够如何解决？" class="headerlink" title="37.IPV4 地址不够如何解决？"></a>37.IPV4 地址不够如何解决？</h3><p>我们知道，IP地址有32位，可以标记2的32次方个地址，听起来很多，但是全球的网络设备数量已经远远超过这个数字，所以IPV4地址已经不够用了，那怎么解决呢？</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657073285959.png" alt="1657073285959"></p>
<ul>
<li><p>DHCP：动态主机配置协议，动态分配IP地址，只给接入网络的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，该协议使得空闲的IP地址可以得到充分利用。</p>
</li>
<li><p>CIDR：无类别域间路由。CIDR消除了传统的A类、B类、C类地址以及划分子网的概念，因而更加有效地分配IPv4的地址空间，但无法从根本上解决地址耗尽的问题。CIDR使用 CIDR 前缀的值指定地址中作为网络 ID 的位数，  这个前缀可以位于地址空间的任何位置，让管理者能够以更灵活的方式定义子网，以简便的形式指定地址中网络 ID 部分和主机 ID 部分。</p>
<p>CIDR 标记使用一个斜线<code>/</code>分隔符，后面跟一个十进制数值表示地址中网络部分所占的位数。例如，205.123.196.183&#x2F;25 中的 25 表示地址中 25 位用于网络 ID，相应的掩码为 255.255.255.128。  </p>
</li>
<li><p>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的IP地址，从而一定程度上缓解了IP资源枯竭的问题，然而主机在局域网中使用的IP地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT方法可以将该主机IP地址转换为全球IP地址。该协议能够有效解决IP地址不足的问题。</p>
</li>
<li><p>IPv6：作为接替IPv4的下一代互联网协议，其可以实现2的128次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个IP地址也够用，该协议能够从根本上解决IPv4地址不够用的问题。</p>
</li>
</ul>
<h3 id="38-说下-ARP-协议的工作过程？"><a href="#38-说下-ARP-协议的工作过程？" class="headerlink" title="38.说下 ARP 协议的工作过程？"></a>38.说下 ARP 协议的工作过程？</h3><p>ARP 协议，<strong>Address Resolution Protocol</strong>，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657073516743.png" alt="1657073516743"></p>
<ul>
<li>首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</li>
<li>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。</li>
<li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ul>
<p><strong>跨网段通信</strong></p>
<hr>
<p>不同网段的主机通信时，主机会封装网关（通常是路由器）的mac地址，然后主机将数据发送给路由器，后续路由进行路由转发，通过ARP解析目标地址的mac地址，然后将数据包送达目的地。具体过程分析如下：</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657075972489.png" alt="1657075972489"></p>
<ol>
<li>主机A有数据发往主机B，数据封装的时候发现没有主机B的mac地址，需要查询本机ARP列表，发现自身不存在，于是计算目标地址发现和自身不属于同一个网段，因此需要使用默认网关，但是自身也不存在默认网关的mac地址，因此需要查询网关的mac地址；、</li>
<li>主机先把数据放到缓存中，发送ARP查询报文：封装自己的mac地址为源地址，目标mac地址写全F的广播地址，请求网关的mac地址，然后以广播的方式发送出去；</li>
<li>路由器收到广播的数据包之后，首先把A主机的mac地址添加到自己的mac地址表中，路由发现是请求自己的mac地址，然后会回复一个ARP应答包，封装自己的IP地址为源地址，自己的mac地址为源mac地址，发送一个单播应答</li>
<li>主机收到应答之后，把网关的mac地址对应网关的IP地址保存下来，并把数据包封装上网关的mac地址进行发送；</li>
<li>路由器收到数据包之后，检查目的IP地址，查目的IP地址，发现不是给自己的，决定要进行路由，然后查询路由表，需要发往192.168.4.0网段中的192.168.4.2地址。路由准备从相应接口上发出去，然后查询mac地址表，发现没有主机B的映射。路由器发送ARP请求查询主机B的mac地址（原理同2、3步，主机B收到请求后首先会添加网关的mac地址，然后单播回复ARP请求）</li>
<li>路由器收到主机B的mac地址后，将其添加到路由mac地址表中，然后将缓存中的数据2层帧头去掉，封装自己的mac地址为源mac，主机B的mac地址为目的mac（源和目的IP地址不变），加上二层帧头及校验，发送给主机B；</li>
<li>主机B收到数据之后，进行处理，发送过程结束</li>
<li>如果主机B收到数据后进行回复，主机B会进行地址判断，不在同一网段，然后决定将数据发送给网关，主机B查询mac地址表获得网关mac地址，将数据封装后发送（ARP地址解析的过程不再需要了，mac地址表条目有一定的有效时间），网关收到数据后直接查询mac表，将二层帧mac地址更改为A的mac发送出去。如此，主机A收到主机B的回复；</li>
</ol>
<h3 id="39-私有IP和公有IP以及NAT网络地址转化协议"><a href="#39-私有IP和公有IP以及NAT网络地址转化协议" class="headerlink" title="39.私有IP和公有IP以及NAT网络地址转化协议"></a>39.私有IP和公有IP以及NAT网络地址转化协议</h3><p>IP地址可以分为私有IP和公有IP，出现这种规划的原因在于IPv4可以表示的IP太少，但是电脑太多导致IP不够用，只有公有IP可以直接连接上网络，对于一些公司、学校、政府都是集中使用私有IP来进行管理，大家在一个局域网使用私有IP，共同使用一个公有IP，这样可以有效解决IP地址不足的问题，而私有地址和公有地址的转换就是使用的NAT网络地址转换协议</p>
<p>早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些企业内部的网络设定，于是就有了私有IP (Private IP) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有 IP 网段，那就是：</p>
<ul>
<li>Class A：10.0.0.0    - 10.255.255.255</li>
<li>Class B：172.16.0.0  - 172.31.255.255</li>
<li>Class C：192.168.0.0 - 192.168.255.255</li>
</ul>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657075298841.png" alt="1657075298841"></p>
<h3 id="40-为什么既有IP地址，又有MAC-地址？"><a href="#40-为什么既有IP地址，又有MAC-地址？" class="headerlink" title="40.为什么既有IP地址，又有MAC 地址？"></a>40.为什么既有IP地址，又有MAC 地址？</h3><p><strong>MAC地址和IP地址都有什么作用？</strong></p>
<ul>
<li>MAC地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li>
<li>IP地址是网络层和以上各层使用的地址，是一种逻辑地址。IP地址用来区别网络上的计算机。</li>
</ul>
<p><strong>为什么有了MAC地址还需要IP地址？</strong></p>
<p>如果我们只使用MAC地址进行寻址的话，我们需要路由器记住每个MAC地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的MAC地址。而我们知道MAC地址的长度为48位，也就是最多共有2的48次方个MAC地址，这就意味着每个路由器需要256T的内存，显然是不现实的。</p>
<p>和MAC地址不同，IP地址是和地域相关的，在一个子网中的设备，我们给其分配的IP地址前缀都是一样的，这样路由器就能根据IP地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p>
<p><strong>为什么有了IP地址还需要MAC地址？</strong></p>
<ul>
<li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配IP地址，在设备还没有IP地址的时候，或者在分配IP的过程中。我们需要MAC地址来区分不同的设备。</li>
<li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21546408%EF%BC%88%E4%B8%80%E7%AF%87%E8%BF%98%E4%B8%8D%E9%94%99%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89">https://www.zhihu.com/question/21546408（一篇还不错的介绍）</a></p>
<h3 id="41-ICMP、IGMP"><a href="#41-ICMP、IGMP" class="headerlink" title="41.ICMP、IGMP"></a>41.ICMP、IGMP</h3><p><strong>ICMP</strong></p>
<hr>
<p>ICMP（Internet Control Message Protocol） ，网际控制报文协议。</p>
<p>ICMP工作在TCP&#x2F;IP体系中的网络层，是IP协议的一个补充，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。ICMP报文通常被IP层或更高层协议(TCP或UDP)使用。<strong>ICMP报文是在IP数据报内部传输的</strong>。IP协议是不可靠协议，不能保证 IP数据报能够成功的到达目的主机，无法进行差错控制，当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657089869782.png" alt="1657089869782"></p>
<ul>
<li>类型：一个<strong>8位</strong>类型字段，表示 ICMP 数据包类型；</li>
<li>代码：一个<strong>8位</strong>代码域，表示指定类型中的一个功能，如果一个类型中只有一种功能，代码域置为 0；</li>
<li>检验和：数据包中 ICMP 部分上的一个<strong>16位</strong>检验和；</li>
<li>ICMP数据部分：包含了所有接受到的数据报的<strong>IP报头</strong>，还包含IP数据报中<strong>前8个字节</strong>的数据。</li>
</ul>
<p>8位类型和8位代码字段一起决定了ICMP报文的类型。</p>
<p>16位的检验和字段：包括数据在内的整个ICMP数据包的检验和，其计算方法和IP头部检验和的计算方法一样的。</p>
<p>ICMP报文具体分<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>(对ICMP差错报文有时需要做特殊处理，因此要对其进行区分。如：对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文，否则会出现死循环)。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657090051507.png" alt="1657090051507"></p>
<ul>
<li><strong>终点不可达：</strong>IP路由器无法将IP数据报发送给目的地址时，会给发送端主机返回一个终点不可达ICMP消息。例如我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回Type&#x3D;3、Code&#x3D;3的ICMP报文，它要告诉我们：“嘿，别连接了，我不在家的！”，常见的不可到达类型还有网络不可到达（Code&#x3D;0）、主机不可到达（Code&#x3D;1）、协议不可到达（Code&#x3D;2）等。</li>
<li><strong>时间超过：</strong>超时报文的代码域有两种取值：Code&#x3D;0表示传输超时，Code&#x3D;1表示重组分段超时。 IP 数据包中有一个字段TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减1，当路由器收到生存时间TTL为零的数据报时，除丢弃该数据报外，还要向源站发送时间超过报文。当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，就将已收到的数据报片都丢弃，并向源站发送时间超过报文。</li>
<li><strong>参数问题：</strong>当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就丢弃该数据报，并向源站发送参数问题报文。</li>
<li><strong>改变路由（重定向）：</strong>如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个ICMP 重定向消息给这个主机，<strong>这个消息包含了最合适的路由信息和源数据</strong>。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个ICMP 重定向消息给发送端主机一个更合适的发送路由。</li>
<li><strong>回送消息：</strong>用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。我们日常使用最多的ping，就是响应请求（Type&#x3D;8）和应答（Type&#x3D;0），一台主机向一个节点发送一个Type&#x3D;8的ICMP报文，如果途中没有异常（例如被路由器丢弃、目标不回应ICMP或传输失败），则目标返回Type&#x3D;0的ICMP报文，说明这台主机存在。</li>
<li><strong>时间戳消息</strong>：时间戳请求报文（Type&#x3D;13）和时间戳应答报文（Type&#x3D;14）用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接收方收到请求后填充接收时间戳后以Type&#x3D;14的报文格式返回，发送方计算这个时间差。一些系统不响应这种报文。</li>
</ul>
<p>以下几种情况都不会导致产生ICMP差错报文：</p>
<ul>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）；</li>
<li>目的地址是广播地址或多播地址的IP数据报；</li>
<li>作为链路层广播的数据报；</li>
<li>不是IP分片的第一片；</li>
<li>源地址不是单个主机的数据报。即源地址不能为零地址、环回地址、广播地址或多播地址。</li>
</ul>
<p><strong>IGMP</strong></p>
<hr>
<p>IGMP也是IP协议的一个补充，位于TCP&#x2F;IP体系中的网络层。</p>
<ol>
<li><p><strong>单播：</strong>单播是说，对特定的主机进行数据传送。例如给某一个主机发送IP数据包。这时候，数据链路层给出的数据头里面是非常具体的目的地址，对于以太网来 说，就是网卡的MAC地址。现在的具有路由功能的主机应该可以将单播数据定向转发，而目的主机的网络接口则可以过滤掉和自己MAC地址不一致的数据。</p>
</li>
<li><p><strong>广播：</strong>广播是主机针对某一个网络上的所有主机发送数据包。这个网络可能是网络，可能是子网，还可能是所有的子网。如果是网络，例如A类网址的广播就是 netid.255.255.255，如果是子网，则是netid.netid.subnetid.255；如果是所有的子网（B类IP）则是则是 netid.netid.255.255。广播所用的MAC地址FF-FF-FF-FF-FF-FF。网络内所有的主机都会收到这个广播数据，网卡只要把 MAC地址为FF-FF-FF-FF-FF-FF的数据交给内核就可以了。一般说来ARP，或者路由协议RIP应该是以广播的形式播发的。</p>
</li>
<li><p><strong>多播：</strong>可以说广播是多播的特例，多播就是给一组特定的主机（多播组）发送数据，这样，数据的播发范围会小一些(实际上播发的范围一点也没有变小)，多播的MAC地址是最高字节的低位为一，例 如01-00-00-00-00-00。<strong>多播组的地址是D类IP，规定是224.0.0.0-239.255.255.255。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</span><br><span class="line">224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；</span><br><span class="line">224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</span><br><span class="line">239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。</span><br></pre></td></tr></table></figure>

<p>虽然多播比较特殊，但是究其原理，多播的数据还是要通过数据链路层进行MAC地址绑定然后进行发送。所以一个以太网卡在绑定了一个多播IP地址之后，必 定还要绑定一个多播的MAC地址，才能使得其可以像单播那样工作。这个多播的IP和多播MAC地址有一个对应的算法。可以看到 这个对应不是一一对应的，主机还是要对多播数据进行过滤。</p>
<p>PS:广播和多播的性质是一样的，路由器会把数据放到局域网里面，然后网卡对这些数据进行过滤，只拿到自己打算要的数据，比如自己感兴趣的多 播数据，自己感兴趣的组播数据。当一个主机运行了一个处理某一个多播IP的进程的时候，这个进程会给网卡绑定一个虚拟的多播mac地址，并做出来一个多播 ip。这样，网卡就会让带有这个多播mac地址的数据进来，从而实现通信，而那些没有监听这些数据的主机就会把这些数据过滤掉。</p>
</li>
</ol>
<p><strong>组播IP地址和MAC地址的关系</strong></p>
<p>以太网组播地址范围是从01-00-5E-00-00-00到01-00-5E-7F-FF-FF。组播MAC地址的高24bit位是以01-00-5E开头，低23bit为组播IP地址的低23bit。<br> 由于IP组播地址的高4bit是1110，标识了组播组，而低28bit中只有23bit被映像到组播MAC地址上，这样IP组播地址中就会有5bit没有使用，从而出现了32个IP组播地址映像到同一MAC地址上的结果。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657091703878.png" alt="1657091703878"></p>
<p>IGMP，就是Internet Group Management Protocol的意思。该协议用来在IP主机和与其直接相邻的组播路由器之间建立、维护<strong>组播组成员</strong>关系，但不包括组播路由器之间的组成员关系信息的传播与维护，这部分工作由各组播路由协议完成。所有参与组播的主机必须实现IGMP。</p>
<p><strong>1.加入一个多播组</strong></p>
<p>多播的基础就是一个进程的概念（使用的术语进程是指操作系统执行的一个程序），该进程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的—它随时因进程加入和离开多播组而变化。</p>
<p>这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何API所必需的部分。使用限定词“接口”是因为多播组中的成员是与接口相关联的。一个进程可以在多个接口上加入同一多播组。</p>
<p><strong>2.IGMP报告和查询</strong></p>
<p>多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p>
<ol>
<li>当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</li>
<li>进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</li>
<li>多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。</li>
<li>主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。</li>
</ol>
<p>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p>
<p>下图显示了两个IGMP报文，一个是主机发送的报告，另一个是路由器发送的查询。该路由器正在要求那个接口上的每个主机说明它加入的每个多播组。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657091845051.png" alt="1657091845051"></p>
<p><strong>3.离开报文（仅限IGMPv2和v3）</strong></p>
<p>该报文由主机发出。当主机离开组播组时发送此报文，向组播路由器报告离开了特定的组播组。离开报文的目标IP为224.0.0.2（所有组播路由器），IGMP报头内的组播IP为特定离开组的IP。</p>
<p><strong>实现细节</strong></p>
<p>为改善IGMP协议的效率，有许多实现的细节要考虑。首先，当一个主机首次发送IGMP报告（当第一个进程加入一个多播组）时，并不保证该报告被可靠接收（因为使用的是IP交付服务）。下一个报告将在间隔一段时间后发送。这个时间间隔由主机在0 ~ 1 0秒的范围内随机选择。</p>
<p>其次，当一个主机收到一个从路由器发出的查询后，并不立即响应，而是经过一定的时间间隔后才发出一些响应（采用“响应”的复数形式是因为该主机必须对它参加的每个组均发送一个响应）。既然参加同一多播组的多个主机均能发送一个报告，可将它们的发送间隔设置为随机时延。在一个物理网络中的所有主机将收到同组其他主机发送的所有报告，报告中的目的地址是那个组地址。这意味着如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组，而只关心该组是否还至少拥有一个主机。的确，一个多播路由器甚至不关心哪个主机属于一个多播组。它仅仅想知道在给定的接口上的多播组中是否还至少有一个主机。</p>
<p>在没有任何多播路由器的单个物理网络中，仅有的IGMP通信量就是在主机加入一个新的多播组时，支持IP多播的主机所发出的报告。</p>
<h3 id="42-Ping的原理"><a href="#42-Ping的原理" class="headerlink" title="42.Ping的原理"></a>42.Ping的原理</h3><p>ping，<strong>Packet Internet Groper</strong>，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP&#x2F;IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079949682.png" alt="1657079949682"></p>
<p>一般来说，ping 可以用来检测网络通不通。它是基于<code>ICMP</code>协议工作的。假设<strong>机器 A</strong> ping <strong>机器 B</strong>，工作过程如下：</p>
<ol>
<li>ping 通知系统，新建一个固定格式的 ICMP 请求数据包</li>
<li>ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层</li>
<li>IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包</li>
<li>先获取目标机器 B 的 MAC 地址。</li>
<li>数据链路层构建一个数据帧，目的地址是 IP 层传过来的 <strong>MAC 地址</strong>，源地址是本机的 <strong>MAC 地址</strong></li>
<li>机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。</li>
<li>根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间</li>
<li>最终显示结果有这几项：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值</li>
</ol>
<h3 id="43-SSH和telnet的区别？"><a href="#43-SSH和telnet的区别？" class="headerlink" title="43.SSH和telnet的区别？"></a>43.SSH和telnet的区别？</h3><p><strong>telnet</strong></p>
<hr>
<ul>
<li>Telnet取名自Telecommunications和Networks的联合缩写，这是一种在UNIX平台上最为人所熟知的网络协议。</li>
<li>Telnet使用端口23，它是专门为局域网设计的。</li>
<li>Telnet不是一种安全通信协议，因为它并不使用任何安全机制，通过网络&#x2F;互联网传输明文格式的数据，包括密码，所以谁都能嗅探数据包。</li>
<li>Telnet中没有使用任何验证策略及数据加密方法，因而带来了巨大的安全威胁，这就是为什么telnet不再用于通过公共网络访问网络设备和服务器。</li>
</ul>
<p><strong>SSH</strong></p>
<hr>
<ul>
<li>Telnet取名自Telecommunications和Networks的联合缩写，这是一种在UNIX平台上最为人所熟知的网络协议。</li>
<li>Telnet使用端口23，它是专门为局域网设计的。</li>
<li>Telnet不是一种安全通信协议，因为它并不使用任何安全机制，通过网络&#x2F;互联网传输明文格式的数据，包括密码，所以谁都能嗅探数据包。</li>
<li>Telnet中没有使用任何验证策略及数据加密方法，因而带来了巨大的安全威胁，这就是为什么telnet不再用于通过公共网络访问网络设备和服务器。</li>
</ul>
<p><strong>区别</strong></p>
<hr>
<ul>
<li>（1) SSH 和 Telnet 应用领域基本重合。</li>
<li>（2) SSH 比 Telnet 更加安全。</li>
<li>（3) 在发送数据时，SSH会对数据加密，而Telnet不会（它会直接发送明文，包括密码）。</li>
<li>（4) SSH使用公钥授权，而Telnet不使用任何授权。</li>
<li>（5) 在带宽上，SSH 会比Telnet多一点点开销。</li>
<li>（6) SSH 几乎在所有场合代替了Telnet。</li>
</ul>
<h3 id="44-UDP是如何实现可靠传输的？"><a href="#44-UDP是如何实现可靠传输的？" class="headerlink" title="44.UDP是如何实现可靠传输的？"></a>44.UDP是如何实现可靠传输的？</h3><p>UDP将可靠传输的实现放到了应用层，然后类似于TCP，实现确认机制，重传机制<br>UDP不属于连接型协议，因而具有消耗资源小，处理速度快等优点，所以通常音频、视频通话在传送时使用UDP比较多，因为它们即使丢失一两个数据包也不会对结果产生太大影响<br>UDP传输层无法保证数据的可靠传输，只能通过应用层来实现了；实现的方式可以参考TCP可靠传输的方式，只是实现不在传输层，转移到了应用层<br>目前有如下开源程序利用UDP实现了可靠的数据传输；分别有RUDP, RTP, UDT</p>
<p>UDT的主要目的是支持高速广域网上的海量数据传输，所以除了在UDP之上实现类似TCP的协议和算法之外，UDT还对TCP的拥塞算法做了一些细节上的调整，包括Negative-ACK(NAK)、ACK to ACK(ACK2)、基于对数的动态AIMD等。不过UDT的重传效率较低，无效报文，实际效果并不理想。</p>
<h3 id="45-SSL-x2F-TLS-协议"><a href="#45-SSL-x2F-TLS-协议" class="headerlink" title="45.SSL&#x2F;TLS 协议"></a>45.SSL&#x2F;TLS 协议</h3><h3 id="46-路由选择协议介绍"><a href="#46-路由选择协议介绍" class="headerlink" title="46.路由选择协议介绍"></a>46.路由选择协议介绍</h3><h1 id="网络安全知识点整理"><a href="#网络安全知识点整理" class="headerlink" title="网络安全知识点整理"></a>网络安全知识点整理</h1><h3 id="1-说说有哪些安全攻击？"><a href="#1-说说有哪些安全攻击？" class="headerlink" title="1.说说有哪些安全攻击？"></a>1.说说有哪些安全攻击？</h3><p>网络安全攻击主要分为两种类型，<strong>被动攻击</strong>和<strong>主动攻击</strong>：</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657077818854.png" alt="1657077818854"></p>
<p><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。</p>
<p>主动攻击</p>
<p>：直接对现有的数据和服务造成影响，常见的主动攻击类型有： </p>
<ul>
<li><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</li>
<li><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</li>
<li><strong>拒绝服务Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</li>
</ul>
<h3 id="2-DNS劫持了解吗？"><a href="#2-DNS劫持了解吗？" class="headerlink" title="2.DNS劫持了解吗？"></a>2.DNS劫持了解吗？</h3><p>DNS劫持即域名劫持，是通过将原域名对应的IP地址进行替换，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657077861431.png" alt="1657077861431"></p>
<p>域名劫持往往只能在特定的网络范围内进行，范围外的DNS服务器能够返回正常的IP地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它主持，并将新的域名信息保存在所指定的DNS服务器中，从而使用户无法对原域名来进行解析以访问目标地址。</p>
<p><strong>DNS劫持的步骤是什么样的？</strong></p>
<p>获取要劫持的域名信息：攻击者会首先访问域名查询要劫持的站点的域名信息。</p>
<p>控制域名响应的E-Mail账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的E-mail账号所对应的密码，更高级的攻击者甚至能够直接对E-Mail进行信息窃取。</p>
<p>修改注册信息：当攻击者破解了E-Mail后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS服务器信息等。</p>
<p>使用E-Mail收发确认函：在修改完注册信息后，攻击者E-Mail在真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成DNS劫持。</p>
<p><strong>怎么应对DNS劫持？</strong></p>
<ul>
<li>直接通过IP地址访问网站，避开DNS劫持</li>
<li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让DNS指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选DNS服务器的地址固定为8.8.8.8（Google DNS）。</li>
</ul>
<h3 id="3-对称加密与非对称加密有什么区别？"><a href="#3-对称加密与非对称加密有什么区别？" class="headerlink" title="3.对称加密与非对称加密有什么区别？"></a>3.对称加密与非对称加密有什么区别？</h3><p><strong>对称加密</strong>：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078035772.png" alt="1657078035772"></p>
<p><strong>非对称加密</strong>：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078050380.png" alt="1657078050380"></p>
<h3 id="4-RSA和AES区别？"><a href="#4-RSA和AES区别？" class="headerlink" title="4.RSA和AES区别？"></a>4.RSA和AES区别？</h3><p><strong>RSA</strong></p>
<p>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，由于需要大数的乘幂求模等运算，其运算速度较慢，不合适大量数据文件加密。</p>
<p><strong>AES</strong></p>
<p>采用对称加密的方式，其秘钥长度最长只有256个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p>
<h3 id="5-什么是XSS攻击，如何避免？"><a href="#5-什么是XSS攻击，如何避免？" class="headerlink" title="5.什么是XSS攻击，如何避免？"></a>5.什么是XSS攻击，如何避免？</h3><p>XSS 攻击是比较常见，XSS，叫<strong>跨站脚本攻击（Cross-Site Scripting）</strong>，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览网页的时候，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。</p>
<p>XSS 攻击一般分三种类型：<strong>存储型 、反射型 、DOM 型 XSS</strong></p>
<p><strong>XSS 是如何攻击的呢？</strong></p>
<p>简单说，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p>
<p>拿反射型举个例子吧，流程图如下：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL 时，访问正常网站服务器</li>
<li>网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，请求恶意服务器，发送用户数据</li>
<li>攻击者就可以窃取用户的数据，以此冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078333259.png" alt="1657078333259"></p>
<h3 id="6-什么是-DoS、DDoS、DRDoS-攻击？"><a href="#6-什么是-DoS、DDoS、DRDoS-攻击？" class="headerlink" title="6.什么是 DoS、DDoS、DRDoS 攻击？"></a>6.什么是 DoS、DDoS、DRDoS 攻击？</h3><ul>
<li><p><strong>DOS</strong>: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起拒绝 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有<strong>计算机网络宽带攻击</strong>、<strong>连通性攻击</strong>。</p>
</li>
<li><p><strong>DDoS</strong>: (Distributed Denial of Service)，翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器，并利用这些机器对受害者同时实施攻击。</p>
<p>主要形式有流量攻击和资源耗尽攻击，常见的 DDoS攻击有： <strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong> 等。</p>
</li>
<li><p><strong>DRDoS</strong>: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。</p>
</li>
</ul>
<p><strong>如何防范DDoS?</strong></p>
<p>针对DDoS中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p>
<p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的SYN攻击包。我们也可以安装专业的抗DDoS防火墙，从而对抗SYN Flood等流量型攻击</p>
<h3 id="7-什么是-CSRF-攻击？如何避免？"><a href="#7-什么是-CSRF-攻击？如何避免？" class="headerlink" title="7.什么是 CSRF 攻击？如何避免？"></a>7.什么是 CSRF 攻击？如何避免？</h3><p><strong>什么是 CSRF 攻击？</strong></p>
<p>CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p>
<p><strong>CSRF 是如何攻击的呢？</strong></p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657078683791.png" alt="1657078683791"></p>
<p>用户登陆银行，没有退出，浏览器包含了 用户 在银行的身份认证信息。</p>
<p>攻击者将伪造的转账请求，包含在在帖子</p>
<p>用户在银行网站保持登陆的情况下，浏览帖子</p>
<p>将伪造的转账请求连同身份认证信息，发送到银行网站</p>
<p>银行网站看到身份认证信息，以为就是 用户的合法操作，最后造成用户资金损失。</p>
<p><strong>怎么应对 CSRF 攻击呢？</strong></p>
<ul>
<li><strong>检查 Referer 字段</strong>：HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</li>
<li><strong>添加校验 token</strong>：以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li>
<li><strong>敏感操作多重校验</strong>：对一些敏感的操作，除了需要校验用户的认证信息，还可以通过邮箱确认、验证码确认这样的方式多重校验。</li>
</ul>
<h3 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8.数字签名"></a>8.数字签名</h3><p>先说数字签名的基本原理。数字签名过程跟加密通信有着一定的对称性，这种对称有着一种逻辑上的美。</p>
<p>加密通信是用公钥进行加密，而用私钥进行解密。而数字签名刚好相反，是采用私钥加密，公钥解密。对于加密通信，公钥加密过程就是通过加密算法把信息加密成密文，私钥解密过程就是通过解密算法解密密文。而对于数字签名，私钥加密过程是通过签名算法来生成数字签名的过程，而公钥解密过程是通过验证算法来确定数字签名是不是有私钥持有者签署的。可以看到，加密算法，解密算法，签名算法，验证算法，对称性是很明显的。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079095355.png" alt="1657079095355"></p>
<p>数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息，输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是“签名 key”，公钥是“验证 key”。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079169348.png" alt="1657079169348"></p>
<p><strong>实例：</strong></p>
<p>Alice 要签署一个文件，于是她就拿出自己的私钥，执行签名算法，得到数字签名。那么其他人如何去验证这个数字签名的确出自 Alice 呢？首先，Alice 要把自己的公钥放到一个大家都可以访问到的服务器上，这样其他人都可以获得 Alice 的公钥，大家把文件，数字签名以及公钥下载到自己的计算机上，调用验证算法，就可以判断这个文件是不是 Alice 签署的了。不管是签名算法还是验证算法都是全球公开的，每个人都可以在自己的计算机上安装软件来执行这两个算法。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657079290506.png" alt="1657079290506"></p>
<p>这就是一个 Alice 签署文件，其他人验证签名的完整过程了。这个过程中有一点要注意，就是签名本身是不会加密文件本身的。在底层，签名过程其实是加密了文件的哈希值，总之签名的目的不在于加密文件信息，而在于生成数字签名。</p>
<p><strong>数字签名的作用</strong></p>
<p>数字签名有三大作用，第一个是认证，第二个是防止抵赖，第三个是保证文件完整性，也就是没有被篡改过。</p>
<p>先看第一个认证，意思就是确认签署人身份，这个跟纸笔签名的作用是一致的。再看第二个防止抵赖，同样是纸笔签名也拥有的特性，一份合同签署了，就要承担责任，白纸黑字，不能耍赖。第三个作用是保证文件没有被篡改过，这个作用纸笔签名很难保证，比如签名只签署了最后一页，那么如果有人想悄悄换掉了前几页的内容，签名本身是阻止不了的。但是数字签名就可以，因为数字签名是由两个输入运算得出的，一个是私钥，另一个就是文件，所以如果在验证过程中，发现文件有改动，验证会失败。这个很类似于现实世界签合同的时候，有时候需要故意用签名或者图章覆盖有文字的区域，或者在写信的时候，给信封加上蜡封，这些措施也都是为了防篡改。</p>
<p>这就是数字签名的三大作用，主要用在各种防伪造场合，在世界上很多国家，数字签名都是有法律效力的。另外要注意，数字签名属于电子签名的一种，但并不是所有的电子签名都是数字签名，这两个概念要区分一下。</p>
<h3 id="9-数字证书"><a href="#9-数字证书" class="headerlink" title="9.数字证书"></a>9.数字证书</h3><p>为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。</p>
<p><img src="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1656943844348.png" alt="1656943844348"></p>
<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li>
<li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li><p>⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate</p>
<p>Signature 内容，得到⼀个 Hash 值 H2 ；</p>
</li>
<li><p>最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ul>
<p>假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Xiang Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">http://example.com/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">The Xiang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%BC%8F/">OSI七层模式</a><a class="post-meta__tags" href="/tags/TCP-IP%E6%A8%A1%E5%BC%8F/">TCP/IP模式</a><a class="post-meta__tags" href="/tags/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E6%8E%A5%E6%94%B6/">五层体系接收</a><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/FTP/">FTP</a><a class="post-meta__tags" href="/tags/SMTP/">SMTP</a><a class="post-meta__tags" href="/tags/DNS/">DNS</a><a class="post-meta__tags" href="/tags/URL/">URL</a><a class="post-meta__tags" href="/tags/%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/">根域名服务器</a><a class="post-meta__tags" href="/tags/org%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/">org域名服务器</a><a class="post-meta__tags" href="/tags/edu%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/">edu域名服务器</a><a class="post-meta__tags" href="/tags/ack/">ack</a><a class="post-meta__tags" href="/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">三次握手</a><a class="post-meta__tags" href="/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">四次挥手</a><a class="post-meta__tags" href="/tags/Socket/">Socket</a><a class="post-meta__tags" href="/tags/%E6%B4%AA%E8%8C%83%E6%94%BB%E5%87%BB/">洪范攻击</a><a class="post-meta__tags" href="/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/">HTTP状态码</a><a class="post-meta__tags" href="/tags/GET%E5%92%8CPOST/">GET和POST</a><a class="post-meta__tags" href="/tags/Session/">Session</a><a class="post-meta__tags" href="/tags/Cookie/">Cookie</a><a class="post-meta__tags" href="/tags/TCP/">TCP</a><a class="post-meta__tags" href="/tags/IP/">IP</a><a class="post-meta__tags" href="/tags/URI/">URI</a><a class="post-meta__tags" href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">拥塞控制</a><a class="post-meta__tags" href="/tags/%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/">重传机制</a><a class="post-meta__tags" href="/tags/TCP%E5%92%8CUDP/">TCP和UDP</a><a class="post-meta__tags" href="/tags/ICMP/">ICMP</a><a class="post-meta__tags" href="/tags/IGMP/">IGMP</a><a class="post-meta__tags" href="/tags/XSS/">XSS</a><a class="post-meta__tags" href="/tags/Ping/">Ping</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">数字签名</a><a class="post-meta__tags" href="/tags/SSL/">SSL</a><a class="post-meta__tags" href="/tags/RSA/">RSA</a></div><div class="post_share"><div class="social-share" data-image="/../image/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><img class="prev-cover" src="/../image/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基本知识点介绍</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/"><img class="next-cover" src="/../image/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spark内核</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./image/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xiang Liu</div><div class="author-info__description">欢迎访问我的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/theXiangCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://mail.qq.com/" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这几天心理颇不宁静</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86"><span class="toc-text">计算机网络知识点整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">1.计算机网络体系结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%AF%8F%E4%B8%80%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">2.说一下每一层对应的网络协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-text">3.数据是如何在各层之间传输的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">4.从浏览器地址栏输入一个URL到显示主页的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4DNS%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">5.说说DNS解析的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%A6%E8%A7%A3TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-text">6.详解TCP三次握手以及四次挥手？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1%E8%AF%A6%E8%A7%A3%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-text">6.1详解三次握手？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E8%80%85%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">6.2三次握手为什么不能是两次或者是四次？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%AD%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E6%94%B6%E5%88%B0%E6%8A%A5%E6%96%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">6.3 三次握手中每一次没有收到报文会发生什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN%EF%BC%9F"><span class="toc-text">6.4第二次握手传回了 ACK，为什么还要传回 SYN？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-%E7%AC%AC3%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-text">6.5 第3次握手可以携带数据吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-%E8%AF%B4%E8%AF%B4%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C-SYN-Flood-%E6%94%BB%E5%87%BB%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">6.6 说说半连接队列和 SYN Flood 攻击的关系？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-%E8%AF%B4%E8%AF%B4TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">6.7 说说TCP四次挥手的过程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-8TCP-%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">6.8TCP 挥手为什么需要四次呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-9TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2MSL-%E6%89%8D%E8%BF%9B%E5%85%A5-CLOSED-%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">6.9TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-10%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">6.10保活计时器有什么用？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B4%E8%AF%B4-WebSocket-%E4%B8%8E-Socket-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7.说说 WebSocket 与 Socket 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-text">8.说一下你了解的端口以及对应的服务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HTTP%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-text">9.HTTP常用状态码以及其含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-HTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">10.HTTP有哪些请求方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%80%E4%B8%8BGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">11.说一下GET和POST的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-GET%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">12.GET的长度限制是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">13.HTTP请求的过程与原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-HTTP%E7%9A%84%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">14.HTTP的报文结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15.URI和URL的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-HTTP-x2F-1-0%E3%80%811-1%E3%80%812-0%E3%80%813-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">16.HTTP&#x2F;1.0、1.1、2.0、3.0的区别.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-HTTP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%B6%85%E6%97%B6%EF%BC%9F"><span class="toc-text">17.HTTP如何实现长连接？在什么时候会超时？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">18.HTTP和HTTPS的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8HTTPS%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">19.为什么要用HTTPS？解决了哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-text">20.HTTPS的工作流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E6%A0%A1%E9%AA%8C%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9F"><span class="toc-text">21.客户端怎么去校验证书的合法性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-HTTP-%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-text">22.如何理解 HTTP 协议是无状态的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%AF%B4%E8%AF%B4Session-%E5%92%8C-Cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-text">23.说说Session 和 Cookie 有什么联系和区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%AF%B4%E8%AF%B4-TCP-%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="toc-text">24.说说 TCP 报文首部的格式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-TCP-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">25.TCP 是如何保证可靠性的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#25-1-%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">25.1 说说 TCP 的流量控制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-2%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">25.2详细说说 TCP 的滑动窗口?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BA%86%E8%A7%A3Nagle-%E7%AE%97%E6%B3%95%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E5%90%97%EF%BC%9F"><span class="toc-text">26.了解Nagle 算法和延迟确认吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E8%AF%B4%E8%AF%B4TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">27.说说TCP 的拥塞控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E8%AF%B4%E8%AF%B4-TCP-%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">28.说说 TCP 的重传机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%AF%B4%E8%AF%B4TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="toc-text">29.说说TCP 的粘包和拆包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E8%AF%B4%E8%AF%B4-TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">30.说说 TCP 和 UDP 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%B8%BA%E4%BB%80%E4%B9%88QQ%E9%87%87%E7%94%A8UDP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">31.为什么QQ采用UDP协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-UDP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-text">32.UDP协议为什么不可靠？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-DNS%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8UDP"><span class="toc-text">33.DNS为什么要用UDP?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">34.IP 协议的定义和作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-IP-%E5%9C%B0%E5%9D%80%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-text">35.IP 地址有哪些分类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E5%9F%9F%E5%90%8D%E5%92%8C-IP-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E4%B8%80%E4%B8%AA-IP-%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%90%97%EF%BC%9F"><span class="toc-text">36.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-IPV4-%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">37.IPV4 地址不够如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E8%AF%B4%E4%B8%8B-ARP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">38.说下 ARP 协议的工作过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%A7%81%E6%9C%89IP%E5%92%8C%E5%85%AC%E6%9C%89IP%E4%BB%A5%E5%8F%8ANAT%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8C%96%E5%8D%8F%E8%AE%AE"><span class="toc-text">39.私有IP和公有IP以及NAT网络地址转化协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A2%E6%9C%89IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%88%E6%9C%89MAC-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">40.为什么既有IP地址，又有MAC 地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-ICMP%E3%80%81IGMP"><span class="toc-text">41.ICMP、IGMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-Ping%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">42.Ping的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-SSH%E5%92%8Ctelnet%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">43.SSH和telnet的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-UDP%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-text">44.UDP是如何实现可靠传输的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-SSL-x2F-TLS-%E5%8D%8F%E8%AE%AE"><span class="toc-text">45.SSL&#x2F;TLS 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">46.路由选择协议介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86"><span class="toc-text">网络安全知识点整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">1.说说有哪些安全攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DNS%E5%8A%AB%E6%8C%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">2.DNS劫持了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.对称加密与非对称加密有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-RSA%E5%92%8CAES%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.RSA和AES区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">5.什么是XSS攻击，如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF-DoS%E3%80%81DDoS%E3%80%81DRDoS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">6.什么是 DoS、DDoS、DRDoS 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">7.什么是 CSRF 攻击？如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-text">8.数字签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">9.数字证书</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="Java基本知识点介绍"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基本知识点介绍"/></a><div class="content"><a class="title" href="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="Java基本知识点介绍">Java基本知识点介绍</a><time datetime="2022-09-10T12:44:35.832Z" title="发表于 2022-09-10 20:44:35">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="计算机网络知识点介绍"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络知识点介绍"/></a><div class="content"><a class="title" href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="计算机网络知识点介绍">计算机网络知识点介绍</a><time datetime="2022-09-10T12:26:42.061Z" title="发表于 2022-09-10 20:26:42">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/" title="Spark内核"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark内核"/></a><div class="content"><a class="title" href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/" title="Spark内核">Spark内核</a><time datetime="2022-09-10T02:54:42.307Z" title="发表于 2022-09-10 10:54:42">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark一个小案例"/></a><div class="content"><a class="title" href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例">Spark一个小案例</a><time datetime="2022-09-08T15:24:18.328Z" title="发表于 2022-09-08 23:24:18">2022-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="Spark核心编程"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark核心编程"/></a><div class="content"><a class="title" href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="Spark核心编程">Spark核心编程</a><time datetime="2022-09-06T11:27:39.924Z" title="发表于 2022-09-06 19:27:39">2022-09-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../image/bg.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#FF6A6A;animation: announ_animation 0.8s linear infinite;" class="fa fa-heartbeat"></i> Xiang Liu</div><div class="footer_custom_text">兽人永不为奴!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>