<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基本知识点介绍 | The Xiang Blog</title><meta name="keywords" content="Java,类型转换,封装,继承,多态,面向对象,this,final,super,instanceof,native,Object,protected,多线程,Thread,Runable,wait,sleep,Vector,ArrayList,类型通配符,HashSet,HashMap,类的加载,双亲委派机制,JDK1.8新特性,lambda表达式,反射,IO流"><meta name="author" content="Xiang Liu"><meta name="copyright" content="Xiang Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍了Java基本知识点介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基本知识点介绍">
<meta property="og:url" content="http://example.com/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="The Xiang Blog">
<meta property="og:description" content="介绍了Java基本知识点介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/bg.jpg">
<meta property="article:published_time" content="2022-09-10T12:44:35.832Z">
<meta property="article:modified_time" content="2022-09-10T12:52:26.155Z">
<meta property="article:author" content="Xiang Liu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="类型转换">
<meta property="article:tag" content="封装">
<meta property="article:tag" content="继承">
<meta property="article:tag" content="多态">
<meta property="article:tag" content="面向对象">
<meta property="article:tag" content="this">
<meta property="article:tag" content="final">
<meta property="article:tag" content="super">
<meta property="article:tag" content="instanceof">
<meta property="article:tag" content="native">
<meta property="article:tag" content="Object">
<meta property="article:tag" content="protected">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="Thread">
<meta property="article:tag" content="Runable">
<meta property="article:tag" content="wait">
<meta property="article:tag" content="sleep">
<meta property="article:tag" content="Vector">
<meta property="article:tag" content="ArrayList">
<meta property="article:tag" content="类型通配符">
<meta property="article:tag" content="HashSet">
<meta property="article:tag" content="HashMap">
<meta property="article:tag" content="类的加载">
<meta property="article:tag" content="双亲委派机制">
<meta property="article:tag" content="JDK1.8新特性">
<meta property="article:tag" content="lambda表达式">
<meta property="article:tag" content="反射">
<meta property="article:tag" content="IO流">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/bg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基本知识点介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-10 20:52:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/title.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../image/bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">The Xiang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基本知识点介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-10T12:44:35.832Z" title="发表于 2022-09-10 20:44:35">2022-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-10T12:52:26.155Z" title="更新于 2022-09-10 20:52:26">2022-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>99分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基本知识点介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Java基础知识点整理</p>
<h3 id="1-Java八大基础数据类型"><a href="#1-Java八大基础数据类型" class="headerlink" title="1.Java八大基础数据类型"></a>1.Java八大基础数据类型</h3><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248985772.png" alt="1657248985772"></p>
<p>1、整型系列</p>
<p>（1）byte：字节类型</p>
<p>占内存：1个字节</p>
<p>存储范围：-128~127</p>
<p>（2）short：短整型类型</p>
<p>占内存：2个字节</p>
<p>存储范围：-32768~32767</p>
<p>（3）int：整型</p>
<p>占内存：4个字节</p>
<p>存储范围：-2的31次方 ~ 2的31次方-1</p>
<p>（4）long：整型</p>
<p>占内存：8个字节</p>
<p>存储范围：-2的63次方 ~ 2的63次方-1</p>
<blockquote>
<p>注意：如果要表示某个常量数字它是long类型，那么需要在数字后面加L</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//右边的整数必须在-128~127范围内</span></span><br><span class="line"><span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1234567</span>; <span class="comment">//右边的整数如果在int范围呢，编译和运行都可以通过</span></span><br><span class="line"><span class="type">long</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="number">12345678912L</span>;<span class="comment">//右边的整数如果超过int范围，必须加L，否则编译不通过</span></span><br></pre></td></tr></table></figure>



<p>2、浮点型系列（小数）</p>
<p>（1）float：单精度浮点型</p>
<p>占内存：4个字节</p>
<p>精度：科学记数法的小数点后6~7位</p>
<blockquote>
<p>注意：如果要表示某个常量数字是float类型，那么需要在数字后面加F或f</p>
</blockquote>
<p>（2）double：双精度浮点型</p>
<p>占内存：8个字节</p>
<p>精度：科学记数法的小数点后15~16位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">12.0F</span>;<span class="comment">//右边如果赋值小数，那么必须加F或f</span></span><br></pre></td></tr></table></figure>



<p>3、单字符类型</p>
<p>char：字符类型</p>
<p>占内存：2个字节</p>
<p>4、布尔类型</p>
<p>boolean：只能存储true或false</p>
<blockquote>
<p>虽然计算机底层使用0和1表示false和true，但是在代码中不能给boolean类型的变量赋值0和1，只能赋值false和true</p>
</blockquote>
<h3 id="2-为什么float-4个字节可表示数字确大于long8个字节？"><a href="#2-为什么float-4个字节可表示数字确大于long8个字节？" class="headerlink" title="2.为什么float 4个字节可表示数字确大于long8个字节？"></a>2.为什么float 4个字节可表示数字确大于long8个字节？</h3><p>因为float是使用的IEEE754标准，32位从前到后分为符号位、指数位、尾数位，使用科学计数法来表示。</p>
<ol>
<li>Sign（1位）：用来表示浮点数是正数还是负数，0表示正数，1表示负数。</li>
<li>Exponent（8位）：指数部分。即上文提到数字c，但是这里不是直接存储c，为了同时表示正负指数以及他们的大小顺序，这里实际存储的是c+127。</li>
<li>Mantissa（23位）：尾数部分。也就是上文中提到的数字b。</li>
</ol>
<p>指数部分可以表示到2的127次幂</p>
<h3 id="3-基本数据类型的转换"><a href="#3-基本数据类型的转换" class="headerlink" title="3.基本数据类型的转换"></a>3.基本数据类型的转换</h3><h4 id="1、自动类型转换（隐式类型转换）"><a href="#1、自动类型转换（隐式类型转换）" class="headerlink" title="1、自动类型转换（隐式类型转换）"></a>1、自动类型转换（隐式类型转换）</h4><p>自动转换可以把取值范围小的类型自动提升为取值范围大的</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657247692362.png" alt="1657247692362"></p>
<h4 id="2、强制类型转换（显示类型转换）"><a href="#2、强制类型转换（显示类型转换）" class="headerlink" title="2、强制类型转换（显示类型转换）"></a>2、强制类型转换（显示类型转换）</h4><p>强制类型转换就是需要把取值范围大的类型转换为取值范围小的类型。</p>
<p><strong>转换格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = （数据类型）被强转数据值；</span><br></pre></td></tr></table></figure>

<p>（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换，提示：有风险，可能会损失精度或溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">3.14</span>;<span class="comment">//强制类型转换，损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)d;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;<span class="comment">//溢出</span></span><br></pre></td></tr></table></figure>

<p>（2）boolean类型不参与</p>
<p>（3）当某个值想要提升数据类型时，也可以使用强制类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">shang</span> <span class="operator">=</span> (<span class="type">double</span>)i/j;</span><br></pre></td></tr></table></figure>

<p>提示：这个情况的强制类型转换是没有风险的。</p>
<h4 id="3、特殊的数据类型转换"><a href="#3、特殊的数据类型转换" class="headerlink" title="3、特殊的数据类型转换"></a>3、特殊的数据类型转换</h4><p>1、任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + <span class="number">1</span> + <span class="number">2</span>);<span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p>2、但是String类型不能通过强制类型()转换，转为其他的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)str;<span class="comment">//错误的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//后面才能讲到，借助包装类的方法才能转</span></span><br></pre></td></tr></table></figure>

<h3 id="4-和–运算符"><a href="#4-和–运算符" class="headerlink" title="4.++和–运算符"></a>4.++和–运算符</h3><ul>
<li><p>和<code>其他变量放在一起使用</code>或者和<code>输出语句放在一起使用</code>，<code>前++</code>和<code>后++</code>就产生了不同。</p>
</li>
<li><p>变量<code>前++</code> ：变量先自身加1，然后再将加1后的结果进行其他使用。</p>
</li>
<li><p>变量<code>后++</code> ：变量先拿去使用，然后再自身加1。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorDemo03</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 其他变量放在一起使用</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="comment">//int y = ++x; // y的值是4，x的值是4，</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++; <span class="comment">// y的值是3，x的值是4</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(x);</span><br><span class="line">		System.out.println(y);</span><br><span class="line">		System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 和输出语句一起</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="comment">//System.out.println(++z);// 输出结果是6，z的值也是6</span></span><br><span class="line">		System.out.println(z++);<span class="comment">// 输出结果是5，z的值是6</span></span><br><span class="line">		System.out.println(z);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        a = a++;<span class="comment">//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的&quot;1&quot;赋值给a,a=1</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++ + ++i * i++;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从左往右加载</span></span><br><span class="line"><span class="comment">        (1)先算i++</span></span><br><span class="line"><span class="comment">        ①取i的值“1”放操作数栈</span></span><br><span class="line"><span class="comment">        ②i再自增 i=2</span></span><br><span class="line"><span class="comment">        （2）再算++i</span></span><br><span class="line"><span class="comment">        ①i先自增 i=3</span></span><br><span class="line"><span class="comment">        ②再取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">        （3）再算i++</span></span><br><span class="line"><span class="comment">        ①取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">        ②i再自增 i=4</span></span><br><span class="line"><span class="comment">        （4）先算乘法</span></span><br><span class="line"><span class="comment">        用操作数栈中3 * 3 = 9，并把9压会操作数栈</span></span><br><span class="line"><span class="comment">        （5）再算求和</span></span><br><span class="line"><span class="comment">        用操作数栈中的 1 + 9 = 10</span></span><br><span class="line"><span class="comment">        （6）最后算赋值</span></span><br><span class="line"><span class="comment">        j = 10</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li><strong>++在前，先自加，后使用；</strong></li>
<li><strong>++在后，先使用，后自加。</strong></li>
</ul>
<h3 id="5-Java的逻辑运算符（主要是之前没掌握-和-的区别）"><a href="#5-Java的逻辑运算符（主要是之前没掌握-和-的区别）" class="headerlink" title="5.Java的逻辑运算符（主要是之前没掌握|| 和| 的区别）"></a>5.Java的逻辑运算符（主要是之前没掌握|| 和| 的区别）</h3><h4 id="amp-amp-和-amp-区别，-和-区别"><a href="#amp-amp-和-amp-区别，-和-区别" class="headerlink" title="&amp;&amp;和&amp;区别，||和|区别"></a>&amp;&amp;和&amp;区别，||和|区别</h4><ul>
<li>**<code>&amp;&amp;</code>和<code>&amp;</code>**区别：<ul>
<li><code>&amp;&amp;</code>和<code>&amp;</code>结果一样，<code>&amp;&amp;</code>有短路效果，左边为false，右边不执行；<code>&amp;</code>左边无论是什么，右边都会执行。</li>
<li>&amp;也可以当作位运算符</li>
</ul>
</li>
<li>**<code>||</code>和<code>|</code>**区别：<ul>
<li><code>||</code>和<code>|</code>结果一样，<code>||</code>有短路效果，左边为true，右边不执行；<code>|</code>左边无论是什么，右边都会执行。</li>
<li>|也可以当位运算符</li>
</ul>
</li>
</ul>
<h3 id="6-Java语言的跨平台性原理"><a href="#6-Java语言的跨平台性原理" class="headerlink" title="6.Java语言的跨平台性原理"></a>6.Java语言的跨平台性原理</h3><ul>
<li>跨平台<strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为</strong>Java语言的跨平台特性**。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。</li>
<li><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境之一，也是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在<strong>JVM</strong> 之上。</li>
</ul>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248815395.png" alt="1657248815395"></p>
<p>如图所示，Java的虚拟机本身是不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</p>
<ul>
<li>**JRE ** (Java Runtime Environment) ：是Java程序的运行时环境，包含<code>JVM</code> 和运行时所需要的<code>核心类库</code>。</li>
<li><strong>JDK</strong>  (Java Development Kit)：是Java程序开发工具包，包含<code>JRE</code> 和开发人员使用的工具。</li>
</ul>
<p>我们想要运行一个已有的Java程序，那么只需安装<code>JRE</code> 即可。</p>
<p>我们想要开发一个全新的Java程序，那么必须安装<code>JDK</code> ，其内部包含<code>JRE</code>。</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248854324.png" alt="1657248854324"></p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657248865944.png" alt="1657248865944"></p>
<h3 id="7-打印arr数组输出的值是地址吗？"><a href="#7-打印arr数组输出的值是地址吗？" class="headerlink" title="7.打印arr数组输出的值是地址吗？"></a>7.打印arr数组输出的值是地址吗？</h3><p>它不是数组的地址。arr中存储的是数组的首地址，但是因为数组是引用数据类型，打印arr时，会自动调用arr数组对象的toString()方法，默认该方法实现的是对象类型名@该对象的hashCode()值的十六进制值。</p>
<h3 id="8-面向对象思想概述"><a href="#8-面向对象思想概述" class="headerlink" title="8.面向对象思想概述"></a>8.面向对象思想概述</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>Java语言是一种面向对象的程序设计语言，而面向对象思想（OOP）是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。<br>这里的<strong>对象</strong>泛指现实中一切事物，每种事物都具备自己的<strong>属性</strong>和<strong>行为</strong>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。<br>它区别于面向过程思想（POP），强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p>
<h4 id="2、面向对象与面向过程的区别"><a href="#2、面向对象与面向过程的区别" class="headerlink" title="2、面向对象与面向过程的区别"></a>2、面向对象与面向过程的区别</h4><p>面向过程：POP: Process-Oriented Programming</p>
<p>​	以函数（方法）为最小单位</p>
<p>​	数据独立于函数之外</p>
<p>​	以过程，步骤为主，考虑怎么做</p>
<p>面向对象：OOP: Object Oriented Programming</p>
<p>​	以类&#x2F;对象为最小单位，类包括：数据+方法</p>
<p>​	以对象（谁）为主，考虑谁来做，谁能做</p>
<p>面向对象仍然包含面向过程，只不过关注点变了，关注谁来做</p>
<p>程序员的角色：</p>
<p>面向过程：程序员是具体执行者</p>
<p>面向对象：程序员是指挥者</p>
<p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。</p>
<p>例子：把大象装进冰箱</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657615405184.png" alt="1657615405184"></p>
<p>3、面向对象的基本特征</p>
<p>面向对象的语言中，包含了三大基本特征，即封装、继承和多态。</p>
<h3 id="9-权限修饰符"><a href="#9-权限修饰符" class="headerlink" title="9.权限修饰符"></a>9.权限修饰符</h3><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657615499914.png" alt="1657615499914"></p>
<h3 id="10-this、final、super关键字"><a href="#10-this、final、super关键字" class="headerlink" title="10.this、final、super关键字"></a>10.this、final、super关键字</h3><h4 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h4><p>this代表当前对象的引用（地址值），即对象自己的引用。</p>
<ul>
<li>this可以用于构造器中：表示正在创建的那个实例对象，即正在new谁，this就代表谁</li>
<li>this用于实例方法中：表示调用该方法的对象，即谁在调用，this就代表谁。</li>
</ul>
<h4 id="this使用格式"><a href="#this使用格式" class="headerlink" title="this使用格式"></a>this使用格式</h4><p>1、this.成员变量名</p>
<p>当方法的局部变量与当前对象的成员变量重名时，就可以在成员变量前面加this.，如果没有重名问题，就可以省略this.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员变量名；</span><br></pre></td></tr></table></figure>

<p>2、this.成员方法</p>
<p>调用当前对象自己的成员方法时，都可以加”this.”，也可以省略，实际开发中都省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【变量=】<span class="built_in">this</span>.成员方法(【实参列表】);</span><br></pre></td></tr></table></figure>

<p>3、this()或this(实参列表)</p>
<p>当需要调用本类的其他构造器时，就可以使用该形式。</p>
<p>要求：</p>
<p>必须在构造器的首行</p>
<p>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(【实参列表】)”，否则会发生递归调用死循环</p>
<h4 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h4><ul>
<li><p><strong>super</strong> ：代表父类的<strong>存储空间标识</strong>(可以理解为父亲的引用)。</p>
<ul>
<li>通过super找成员变量和成员方法时，直接从父类空间（包含父类的父类继承的）找</li>
<li>super()或super(实参列表)只能从直接父类找</li>
<li>通过super只能访问父类在子类中可见的（非private，跨包还不能是缺省的）</li>
</ul>
</li>
<li><p><strong>this</strong> ：代表<strong>当前对象的引用</strong>。</p>
<ul>
<li>通过this找成员变量和成员方法时，先从当前类中找，没有的会往上找父类的。</li>
<li>但是this()或this(实参列表)只会在本类中找</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：super和this都不能出现在静态方法和静态代码块中，因为super和this都是存在与<strong>对象</strong>中的</p>
</blockquote>
<h4 id="super的用法"><a href="#super的用法" class="headerlink" title="super的用法"></a>super的用法</h4><h5 id="1、super-成员变量"><a href="#1、super-成员变量" class="headerlink" title="1、super.成员变量"></a>1、super.成员变量</h5><p>在子类对象中访问父类空间的成员变量，即访问从父类继承的在子类中仍然可见的成员变量</p>
<h5 id="2、super-成员方法"><a href="#2、super-成员方法" class="headerlink" title="2、super.成员方法"></a>2、super.成员方法</h5><p>在子类对象中访问从父类继承的在子类中仍然可见的成员方法</p>
<h5 id="3、super-或super-实参列表"><a href="#3、super-或super-实参列表" class="headerlink" title="3、super()或super(实参列表)"></a>3、super()或super(实参列表)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>(...)    	--    本类的构造方法</span><br><span class="line"><span class="built_in">super</span>(...)   	--    父类的构造方法</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</p>
<p>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</p>
</blockquote>
<h4 id="final的用法"><a href="#final的用法" class="headerlink" title="final的用法"></a>final的用法</h4><p>final：最终的，不可更改的，它的用法有：</p>
<h5 id="1、修饰类"><a href="#1、修饰类" class="headerlink" title="1、修饰类"></a>1、修饰类</h5><p>表示这个类不能被继承，没有子类</p>
<h5 id="2、修饰方法"><a href="#2、修饰方法" class="headerlink" title="2、修饰方法"></a>2、修饰方法</h5><p>表示这个方法不能被子类重写</p>
<h5 id="3、声明常量"><a href="#3、声明常量" class="headerlink" title="3、声明常量"></a>3、声明常量</h5><p>某个变量如果使用final修饰，那么它的值就不能被修改，即常量</p>
<blockquote>
<p>final可以修饰成员变量（静态的类变量和非静态的实例变量）和局部变量</p>
<p>如果某个成员变量用final修饰后，没有set方法，并且必须有显式赋值语句，不能使用成员变量默认值</p>
<p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p>
</blockquote>
<h3 id="11-类的初始化和实例初始化"><a href="#11-类的初始化和实例初始化" class="headerlink" title="11.类的初始化和实例初始化"></a>11.类的初始化和实例初始化</h3><h4 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h4><p>类被加载内存后，会在方法区创建一个Class对象（后面反射章节详细学习）来存储该类的所有信息。此时会为类的静态变量分配内存，然后为类变量进行初始化。那么，实际上，类初始化的过程时在调用一个<clinit>()方法，而这个方法是编译器自动生成的。编译器会将如下两部分的<strong>所有</strong>代码，<strong>按顺序</strong>合并到类初始化<clinit>()方法体中。</p>
<p>（1）静态类成员变量的显式赋值语句</p>
<p>（2）静态代码块中的语句</p>
<p>整个类初始化只会进行一次，如果子类初始化时，发现父类没有初始化，那么会先初始化父类。</p>
<p>结论：</p>
<p>每一个类都有一个类初始化方法<clinit>()方法，然后子类初始化时，如果发现父类加载和没有初始化，会先加载和初始化父类，然后再加载和初始化子类。一个类，只会初始化一次。</p>
<h4 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h4><p>实际上我们编写的代码在编译时，会自动处理代码，整理出一个<clinit>()的类初始化方法，还会整理出一个或多个的<init>(…)实例初始化方法。一个类有几个实例初始化方法，由这个类有几个构造器决定。</p>
<p>实例初始化方法的方法体，由四部分构成：</p>
<p>（1）super()或super(实参列表)    这里选择哪个，看原来构造器首行是哪句，没写，默认就是super()</p>
<p>（2）非静态实例变量的显示赋值语句</p>
<p>（3）非静态代码块</p>
<p>（4）对应构造器中的代码</p>
<p>特别说明：其中（2）和（3）是按顺序合并的，（1）一定在最前面（4）一定在最后面</p>
<p>执行特点：</p>
<ul>
<li>创建对象时，才会执行，</li>
<li>调用哪个构造器，就是指定它对应的实例初始化方法</li>
<li>创建子类对象时，父类对应的实例初始化会被先执行，执行父类哪个实例初始化方法，看用super()还是super(实参列表)</li>
</ul>
<p>结论：</p>
<p>类初始化肯定优先于实例初始化。</p>
<p>类初始化只做一次。</p>
<p>实例初始化是每次创建对象都要进行。</p>
<h4 id="构造器和非静态代码块"><a href="#构造器和非静态代码块" class="headerlink" title="构造器和非静态代码块"></a>构造器和非静态代码块</h4><p>从某种程度上来看，非静态代码块是对构造器的补充，非静态代码块总是在构造器执行之前执行。与构造器不同的是，非静态代码块是一段固定执行的代码，它不能接收任何参数。因此非静态代码块对同一个类的所有对象所进行的初始化处理完全相同。基于这个原因，不难发现非静态代码块的基本用法，如果有一段初始化处理代码对所有对象完全相同，且无须接收任何参数，就可以把这段初始化处理代码提取到非静态代码块中。</p>
<p>即如果每个构造器中有相同的初始化代码，且这些初始化代码无须接收参数，就可以把它们放在非静态代码块中定义。通过把多个构造器中相同代码提取到非静态代码块中定义，能更好地提高初始代码的复用，提高整个应用的可维护性。</p>
<h3 id="12、多态"><a href="#12、多态" class="headerlink" title="12、多态"></a>12、多态</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h4><p>多态是继封装、继承之后，面向对象的第三大特性。</p>
<p>生活中，比如求面积的功能，圆、矩形、三角形实现起来是不一样的。跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</p>
<h4 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h4><ul>
<li><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</li>
</ul>
<h4 id="3-前提【重点】"><a href="#3-前提【重点】" class="headerlink" title="3. 前提【重点】"></a>3. 前提【重点】</h4><ol>
<li>继承父类或者实现接口【二选一】</li>
<li>方法的重写【意义体现：不重写，无意义】</li>
<li>父类引用指向子类对象【格式体现】</li>
</ol>
<h4 id="4-多态的体现"><a href="#4-多态的体现" class="headerlink" title="4. 多态的体现"></a>4. 多态的体现</h4><p>多态体现的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类对象；</span><br><span class="line">变量名.方法名();<span class="comment">//这个方法是父类中声明，子类中重写的方法</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
<p>多态体现出来的现象：</p>
<p>编译时，看“父类”，只能调用父类声明的方法，不能调用子类扩展的方法；</p>
<p>运行时，看“子类”，一定是执行子类重写的方法体；</p>
<h4 id="5-多态的好处"><a href="#5-多态的好处" class="headerlink" title="5.多态的好处"></a>5.多态的好处</h4><h5 id="1、多态参数"><a href="#1、多态参数" class="headerlink" title="1、多态参数"></a>1、多态参数</h5><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下：</p>
<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态形式，创建对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  </span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用showCatEat </span></span><br><span class="line">        showCatEat(c);</span><br><span class="line">        <span class="comment">// 调用showDogEat </span></span><br><span class="line">        showDogEat(d); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代</span></span><br><span class="line"><span class="comment">        而执行效果一致</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showAnimalEat(c);</span><br><span class="line">        showAnimalEat(d); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showCatEat</span> <span class="params">(Cat c)</span>&#123;</span><br><span class="line">        c.eat(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showDogEat</span> <span class="params">(Dog d)</span>&#123;</span><br><span class="line">        d.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showAnimalEat</span> <span class="params">(Animal a)</span>&#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</p>
<p>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</p>
<p>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</p>
<p>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p>
<h5 id="2、多态数组"><a href="#2、多态数组" class="headerlink" title="2、多态数组"></a>2、多态数组</h5><p>例如：家里养了两只猫，两条狗，想要统一管理他们的对象，可以使用多态数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnimal</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Animal[] all = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">4</span>];<span class="comment">//可以存储各种Animal子类的对象</span></span><br><span class="line">		all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">			all[i].eat();<span class="comment">//all[i]编译时是Animal类型，运行时看存储的是什么对象</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-父子类之间的转换"><a href="#6-父子类之间的转换" class="headerlink" title="6.父子类之间的转换"></a>6.父子类之间的转换</h4><p>多态的转型分为向上转型与向下转型两种：</p>
<h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><ul>
<li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</li>
</ul>
<p>当父类引用指向一个子类对象时，便是向上转型。</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><ul>
<li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。</li>
</ul>
<p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure>

<h5 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h5><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。</p>
<h4 id="7-instanceof运算符"><a href="#7-instanceof运算符" class="headerlink" title="7.instanceof运算符"></a>7.instanceof运算符</h4><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量名/对象 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line"></span><br><span class="line">如果变量/对象属于该数据类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量/对象不属于该数据类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>

<h3 id="13-native关键字"><a href="#13-native关键字" class="headerlink" title="13.native关键字"></a>13.native关键字</h3><p>native：本地的，原生的<br>用法：</p>
<p>​	只能修饰方法</p>
<p>​	表示这个方法的方法体代码不是用Java语言实现的。</p>
<p>​	但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p>
<p>JVM内存的管理：</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1657624802173.png" alt="1657624802173"></p>
<p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p>
<p>虚拟机栈：Java语言实现的方法的局部变量</p>
<p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p>
<p>堆：new出来的对象</p>
<p>程序计数器：记录每一个线程目前执行到哪一句指令</p>
<h3 id="14-Object根父类"><a href="#14-Object根父类" class="headerlink" title="14.Object根父类"></a>14.Object根父类</h3><p>类 <code>java.lang.Object</code>是类层次结构的根类，即所有类的父类。每个类都使用 <code>Object</code> 作为超类。所有对象（包括数组）都实现这个类的方法。</p>
<p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="comment">/*extends Object*/</span> &#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的5个：</p>
<h4 id="1-public-String-toString-："><a href="#1-public-String-toString-：" class="headerlink" title="1.public String toString()："></a>1.public String toString()：</h4><p>①默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p>
<p>②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p>
<p>③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p>
<h4 id="2-public-final-Class-lt-gt-getClass-：获取对象的运行时类型"><a href="#2-public-final-Class-lt-gt-getClass-：获取对象的运行时类型" class="headerlink" title="2.public final Class&lt;?&gt; getClass()：获取对象的运行时类型"></a>2.public final Class&lt;?&gt; getClass()：获取对象的运行时类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">	System.out.println(obj.getClass());<span class="comment">//运行时类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-protected-void-finalize-："><a href="#3-protected-void-finalize-：" class="headerlink" title="3.protected void finalize()："></a>3.protected void finalize()：</h4><p>当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p>
<h4 id="4-public-int-hashCode-："><a href="#4-public-int-hashCode-：" class="headerlink" title="4.public int hashCode()："></a>4.public int hashCode()：</h4><p>返回每个对象的hash值。</p>
<p>规定：①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p>
<p>​	②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p>
<p>主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p>
<h4 id="5-public-boolean-equals-Object-obj-："><a href="#5-public-boolean-equals-Object-obj-：" class="headerlink" title="5.public boolean equals(Object obj)："></a>5.public boolean equals(Object obj)：</h4><p>用于判断当前对象this与指定对象obj是否“相等”</p>
<p>①默认情况下，equals方法的实现等价于与“&#x3D;&#x3D;”，比较的是对象的地址值</p>
<p>②我们可以选择重写，重写有些要求：</p>
<p>A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p>
<p>​	a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p>
<p>​	b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p>
<p>​	c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p>
<h3 id="15-为什么重写equals方法也要重写hashcode"><a href="#15-为什么重写equals方法也要重写hashcode" class="headerlink" title="15.为什么重写equals方法也要重写hashcode()"></a>15.为什么重写equals方法也要重写hashcode()</h3><p>hashcode()和equals()两个方法用来协同判断两个对象是否相等，但是重写equals时，不重写hashCode，就会导致在某些场景下，例如将两个相等的自定义<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cos?from=10680">对象存储</a>在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。</p>
<p>因为Set会调用hashCode方法，如果没有自定义hashCode，那么自定义的两个对象返回的code值肯定不相等，因此直接判断两个对象不相等。</p>
<p>调用顺序：首先使用hashcode方法，再调用equals。</p>
<h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16.接口"></a>16.接口</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong>，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p>
<p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<blockquote>
<p>引用数据类型：数组，类，接口。</p>
</blockquote>
<p>接口的声明格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 interface 接口名&#123;</span><br><span class="line">    <span class="comment">//接口的成员列表：</span></span><br><span class="line">    <span class="comment">// 静态常量</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">7900000</span>;<span class="comment">//这里单位是毫米/秒，7.9千米/秒，超过这个速度，就变成卫星</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">broken</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞行中遇到物体就坏了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK8之前，接口中只运行出现：</p>
<p>（1）公共的静态的常量：其中public static final可以省略</p>
<p>（2）公共的抽象的方法：其中public abstract可以省略</p>
<p>在JDK1.8时，接口中允许声明默认方法和静态方法：</p>
<p>（3）公共的默认的方法：其中public 可以省略，建议保留</p>
<blockquote>
<p>默认方法相当于允许给接口的抽象方法给出默认实现了，这样实现类（子类）既可以选择使用默认实现，还可以选择重写，更灵活了</p>
</blockquote>
<p>（4）公共的静态的方法：其中public 可以省略，建议保留</p>
<h4 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h4><p>为什么JDK1.8之后要允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。</p>
<p><strong>静态方法</strong>：因为之前的标准类库设计中，有很多Collection&#x2F;Colletions或者Path&#x2F;Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。</p>
<p><strong>默认方法</strong>：我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。</p>
<h3 id="17异常体系"><a href="#17异常体系" class="headerlink" title="17异常体系"></a>17异常体系</h3><p>异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658758135179.png" alt="1658758135179"></p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。<ul>
<li>例如：StackOverflowError和OOM（OutOfMemoryError）。</li>
</ul>
</li>
<li><strong>Exception</strong>:表示异常，其它因编程错误或偶然的外在因素导致的一般性问题，程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。<ul>
<li>例如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界</li>
</ul>
</li>
</ul>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会被编译器检测到(不报错)。(如数组索引越界异常，类型转换异常)。程序员应该积极避免其出现的异常，而不是使用try..catch处理，因为这类异常很普遍，若都使用try..catch或throws处理可能会对程序的可读性和运行效率产生影响。</li>
</ul>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658758189730.png" alt="1658758189730"></p>
<h3 id="18-多线程"><a href="#18-多线程" class="headerlink" title="18.多线程"></a>18.多线程</h3><h4 id="18-1-java中多线程的创建和启动方式"><a href="#18-1-java中多线程的创建和启动方式" class="headerlink" title="18.1 java中多线程的创建和启动方式"></a>18.1 java中多线程的创建和启动方式</h4><h5 id="18-1-1-继承Thread类"><a href="#18-1-1-继承Thread类" class="headerlink" title="18.1.1 继承Thread类"></a>18.1.1 继承Thread类</h5><p>Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18-1-2-实现Runnable接口"><a href="#18-1-2-实现Runnable接口" class="headerlink" title="18.1.2 实现Runnable接口"></a>18.1.2 实现Runnable接口</h5><p>Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法</p>
<p>步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li>
<li>调用线程对象的start()方法来启动线程。<br>代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        	System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);         </span><br><span class="line">		&#125;       </span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程<br>代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<p>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
<h5 id="18-1-3-使用匿名内部类对象来实现线程的创建和启动（常用方式）"><a href="#18-1-3-使用匿名内部类对象来实现线程的创建和启动（常用方式）" class="headerlink" title="18.1.3 使用匿名内部类对象来实现线程的创建和启动（常用方式）"></a>18.1.3 使用匿名内部类对象来实现线程的创建和启动（常用方式）</h5><p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658912895136.png" alt="1658912895136"></p>
<p>上述两种都是使用匿名内部类启动线程。两种分别使用了不同的构造方法。</p>
<p>public Thread() :分配一个新的线程对象。<br>public Thread(String name) :分配一个指定名字的新的线程对象。<br>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。<br>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</p>
<h4 id="18-2-Thread常用方法"><a href="#18-2-Thread常用方法" class="headerlink" title="18.2 Thread常用方法"></a>18.2 Thread常用方法</h4><ul>
<li><p>public void run() :此线程要执行的任务在此处定义代码。</p>
</li>
<li><p>public String getName() :获取当前线程名称。</p>
</li>
<li><p>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</p>
</li>
<li><p>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </p>
</li>
<li><p>public final int getPriority() ：返回线程优先级 </p>
</li>
<li><p>public final void setPriority(int newPriority) ：改变线程的优先级</p>
<ul>
<li>每个线程都有一定的优先级，优先级高的线程将获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。Thread类提供了setPriority(int newPriority)和getPriority()方法类设置和获取线程的优先级，其中setPriority方法需要一个整数，并且范围在[1,10]之间，通常推荐设置Thread类的三个优先级常量：</li>
<li>MAX_PRIORITY（10）：最高优先级 </li>
<li>MIN _PRIORITY （1）：最低优先级</li>
<li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</li>
</ul>
</li>
<li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</p>
</li>
<li><p>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</p>
</li>
<li><p>public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</p>
</li>
<li><p>void join() ：等待该线程终止。 </p>
<p>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </p>
<p>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </p>
</li>
<li><p>public final void stop()：强迫线程停止执行。 该方法具有固有的不安全性，已经标记为@Deprecated不建议再使用，那么我们就需要通过其他方式来停止线程了，其中一种方式是使用变量的值的变化来控制线程是否结束。</p>
</li>
</ul>
<h4 id="18-3-线程安全"><a href="#18-3-线程安全" class="headerlink" title="18.3 线程安全"></a>18.3 线程安全</h4><h5 id="18-3-1-同步代码块"><a href="#18-3-1-同步代码块" class="headerlink" title="18.3.1 同步代码块"></a>18.3.1 同步代码块</h5><ul>
<li><p>同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步锁:<br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</li>
</ul>
<p>​	锁对象 可以是任意类型。</p>
<p>​	多个线程对象  要使用同一把锁。<br>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。<br>使用同步代码块解决代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 执行卖票操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 每个窗口卖票的操作</span></span><br><span class="line">		<span class="comment">// 窗口永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">//这里可以选择this作为锁，是因为对于这几个线程，Ticket的this是同一个 </span></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">// 有票可以卖</span></span><br><span class="line">                    <span class="comment">// 出票操作</span></span><br><span class="line">                    <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Ticket</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Ticket</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 执行卖票操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 每个窗口卖票的操作</span></span><br><span class="line">		<span class="comment">// 窗口永远开启</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Ticket.class) &#123;<span class="comment">//这里不能选用this作为锁，因为这几个线程的this不是同一个</span></span><br><span class="line">				<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票可以卖</span></span><br><span class="line">	                <span class="comment">// 出票操作</span></span><br><span class="line">	                <span class="comment">// 使用sleep模拟一下出票时间</span></span><br><span class="line">	                <span class="keyword">try</span> &#123;</span><br><span class="line">	                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">	                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	                    e.printStackTrace();</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line">	                System.out.println(getName() + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line">	            &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="18-3-2-同步方法"><a href="#18-3-2-同步方法" class="headerlink" title="18.3.2 同步方法"></a>18.3.2 同步方法</h5><ul>
<li>同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外<br>等着</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法的锁对象：</p>
<p>（1）静态方法：当前类的Class对象</p>
<p>（2）非静态方法：this</p>
<h5 id="18-3-3-锁机制"><a href="#18-3-3-锁机制" class="headerlink" title="18.3.3 锁机制"></a>18.3.3 锁机制</h5><h4 id="18-4等待唤醒机制"><a href="#18-4等待唤醒机制" class="headerlink" title="18.4等待唤醒机制"></a>18.4等待唤醒机制</h4><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait&#x2F;notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；</li>
<li>否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h4 id="18-5-线程的生命周期"><a href="#18-5-线程的生命周期" class="headerlink" title="18.5 线程的生命周期"></a>18.5 线程的生命周期</h4><p>线程有五个状态：新建、就绪、运行、阻塞、死亡。</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658929105650.png" alt="1658929105650"></p>
<p><strong>1.</strong> <strong>新建</strong></p>
<p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p>
<p><strong>2.</strong> <strong>就绪</strong></p>
<p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p>
<blockquote>
<p>注意：</p>
<p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p>
</blockquote>
<p><strong>3.</strong> <strong>运行</strong></p>
<p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU，在任何时刻只有一个线程处于运行状态，如果计算机有多个处理器，将会有多个线程并行(Parallel)执行。</p>
<p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p>
<p><strong>4.</strong> <strong>阻塞</strong></p>
<p>当在运行过程中的线程遇到如下情况时，线程会进入阻塞状态：</p>
<ul>
<li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li>
<li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li>
<li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li>
<li>线程执行过程中，同步监视器调用了wait(time)</li>
<li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li>
<li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li>
</ul>
<p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p>
<ul>
<li>线程的sleep()时间到；</li>
<li>线程成功获得了同步监视器；</li>
<li>线程等到了通知(notify)；</li>
<li>线程wait的时间到了</li>
<li>加塞的线程结束了；</li>
<li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li>
</ul>
<p><strong>5.</strong> <strong>死亡</strong></p>
<p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p>
<ul>
<li>run()方法执行完成，线程正常结束</li>
<li>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</li>
<li>直接调用该线程的stop()来结束该线程（已过时，因为容易发生死锁）</li>
</ul>
<p>不过在java.lang.Thread.State的枚举类中这样定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先它没有区分：就绪和运行状态，因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。只能我们人为的进行想象和理解。</li>
<li>其次根据Thread.State的定义，阻塞状态是分为三种的：BLOCKED、WAITING、TIMED_WAITING。</li>
</ul>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658929292576.png" alt="1658929292576"></p>
<h3 id="19-thread和runnable的区别"><a href="#19-thread和runnable的区别" class="headerlink" title="19.thread和runnable的区别"></a>19.thread和runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p>
<ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
<li>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用<br>java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进<br>程。</li>
</ol>
<h3 id="20-wait和sleep的区别"><a href="#20-wait和sleep的区别" class="headerlink" title="20.wait和sleep的区别"></a>20.wait和sleep的区别</h3><p>（1）sleep()不释放锁，wait()释放锁（目前的理解，wait可以指定时间，一旦超过这个时间，那么这个锁对象释放，即直接变为runnable状态，不需要等到对象.notify()方法的调用，但是wait也可以不指定时间，一旦不指定时间，那么就需要等对象调用notify才能释放这个锁对象，其它线程才可以使用）</p>
<p>（2）sleep()指定休眠的时间，wait()可以指定时间也可以无限等待直到notify或notifyAll</p>
<p>（3）sleep()在Thread类中声明的静态方法，wait方法在Object类中声明</p>
<p>因为我们调用wait（）方法是由锁对象调用，而锁对象的类型是任意类型的对象。那么希望任意类型的对象都要有的方法，只能声明在Object类中。</p>
<h3 id="21-泛型"><a href="#21-泛型" class="headerlink" title="21.泛型"></a>21.泛型</h3><h4 id="21-1类型变量的上限"><a href="#21-1类型变量的上限" class="headerlink" title="21.1类型变量的上限"></a>21.1类型变量的上限</h4><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型变量  extends 上限&gt;</span><br></pre></td></tr></table></figure>

<p>如果有多个上限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型变量  extends 上限1 &amp; 上限2&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果多个上限中有类有接口，那么只能有一个类，而且必须写在最左边。接口的话，可以多个。</p>
<p>如果在声明&lt;类型变量&gt;时没有指定上限，默认上限是java.lang.Object。</p>
</blockquote>
<p>例如：我们要声明一个两个数求和的工具类，要求两个加数必须是Number数字类型，并且实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumTools</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span> &amp; Comparable&lt;T&gt;&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> T a;</span><br><span class="line">	<span class="keyword">private</span> T b;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SumTools</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getSum</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(a <span class="keyword">instanceof</span> BigInteger)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T) ((BigInteger) a).add((BigInteger)b);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> BigDecimal)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T) ((BigDecimal) a).add((BigDecimal)b);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Short)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Integer.valueOf((Short)a+(Short)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Integer.valueOf((Integer)a+(Integer)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Long.valueOf((Long)a+(Long)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Float)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Float.valueOf((Float)a+(Float)b));</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Double)&#123;</span><br><span class="line">			<span class="keyword">return</span> (T)(Double.valueOf((Double)a+(Double)b));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持该操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SumTools&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">SumTools</span>&lt;Integer&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> s.getSum();</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		SumTools&lt;String&gt; s = new SumTools&lt;String&gt;(&quot;1&quot;,&quot;2&quot;);//错误，因为String类型不是extends Number</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="21-2泛型擦除"><a href="#21-2泛型擦除" class="headerlink" title="21.2泛型擦除"></a>21.2泛型擦除</h4><p>当使用参数化类型的类或接口时，如果没有指定泛型，那么会怎么样呢？</p>
<p>会发生泛型擦除，自动按照最左边的第一个上限处理。如果没有指定上限，上限即为Object。</p>
<h4 id="21-3泛型方法"><a href="#21-3泛型方法" class="headerlink" title="21.3泛型方法"></a>21.3泛型方法</h4><p>前面介绍了在定义类、接口时可以声明&lt;类型变量&gt;，在该类的方法和属性定义、接口的方法定义中，这些&lt;类型变量&gt;可被当成普通类型来用。但是，在另外一些情况下，</p>
<p>（1）如果我们定义类、接口时没有使用&lt;类型变量&gt;，但是某个方法定义时，想要自己定义&lt;类型变量&gt;；</p>
<p>（2）另外我们之前说类和接口上的类型形参是不能用于静态方法中，那么当某个静态方法想要定义&lt;类型变量&gt;。</p>
<p>那么，JDK1.5之后，还提供了泛型方法的支持。</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 &lt;类型变量列表&gt; 返回值类型 方法名(【形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;类型变量列表&gt;：可以是一个或多个类型变量，一般都是使用单个的大写字母表示。例如：<T>、&lt;K,V&gt;等。</li>
<li>&lt;类型变量&gt;同样也可以指定上限</li>
</ul>
<h4 id="21-4-类型通配符"><a href="#21-4-类型通配符" class="headerlink" title="21.4 类型通配符"></a>21.4 类型通配符</h4><p><strong>自己的话：就是当你声明了一个带有泛型的类，然后你定义另外一个方法的时候使用到了这个带有泛型的类作为形参，你并不知道这个方法中的形参类型是什么，因此需要使用到类型通配符  ？</strong></p>
<p>当我们声明一个方法时，某个形参的类型是一个参数化的泛型类或泛型接口类型，但是在声明方法时，又不确定该泛型实际类型，我们可以考虑使用类型通配符。</p>
<p>例如：</p>
<p>这个学生类是一个参数化的泛型类，代码如下（详细请看$12.2.1中的示例说明）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> T score;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, T score)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T score)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 成绩：&quot;</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21-4-1-lt-gt-任意类型"><a href="#21-4-1-lt-gt-任意类型" class="headerlink" title="21.4.1  &lt;?&gt;任意类型"></a>21.4.1  &lt;?&gt;任意类型</h5><p>例如：我们要声明一个学生管理类，这个管理类要包含一个方法，可以遍历学生数组。</p>
<p>学生管理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student&lt;?&gt;[] arr)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21-4-2-lt-extends上限-gt"><a href="#21-4-2-lt-extends上限-gt" class="headerlink" title="21.4.2&lt;?extends上限&gt;"></a>21.4.2&lt;?extends上限&gt;</h5><p>例如：我们要声明一个学生管理类，这个管理类要包含一个方法，找出学生数组中成绩最高的学生对象。</p>
<p>要求学生的成绩的类型必须可比较大小，实现Comparable接口。</p>
<p>学生管理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Student&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; max(Student&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;[] arr)&#123;</span><br><span class="line">		Student&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; max = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i].getScore().compareTo(max.getScore())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21-4-3-lt-super下限-gt"><a href="#21-4-3-lt-super下限-gt" class="headerlink" title="21.4.3&lt;?super下限&gt;"></a>21.4.3&lt;?super下限&gt;</h5><p>现在要声明一个数组工具类，包含</p>
<p>（1）方法1：可以给任意对象数组进行从小到大排序，只要你指定定制比较器对象，而且这个定制比较器对象可以是当前数组元素类型自己或其父类的定制比较器对象</p>
<p>（2）方法2：可以将任意对象数组的元素拼接为一个字符串返回</p>
<p>数组工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrays</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">toString</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">				str += <span class="string">&quot;[&quot;</span> + arr[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">				str += arr[i] + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				str += arr[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(c.compare(arr[j], arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：有如下JavaBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(name, age);</span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;,score=&quot;</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Student[] all = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">		all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="number">89</span>);</span><br><span class="line">		all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">22</span>, <span class="number">99</span>);</span><br><span class="line">		all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">25</span>, <span class="number">67</span>);</span><br><span class="line">		</span><br><span class="line">		MyArrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(MyArrays.toString(all));</span><br><span class="line">		</span><br><span class="line">		MyArrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> o1.getScore() - o2.getScore();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(MyArrays.toString(all));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21-4-4-总结"><a href="#21-4-4-总结" class="headerlink" title="21.4.4 总结"></a>21.4.4 总结</h5><p><strong>下限就是需要你添加 该类型或者该类型的父类</strong></p>
<p><strong>上限就是需要你添加 该类型或者该类型的子类</strong></p>
<h3 id="22-集合的分类"><a href="#22-集合的分类" class="headerlink" title="22.集合的分类"></a>22.集合的分类</h3><p>集合主要分为两大类型，Collection和Map，Collection表示一组对象，Map表示一组键值对</p>
<ul>
<li>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 <ul>
<li>List：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li>
<li>Queue：队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。</li>
<li>Set：一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。 </li>
<li>SortedSet进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</li>
</ul>
</li>
<li>Map：将键映射到值(key,value)的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</li>
</ul>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658937189929.png" alt="1658937189929"></p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658937211603.png" alt="1658937211603"></p>
<h3 id="23-Iterator和Iterable的区别"><a href="#23-Iterator和Iterable的区别" class="headerlink" title="23.Iterator和Iterable的区别"></a>23.Iterator和Iterable的区别</h3><p>Iterable主要是对于Iterator做了一层封装，里面包含了Iterable，定义了一个forEach函数，用于实现其子类集合的增强for循环</p>
<p>Iterator是迭代器接口，实现此接口的实例可以对元素集合进行迭代遍历，而Iterable是为了只要实现该接口就可以使用foreach进行迭代<br>Iterable中封装了Iterator接口，只要实现了Iterable接口的类，就可以使用Iterator迭代器了。<br>集合Collection、List、Set都是Iterable的实现类，所以他们及其他们的子类都可以使用foreach进行迭代。<br>Iterator中和核心的方法next(),hasnext(),remove(),都是依赖当前位置，如果这些集合直接实现Iterator，则必须包括当前迭代位置的指针。当集合在方法间进行传递的时候，由于当前位置不可知，所以next()之后的值，也不可知。而当实现Iterable则不然，每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响<br><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658937169590.png" alt="1658937169590"></p>
<h3 id="24-List集合"><a href="#24-List集合" class="headerlink" title="24.List集合"></a>24.List集合</h3><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><p>ArrayList与Vector的区别？</p>
<p>它们的底层物理结构都是数组，我们称为动态数组。</p>
<ul>
<li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li>
<li>动态数组的扩容机制不同，ArrayList扩容为原来的1.5倍，Vector扩容增加为原来的2倍。</li>
<li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10，而JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。</li>
<li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</li>
</ul>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<p><img src="D:/大数据开发笔记/1.JAVA/19_集合(Collection)/imgS/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p>
<p>JDK1.6之后LinkedList实现了Deque接口。双端队列也可用作 LIFO（后进先出）堆栈。如果要使用堆栈结构的集合，可以考虑使用LinkedList，而不是Stack。</p>
<h4 id="24-1-vector源码分析"><a href="#24-1-vector源码分析" class="headerlink" title="24.1 vector源码分析"></a>24.1 vector源码分析</h4><ul>
<li><p>Object数组初始值10，elementCount元素数量，增量默认0，modCount版本</p>
</li>
<li><p>向Vector集合添加数据超过初始值10，扩容，2倍大小扩容</p>
</li>
<li><p>Vector里面add解决线程安全问题synchronized</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement增量为<span class="number">0</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>();</span><br><span class="line">       <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">       <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">       <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">       <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    	<span class="comment">//看是否需要扩容</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-2-ArrayList源码分析"><a href="#24-2-ArrayList源码分析" class="headerlink" title="24.2 ArrayList源码分析"></a>24.2 ArrayList源码分析</h4><p>1.6版本的时候是直接初始化一个10长度的Object数组，1.7版本及之后都是先初始化一个长度为0的Object数组，然后加入第一个元素之后就会初始化一个长度为10的Object数组，然后每一次扩容1.5倍。</p>
<ul>
<li><p>数据存储的结构是数组结构。元素增删慢，查找快</p>
</li>
<li><p>创建List集合，有三部分：Object数组，size，modCount</p>
</li>
<li><p>创建List集合之后，Object数组默认初始大小是0</p>
</li>
<li><p>当向集合添加数据，Object数组大小变成10</p>
</li>
<li><p>向数组添加数据超过了10，进行扩容，1.5倍大小扩容</p>
</li>
</ul>
<p>JDK1.6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">      <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line"><span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>();</span><br><span class="line">       <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">           <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//看是否需要扩容处理</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>JDK1.8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//查看是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">    <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//需要移动的元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">      rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">      modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//需要移动的元素个数</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">      elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">     <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-3-LinkedList源码分析"><a href="#24-3-LinkedList源码分析" class="headerlink" title="24.3 LinkedList源码分析"></a>24.3 LinkedList源码分析</h4><ul>
<li>数据存储的结构链表（双向）</li>
<li>创建LinkedList对象，包含四部分：size元素数量，first，last，modCount</li>
<li>添加元素时候，第一次添加元素时候，作为首节点和尾节点</li>
<li>再次添加时候，在首节点下一个添加节点，可以指向上一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;<span class="comment">//元素数据</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">          first = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">          prev.next = next;</span><br><span class="line">          <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">          x.prev = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">          next.prev = prev;</span><br><span class="line">          <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">          x.next = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">      x.item = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">//元素个数减少</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="comment">//修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-Set集合"><a href="#25-Set集合" class="headerlink" title="25.Set集合"></a>25.Set集合</h3><h4 id="25-1-HashSet"><a href="#25-1-HashSet" class="headerlink" title="25.1 HashSet"></a>25.1 HashSet</h4><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p>
<p><code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，然后HashMap的底层物理实现是一个Hash表。（什么是哈希表，下一节在HashMap小节在细讲，这里先不展开）</p>
<p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。<strong>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet的元素要重写hashCode和equals方法。</strong></p>
<p>示例代码：定义一个Employee类，该类包含属性：name, birthday，其中 birthday 为 MyDate类的对象；MyDate为自定义类型，包含年、月、日属性。要求 name和birthday一样的视为同一个员工。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> MyDate birthday;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, MyDate birthday)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> MyDate <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> birthday;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(MyDate birthday)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		result = prime * result + ((birthday == <span class="literal">null</span>) ? <span class="number">0</span> : birthday.hashCode());</span><br><span class="line">		result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) obj;</span><br><span class="line">		<span class="keyword">if</span> (birthday == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.birthday != <span class="literal">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!birthday.equals(other.birthday))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 生日：&quot;</span> + birthday;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.year = year;</span><br><span class="line">		<span class="built_in">this</span>.month = month;</span><br><span class="line">		<span class="built_in">this</span>.day = day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getYear</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> year;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.year = year;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMonth</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> month;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonth</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.month = month;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDay</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.day = day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		result = prime * result + day;</span><br><span class="line">		result = prime * result + month;</span><br><span class="line">		result = prime * result + year;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">MyDate</span> <span class="variable">other</span> <span class="operator">=</span> (MyDate) obj;</span><br><span class="line">		<span class="keyword">if</span> (day != other.day)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (month != other.month)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (year != other.year)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashSet</span> &#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		HashSet&lt;Employee&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1990</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">		<span class="comment">//重复元素无法添加，因为MyDate和Employee重写了hashCode和equals方法</span></span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1990</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1992</span>,<span class="number">2</span>,<span class="number">2</span>)));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Employee object : set) &#123;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-2-LinkedHashSet"><a href="#25-2-LinkedHashSet" class="headerlink" title="25.2 LinkedHashSet"></a>25.2 LinkedHashSet</h4><p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p>
<h4 id="25-3-TreeSet"><a href="#25-3-TreeSet" class="headerlink" title="25.3 TreeSet"></a>25.3 TreeSet</h4><p>底层结构：里面维护了一个TreeMap，都是基于红黑树实现的！</p>
<p>特点：<br>    1、不允许重复<br>    2、实现排序<br>        自然排序或定制排序</p>
<p>如何实现去重的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果使用的是自然排序，则通过调用实现的compareTo方法</span><br><span class="line">如果使用的是定制排序，则通过调用比较器的compare方法</span><br></pre></td></tr></table></figure>

<p>如何排序？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：自然排序</span><br><span class="line">让待添加的元素类型实现Comparable接口，并重写compareTo方法</span><br><span class="line"></span><br><span class="line">方式二：定制排序</span><br><span class="line">创建Set对象时，指定Comparator比较器接口，并实现compare方法</span><br></pre></td></tr></table></figure>

<h5 id="自然顺序"><a href="#自然顺序" class="headerlink" title="自然顺序"></a>自然顺序</h5><p>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值为0。</p>
<p>代码示例一：按照字符串Unicode编码值排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">		TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;zhangsan&quot;</span>);  <span class="comment">//String它实现了java.lang.Comparable接口</span></span><br><span class="line">		set.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">				</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line">		<span class="keyword">for</span> (String str : set) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h5><p>如果放到TreeSet中的元素的自然排序（Comparable）规则不符合当前排序需求时，或者元素的类型没有实现Comparable接口。那么在创建TreeSet时，可以单独指定一个Comparator的对象。使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</p>
<p>代码示例：学生类型未实现Comparable接口，单独指定Comparator比较器，按照学生的学号排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//......这里省略了name属性的get/set</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">		TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;张三风&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;元素个数：&quot;</span> + set.size());</span><br><span class="line">		<span class="keyword">for</span> (Student stu : set) &#123;</span><br><span class="line">			System.out.println(stu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-HashMap底层原理"><a href="#26-HashMap底层原理" class="headerlink" title="26.HashMap底层原理"></a>26.HashMap底层原理</h3><p>（1）创建HashMap对象时候，初始化几个值，</p>
<ul>
<li>主要：table代表数组默认null，负载因子默认0.75，边界值0<br>  （2）第一次向HashMap添加元素</li>
<li>根据添加数据key计算hash值</li>
<li>判断当前table数组是否为空，第一次肯定是空，数组进行初始化<br>   – 数组容量 16 ，临界值 12</li>
<li>根据数组初始长度和hash值得到数组某个位置，在位置添加元素（第一次加不存在重复问题）</li>
</ul>
<p>（3）容量不超过临界值12时候，再次添加数据</p>
<ul>
<li>根据添加数据key计算hash值</li>
<li>根据数组长度和hash值得到数组某个位置，在位置添加元素<br>– 判断数组这个位置上面是否存在元素，如果不存在，添加<br>   – 如果位置存在元素，<br>— 判断位置元素key是否一样，如果key相同，替换，如果key不一样，链表存储</li>
</ul>
<p>（4）容量超过临界值12，添加数据</p>
<ul>
<li>根据添加数据key计算hash值</li>
<li>根据数组长度和hash值得到数组某个位置，在位置添加元素<br>– 判断数组这个位置上面是否存在元素，如果不存在，添加<br>– 如果位置存在元素，<br> — 判断位置元素key是否一样，如果key相同，替换，如果key不一样，链表存储<br>   – 判断数组容量是否超过临界值，如果超过进行扩容<br>— 把数组大小2倍，临界值2倍<br>— 把数组元素重新编排</li>
</ul>
<p>（5）在jdk1.8优化</p>
<ul>
<li>如果数组容量64，链表节点8，把链表转换树形结构</li>
</ul>
<h4 id="26-1-Hash的物理结构"><a href="#26-1-Hash的物理结构" class="headerlink" title="26.1 Hash的物理结构"></a>26.1 Hash的物理结构</h4><p>HashMap和Hashtable是散列表，其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个元素被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到了某个table[index]桶中。使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p>
<h5 id="（1）-数组元素类型"><a href="#（1）-数组元素类型" class="headerlink" title="（1） 数组元素类型"></a>（1） 数组元素类型</h5><p>JDK1.7：</p>
<p>映射关系被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p>
<p>观察HashMap.Entry类型是个结点类型，即table[index]下的映射关系可能串起来一个链表。因此我们把table[index]称为“桶bucket”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Entry&lt;K,V&gt; next;</span><br><span class="line">            <span class="type">int</span> hash;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658979185354.png" alt="1658979185354"></p>
<p>DK1.8：</p>
<p>映射关系被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p>
<p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树（自平衡的二叉树）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            V value;</span><br><span class="line">            Node&lt;K,V&gt; next;</span><br><span class="line">            <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red;<span class="comment">//是红结点还是黑结点</span></span><br><span class="line">        <span class="comment">//...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980871876.png" alt="1658980871876"></p>
<h5 id="（2）数组的长度始终是2的n次幂"><a href="#（2）数组的长度始终是2的n次幂" class="headerlink" title="（2）数组的长度始终是2的n次幂"></a>（2）数组的长度始终是2的n次幂</h5><p>table数组的默认初始化长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>如果你手动指定的table长度不是2的n次幂，会通过如下方法给你纠正为2的n次幂</p>
<p>JDK1.7：</p>
<p>HashMap处理容量方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Integer包装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">highestOneBit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组不够了，扩容了怎么办？扩容了还是2的n次幂，因为每次数组扩容为原来的2倍</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//扩容为原来的2倍</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//oldCap原来的容量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">      <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line">          &#125;<span class="comment">//newCap = oldCap &lt;&lt; 1  新容量=旧容量扩容为原来的2倍</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">      &#125;</span><br><span class="line"> 		<span class="comment">//......此处省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么为什么要保持table数组一直是2的n次幂呢？</p>
<p>如果不是2的次幂，会浪费散列表的一些空间位置，因为计算某个元素存放位置的时候，使用的位运算操作，只能得到2的次幂内的索引。在下面会详细讲述</p>
<h5 id="（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？"><a href="#（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？" class="headerlink" title="（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？"></a>（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？</h5><p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p>
<p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算，不能保证均匀存放，可能会导致某些table[index]桶中的元素太多，而另一些太少，因此不合适。</p>
<p>②hash 值 &amp; (table.length-1)，因为table.length是2的幂次方，因此table.length-1是一个二进制低位全是1的数，所以&amp;操作完，也会得到一个[0,table.length-1]范围的值。</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980858318.png" alt="1658980858318"></p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">//此处h就是hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  <span class="comment">// i = (n - 1) &amp; hash</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//....省略大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（4）hash是hashCode的再运算"><a href="#（4）hash是hashCode的再运算" class="headerlink" title="（4）hash是hashCode的再运算"></a>（4）hash是hashCode的再运算</h5><p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p>
<p>JDK1.7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p>
<p>为什么要hashCode值的二进制的高位参与到index计算呢？</p>
<p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p>
<h5 id="（5）解决-index-冲突问题"><a href="#（5）解决-index-冲突问题" class="headerlink" title="（5）解决[index]冲突问题"></a>（5）解决[index]冲突问题</h5><p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p>
<p>JDK1.8之间使用：数组+链表的结构。</p>
<p>JDK1.8之后使用：数组+链表&#x2F;红黑树的结构。</p>
<p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980822947.png" alt="1658980822947"></p>
<h5 id="（6）为什么JDK1-8会出现红黑树和链表共存呢？"><a href="#（6）为什么JDK1-8会出现红黑树和链表共存呢？" class="headerlink" title="（6）为什么JDK1.8会出现红黑树和链表共存呢？"></a>（6）为什么JDK1.8会出现红黑树和链表共存呢？</h5><p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p>
<p>但是二叉树的结构又过于复杂，如果结点个数比较少的时候，那么选择链表反而更简单。</p>
<p>所以会出现红黑树和链表共存。</p>
<h5 id="（7）什么时候树化？什么时候反树化？"><a href="#（7）什么时候树化？什么时候反树化？" class="headerlink" title="（7）什么时候树化？什么时候反树化？"></a>（7）什么时候树化？什么时候反树化？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//反树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;<span class="comment">//最小树化容量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当某table[index]下的链表的结点个数达到8，并且table.length&gt;&#x3D;64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</li>
<li>当某table[index]下的红黑树结点个数少于6个，此时，<ul>
<li>如果继续删除table[index]下树结点，一直删除到2个以下时就会变回链表。</li>
<li>如果继续添加映射关系到当前map中，如果添加导致了map的table重新resize，那么只要table[index]下的树结点仍然&lt;&#x3D;6个，那么会变回链表</li>
</ul>
</li>
</ul>
<h4 id="26-2-JDK1-7的put方法源码解析"><a href="#26-2-JDK1-7的put方法源码解析" class="headerlink" title="26.2 JDK1.7的put方法源码解析"></a>26.2 JDK1.7的put方法源码解析</h4><p>（1）几个关键的常量和变量值的作用：</p>
<p>初始化容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<p>①默认负载因子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>②阈值：扩容的临界值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = table.length * loadFactor;</span><br></pre></td></tr></table></figure>

<p>③负载因子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>负载因子的值大小有什么关系？</p>
<p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p>
<p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  	<span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">      <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性                                       initialCapacity);</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">      <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">      threshold = initialCapacity;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">        <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//添加新的映射关系</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line">		<span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">        threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否需要库容</span></span><br><span class="line">        <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">            hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//存入table中</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;<span class="comment">//个数增加</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>1、put(key,value)</p>
<p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
<p>（2）特殊考虑：如果key为null，index直接是[0],hash也是0</p>
<p>（3）如果key不为null，在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<p>（4）计算index &#x3D; table.length-1 &amp; hash;</p>
<p>（5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
<p>（6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p>
<p>（7）添加之前先判断if(size &gt;&#x3D; threshold  &amp;&amp;  table[index]!&#x3D;null)如果该条件为true，会扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(size &gt;= threshold  &amp;&amp;  table[index]!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">	①会扩容</span><br><span class="line"></span><br><span class="line">	②会重新计算key的hash</span><br><span class="line"></span><br><span class="line">	③会重新计算index</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980807705.png" alt="1658980807705"><br>2、get(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index &#x3D; table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p>
<p>3、remove(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index &#x3D; table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
<h4 id="26-3-JDK1-8的put方法源码分析"><a href="#26-3-JDK1-8的put方法源码分析" class="headerlink" title="26.3 JDK1.8的put方法源码分析"></a>26.3 JDK1.8的put方法源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="type">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="type">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">	<span class="comment">//如果key是null，hash是0</span></span><br><span class="line">	<span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">	<span class="comment">//		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">	如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">	这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">	Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line">	<span class="type">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//tab和table等价</span></span><br><span class="line">	<span class="comment">//如果table是空的</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">		tab = resize();</span></span><br><span class="line"><span class="comment">		n = tab.length;*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">		n = 16</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">	<span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">	<span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; </span><br><span class="line">		K k;</span><br><span class="line">		<span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">		<span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">               e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">               <span class="comment">//单独处理树结点</span></span><br><span class="line">               <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">               <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">			<span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">				<span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					&#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">				<span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                   p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)&#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">			&#125;</span><br><span class="line">               afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//元素个数增加</span></span><br><span class="line">	<span class="comment">//size达到阈值</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">           resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">       afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line">	<span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//newCap，新容量</span></span><br><span class="line">	<span class="comment">//newThr：新阈值</span></span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">			<span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">			<span class="comment">//新容量：32,64，...</span></span><br><span class="line">			<span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">			<span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">		&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">		<span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line">		<span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line">					<span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">					*/</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line">   Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">	<span class="comment">//创建一个新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">       <span class="type">int</span> n, index; </span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">	<span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();<span class="comment">//先扩容</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                   hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">		</span><br><span class="line">           <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">               hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;	</span><br></pre></td></tr></table></figure>

<p>1、添加过程</p>
<p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
<p>（2）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<blockquote>
<p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p>
</blockquote>
<p>（3）计算index &#x3D; table.length-1 &amp; hash;</p>
<p>（4）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
<p>（5）如果没有相同的，</p>
<p>①table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p>
<p>②table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p>
<p>③table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转为一棵红黑树</p>
<p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p>
<p>（6）添加完成后判断if(size &gt; threshold ){</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	①会扩容</span><br><span class="line"></span><br><span class="line">	②会重新计算key的hash</span><br><span class="line"></span><br><span class="line">	③会重新计算index</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658980775776.png" alt="1658980775776"></p>
<p>2、remove(key)</p>
<p>（1）计算key的hash值，用这个方法hash(key)</p>
<p>（2）找index &#x3D; table.length-1 &amp; hash;</p>
<p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
<p>（4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</p>
<h3 id="27-IO流"><a href="#27-IO流" class="headerlink" title="27 IO流"></a>27 IO流</h3><h4 id="27-1-分类"><a href="#27-1-分类" class="headerlink" title="27.1 分类"></a>27.1 分类</h4><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul>
<li>以InputStream,Reader结尾</li>
</ul>
</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul>
<li>以OutputStream、Writer结尾</li>
</ul>
</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul>
<li>以InputStream和OutputStream结尾</li>
</ul>
</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul>
<li>以Reader和Writer结尾</li>
</ul>
</li>
</ul>
<p>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。</p>
<ul>
<li><strong>节点流</strong>：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li>
<li><strong>处理流</strong>：是对一个已存在的流进行连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li>
</ul>
<blockquote>
<p>这种设计是<strong>装饰模式</strong>（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一。在现实生活中你也有很多装饰者的例子，例如：人需要各种各样的衣着，不管你穿着怎样，但是，对于你个人本质来说是不变的，充其量只是在外面加上了一些装饰，有，“遮羞的”、“保暖的”、“好看的”、“防雨的”….</p>
</blockquote>
<p><strong>四大顶级抽象父类</strong></p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658990418003.png" alt="1658990418003"></p>
<h3 id="28-类加载"><a href="#28-类加载" class="headerlink" title="28.类加载"></a>28.类加载</h3><h4 id="28-1-类的加载过程"><a href="#28-1-类的加载过程" class="headerlink" title="28.1 类的加载过程"></a>28.1 类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p>
<p>类的加载又分为三个阶段：</p>
<p>（1）加载：load</p>
<p>就是指将类型的class字节码数据读入内存</p>
<p>（2）连接：link</p>
<p>①验证：校验合法性等</p>
<p>②准备：准备对应的内存（方法区），创建Class对象，为类变量赋默认值，为静态常量赋初始值。</p>
<p>③解析：把字节码中的符号引用替换为对应的直接地址引用</p>
<p>（3）初始化：initialize（类初始化）即执行<clinit>类初始化方法，大多数情况下，类的加载就完成了类的初始化，有些情况下，会延迟类的初始化。</p>
<p><img src="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1658994987896.png" alt="1658994987896"></p>
<h4 id="28-2类的初始化"><a href="#28-2类的初始化" class="headerlink" title="28.2类的初始化"></a>28.2类的初始化</h4><p><strong>1、哪些操作会导致类的初始化？</strong></p>
<p>（1）运行主方法所在的类，要先完成类初始化，再执行main方法</p>
<p>（2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化</p>
<p>（3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化</p>
<p>（4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类</p>
<p>（5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化</p>
<blockquote>
<p>类初始化执行的是<clinit>()，该方法由（1）类变量的显式赋值代码（2）静态代码块中的代码构成</p>
</blockquote>
<p><strong>2、哪些使用类的操作，但是不会导致类的初始化？</strong></p>
<p>（1）使用某个类的静态的常量（static  final）（常量应该是放到常量池之中）</p>
<p>（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</p>
<p>（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化</p>
<h4 id="28-3-类加载器"><a href="#28-3-类加载器" class="headerlink" title="28.3 类加载器"></a>28.3 类加载器</h4><p><strong>1、类加载器分为：</strong></p>
<p>（1）引导类加载器（Bootstrap Classloader）又称为根类加载器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它负责加载jre/rt.jar核心库</span><br><span class="line">它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null</span><br></pre></td></tr></table></figure>

<p>（2）扩展类加载器（Extension ClassLoader）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它负责加载jre/lib/ext扩展库</span><br><span class="line">它是ClassLoader的子类</span><br></pre></td></tr></table></figure>

<p>（3）应用程序类加载器（Application Classloader）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它负责加载项目的classpath路径下的类</span><br><span class="line"></span><br><span class="line">它是ClassLoader的子类</span><br></pre></td></tr></table></figure>

<p>（4）自定义类加载器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你的程序需要加载“特定”目录下的类，可以自定义类加载器；</span><br><span class="line">当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码</span><br><span class="line">后面会见到的自定义类加载器：tomcat中</span><br></pre></td></tr></table></figure>

<p><strong>2、Java系统类加载器的双亲委托模式</strong></p>
<p>简单描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下一级的类加载器，如果接到任务时，会先搜索是否加载过，如果没有，会先把任务往上传，如果都没有加载过，一直到根加载器，如果根加载器在它负责的路径下没有找到，会往回传，如果一路回传到最后一级都没有找到，那么会报ClassNotFoundException或NoClassDefError，如果在某一级找到了，就直接返回Class对象。</span><br></pre></td></tr></table></figure>

<p>应用程序类加载器  把  扩展类加载器视为父加载器，</p>
<p>扩展类加载器 把 引导类加载器视为父加载器。</p>
<p>不是继承关系，是组合的方式实现的。</p>
<h4 id="双亲委派模型工作工程："><a href="#双亲委派模型工作工程：" class="headerlink" title="双亲委派模型工作工程："></a>双亲委派模型工作工程：</h4><p>　　1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。  </p>
<p>　　2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。  </p>
<p>　　3.如果Bootstrap ClassLoader加载失败(在<JAVA_HOME>\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。  </p>
<p>　　4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。  </p>
<p>　　5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。  </p>
<p>　　6.如果均加载失败，就会抛出ClassNotFoundException异常。</p>
<p>例子：</p>
<p>　　当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理会先检查自己是否已经加载过，如果没有再往上。注意这个过程，直到到达Bootstrap classLoader之前，都是没有哪个加载器自己选择加载的。如果父加载器无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p>
<h3 id="29-获取Class对象的四种方式"><a href="#29-获取Class对象的四种方式" class="headerlink" title="29.获取Class对象的四种方式"></a>29.获取Class对象的四种方式</h3><p>（1）类型名.class</p>
<p>要求编译期间已知类型</p>
<p>（2）对象.getClass()</p>
<p>获取对象的运行时类型</p>
<p>（3）Class.forName(类型全名称)</p>
<p> 可以获取编译期间未知的类型</p>
<p>（4）ClassLoader的类加载器对象.loadClass(类型全名称)</p>
<p>可以用系统类加载对象或自定义加载器对象加载指定路径下的类型</p>
<h3 id="30-java1-8新特性"><a href="#30-java1-8新特性" class="headerlink" title="30.java1.8新特性"></a>30.java1.8新特性</h3><p>主要是增加了函数式编程的一些接口，比如lambda表达式以及StreamAPI，感觉就是模仿的scala，lambda模仿的就是函数最简化，streamAPI 就是模仿的一套算子连续不断的处理数据，从而节省了中途起名字的一些不必要的操作。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Xiang Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">http://example.com/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">The Xiang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">类型转换</a><a class="post-meta__tags" href="/tags/%E5%B0%81%E8%A3%85/">封装</a><a class="post-meta__tags" href="/tags/%E7%BB%A7%E6%89%BF/">继承</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E6%80%81/">多态</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a><a class="post-meta__tags" href="/tags/this/">this</a><a class="post-meta__tags" href="/tags/final/">final</a><a class="post-meta__tags" href="/tags/super/">super</a><a class="post-meta__tags" href="/tags/instanceof/">instanceof</a><a class="post-meta__tags" href="/tags/native/">native</a><a class="post-meta__tags" href="/tags/Object/">Object</a><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/Thread/">Thread</a><a class="post-meta__tags" href="/tags/Runable/">Runable</a><a class="post-meta__tags" href="/tags/wait/">wait</a><a class="post-meta__tags" href="/tags/sleep/">sleep</a><a class="post-meta__tags" href="/tags/Vector/">Vector</a><a class="post-meta__tags" href="/tags/ArrayList/">ArrayList</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/">类型通配符</a><a class="post-meta__tags" href="/tags/HashSet/">HashSet</a><a class="post-meta__tags" href="/tags/HashMap/">HashMap</a><a class="post-meta__tags" href="/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">类的加载</a><a class="post-meta__tags" href="/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/">双亲委派机制</a><a class="post-meta__tags" href="/tags/JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7/">JDK1.8新特性</a><a class="post-meta__tags" href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">lambda表达式</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a><a class="post-meta__tags" href="/tags/IO%E6%B5%81/">IO流</a></div><div class="post_share"><div class="social-share" data-image="/../image/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><img class="next-cover" src="/../image/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络知识点介绍</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./image/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xiang Liu</div><div class="author-info__description">欢迎访问我的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/theXiangCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://mail.qq.com/" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这几天心理颇不宁静</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E5%85%AB%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.Java八大基础数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88float-4%E4%B8%AA%E5%AD%97%E8%8A%82%E5%8F%AF%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%97%E7%A1%AE%E5%A4%A7%E4%BA%8Elong8%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">2.为什么float 4个字节可表示数字确大于long8个字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.基本数据类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">1、自动类型转换（隐式类型转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">2、强制类型转换（显示类型转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">3、特殊的数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%92%8C%E2%80%93%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.++和–运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Java%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B9%8B%E5%89%8D%E6%B2%A1%E6%8E%8C%E6%8F%A1-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-text">5.Java的逻辑运算符（主要是之前没掌握|| 和| 的区别）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-amp-%E5%92%8C-amp-%E5%8C%BA%E5%88%AB%EF%BC%8C-%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="toc-text">&amp;&amp;和&amp;区别，||和|区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">6.Java语言的跨平台性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%93%E5%8D%B0arr%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA%E7%9A%84%E5%80%BC%E6%98%AF%E5%9C%B0%E5%9D%80%E5%90%97%EF%BC%9F"><span class="toc-text">7.打印arr数组输出的值是地址吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0"><span class="toc-text">8.面向对象思想概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2、面向对象与面向过程的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">9.权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-this%E3%80%81final%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">10.this、final、super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">this的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">this使用格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%92%8Cthis%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">super和this的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">super的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81super-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">1、super.成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81super-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">2、super.成员方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81super-%E6%88%96super-%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-text">3、super()或super(实参列表)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">final的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">1、修饰类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2、修饰方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F"><span class="toc-text">3、声明常量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">11.类的初始化和实例初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">类的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">实例初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">构造器和非静态代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-text">12、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5"><span class="toc-text">1.引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89"><span class="toc-text">2. 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%89%8D%E6%8F%90%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-text">3. 前提【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">4. 多态的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">5.多态的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">1、多态参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">2、多态数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%88%B6%E5%AD%90%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.父子类之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BD%AC%E5%9E%8B"><span class="toc-text">为什么要转型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-instanceof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">7.instanceof运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-native%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">13.native关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Object%E6%A0%B9%E7%88%B6%E7%B1%BB"><span class="toc-text">14.Object根父类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-public-String-toString-%EF%BC%9A"><span class="toc-text">1.public String toString()：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-public-final-Class-lt-gt-getClass-%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.public final Class&lt;?&gt; getClass()：获取对象的运行时类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-protected-void-finalize-%EF%BC%9A"><span class="toc-text">3.protected void finalize()：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-public-int-hashCode-%EF%BC%9A"><span class="toc-text">4.public int hashCode()：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-public-boolean-equals-Object-obj-%EF%BC%9A"><span class="toc-text">5.public boolean equals(Object obj)：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99hashcode"><span class="toc-text">15.为什么重写equals方法也要重写hashcode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%8E%A5%E5%8F%A3"><span class="toc-text">16.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%EF%BC%9F"><span class="toc-text">思考？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">17异常体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">18.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-java%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">18.1 java中多线程的创建和启动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">18.1.1 继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">18.1.2 实现Runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-1-3-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%EF%BC%88%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">18.1.3 使用匿名内部类对象来实现线程的创建和启动（常用方式）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-2-Thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">18.2 Thread常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">18.3 线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-1-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">18.3.1 同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-2-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">18.3.2 同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-3-3-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-text">18.3.3 锁机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-text">18.4等待唤醒机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">18.5 线程的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-thread%E5%92%8Crunnable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">19.thread和runnable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">20.wait和sleep的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%B3%9B%E5%9E%8B"><span class="toc-text">21.泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-1%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8A%E9%99%90"><span class="toc-text">21.1类型变量的上限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-2%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-text">21.2泛型擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-3%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">21.3泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-4-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">21.4 类型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#21-4-1-lt-gt-%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">21.4.1  &lt;?&gt;任意类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-4-2-lt-extends%E4%B8%8A%E9%99%90-gt"><span class="toc-text">21.4.2&lt;?extends上限&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-4-3-lt-super%E4%B8%8B%E9%99%90-gt"><span class="toc-text">21.4.3&lt;?super下限&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-4-4-%E6%80%BB%E7%BB%93"><span class="toc-text">21.4.4 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">22.集合的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Iterator%E5%92%8CIterable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">23.Iterator和Iterable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-List%E9%9B%86%E5%90%88"><span class="toc-text">24.List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88"><span class="toc-text">ArrayList集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E9%9B%86%E5%90%88"><span class="toc-text">Vector集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList%E9%9B%86%E5%90%88"><span class="toc-text">LinkedList集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-1-vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">24.1 vector源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-2-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">24.2 ArrayList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-3-LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">24.3 LinkedList源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Set%E9%9B%86%E5%90%88"><span class="toc-text">25.Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#25-1-HashSet"><span class="toc-text">25.1 HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-2-LinkedHashSet"><span class="toc-text">25.2 LinkedHashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-3-TreeSet"><span class="toc-text">25.3 TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E9%A1%BA%E5%BA%8F"><span class="toc-text">自然顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">定制排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">26.HashMap底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#26-1-Hash%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">26.1 Hash的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-text">（1） 数组元素类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6%E5%A7%8B%E7%BB%88%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82"><span class="toc-text">（2）数组的长度始终是2的n次幂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%82%A3%E4%B9%88HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E6%9F%90%E4%B8%AA%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E5%AD%98%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%A1%B6%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">（3）那么HashMap是如何决定某个映射关系存在哪个桶的呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89hash%E6%98%AFhashCode%E7%9A%84%E5%86%8D%E8%BF%90%E7%AE%97"><span class="toc-text">（4）hash是hashCode的再运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%A7%A3%E5%86%B3-index-%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-text">（5）解决[index]冲突问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88JDK1-8%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E9%93%BE%E8%A1%A8%E5%85%B1%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="toc-text">（6）为什么JDK1.8会出现红黑树和链表共存呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%A0%91%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%8D%E6%A0%91%E5%8C%96%EF%BC%9F"><span class="toc-text">（7）什么时候树化？什么时候反树化？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-2-JDK1-7%E7%9A%84put%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">26.2 JDK1.7的put方法源码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-3-JDK1-8%E7%9A%84put%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">26.3 JDK1.8的put方法源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-IO%E6%B5%81"><span class="toc-text">27 IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#27-1-%E5%88%86%E7%B1%BB"><span class="toc-text">27.1 分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-text">28.类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#28-1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">28.1 类的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-2%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">28.2类的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">28.3 类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B%EF%BC%9A"><span class="toc-text">双亲委派模型工作工程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">29.获取Class对象的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-java1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">30.java1.8新特性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="Java基本知识点介绍"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基本知识点介绍"/></a><div class="content"><a class="title" href="/2022/09/10/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="Java基本知识点介绍">Java基本知识点介绍</a><time datetime="2022-09-10T12:44:35.832Z" title="发表于 2022-09-10 20:44:35">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="计算机网络知识点介绍"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络知识点介绍"/></a><div class="content"><a class="title" href="/2022/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="计算机网络知识点介绍">计算机网络知识点介绍</a><time datetime="2022-09-10T12:26:42.061Z" title="发表于 2022-09-10 20:26:42">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/" title="Spark内核"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark内核"/></a><div class="content"><a class="title" href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/" title="Spark内核">Spark内核</a><time datetime="2022-09-10T02:54:42.307Z" title="发表于 2022-09-10 10:54:42">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark一个小案例"/></a><div class="content"><a class="title" href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例">Spark一个小案例</a><time datetime="2022-09-08T15:24:18.328Z" title="发表于 2022-09-08 23:24:18">2022-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="Spark核心编程"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark核心编程"/></a><div class="content"><a class="title" href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="Spark核心编程">Spark核心编程</a><time datetime="2022-09-06T11:27:39.924Z" title="发表于 2022-09-06 19:27:39">2022-09-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../image/bg.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#FF6A6A;animation: announ_animation 0.8s linear infinite;" class="fa fa-heartbeat"></i> Xiang Liu</div><div class="footer_custom_text">兽人永不为奴!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>