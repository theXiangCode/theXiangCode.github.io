<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spark内核 | The Xiang Blog</title><meta name="keywords" content="Spark,NIO,Netty,RpcEndpoint,任务划分,任务的调度,ShuffleMapStage,ResultStage,SortShuffle,bypass SortShuffle,HashShuffle,Spark内存管理,堆外内存,Storage,Execution,静态内存管理,动态内存管理"><meta name="author" content="Xiang Liu"><meta name="copyright" content="Xiang Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍了Spark的内核">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark内核">
<meta property="og:url" content="http://example.com/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/index.html">
<meta property="og:site_name" content="The Xiang Blog">
<meta property="og:description" content="介绍了Spark的内核">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/bg.jpg">
<meta property="article:published_time" content="2022-09-10T02:54:42.307Z">
<meta property="article:modified_time" content="2022-09-10T12:20:11.985Z">
<meta property="article:author" content="Xiang Liu">
<meta property="article:tag" content="Spark">
<meta property="article:tag" content="NIO">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="RpcEndpoint">
<meta property="article:tag" content="任务划分">
<meta property="article:tag" content="任务的调度">
<meta property="article:tag" content="ShuffleMapStage">
<meta property="article:tag" content="ResultStage">
<meta property="article:tag" content="SortShuffle">
<meta property="article:tag" content="bypass SortShuffle">
<meta property="article:tag" content="HashShuffle">
<meta property="article:tag" content="Spark内存管理">
<meta property="article:tag" content="堆外内存">
<meta property="article:tag" content="Storage">
<meta property="article:tag" content="Execution">
<meta property="article:tag" content="静态内存管理">
<meta property="article:tag" content="动态内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/bg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spark内核',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-10 20:20:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/title.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">129</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../image/bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">The Xiang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spark内核</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-10T02:54:42.307Z" title="发表于 2022-09-10 10:54:42">2022-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-10T12:20:11.985Z" title="更新于 2022-09-10 20:20:11">2022-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spark/">Spark</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spark内核"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-Spark内核概述"><a href="#1-Spark内核概述" class="headerlink" title="1. Spark内核概述"></a>1. Spark内核概述</h2><h3 id="1-1-Spark核心组件"><a href="#1-1-Spark核心组件" class="headerlink" title="1.1 Spark核心组件"></a>1.1 Spark核心组件</h3><p><strong>Driver</strong></p>
<p>​	Spark驱动器节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：</p>
<ol>
<li><p>将用户程序转化为作业（Job）；</p>
</li>
<li><p>在Executor之间调度任务（Task）；</p>
</li>
<li><p>跟踪Executor的执行情况；</p>
</li>
<li><p>通过UI展示查询运行情况；</p>
</li>
</ol>
<p><strong>Executor</strong></p>
<p>​	Spark Executor对象是负责在Spark作业中运行具体任务，任务彼此之间相互独立。Spark 应用启动时，ExecutorBackend节点被同时启动，并且始终伴随着整个Spark应用的生命周期而存在。如果有ExecutorBackend节点发生了故障或崩溃，Spark应用也可以继续执行，会将出错节点上的任务调度到其他Executor节点上继续运行。</p>
<p>Executor有两个核心功能：</p>
<ol>
<li><p>负责运行组成Spark应用的任务，并将结果返回给驱动器（Driver）；</p>
</li>
<li><p>它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p>
</li>
</ol>
<h3 id="1-2-Spark通用运行流程概述"><a href="#1-2-Spark通用运行流程概述" class="headerlink" title="1.2 Spark通用运行流程概述"></a>1.2 Spark通用运行流程概述</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662781886696.png" alt="1662781886696"></p>
<p>​	上图为Spark通用运行流程图，体现了基本的Spark应用程序在部署中的基本提交流程。</p>
<p>这个流程是按照如下的核心步骤进行工作的：</p>
<ol>
<li><p>任务提交后，都会先启动Driver程序；</p>
</li>
<li><p>随后Driver向集群管理器注册应用程序；</p>
</li>
<li><p>之后集群管理器根据此任务的配置文件分配Executor并启动；</p>
</li>
<li><p>Driver开始执行main函数，Spark查询为懒执行，当执行到Action算子时开始反向推算，根据宽依赖进行Stage的划分，随后每一个Stage对应一个Taskset，Taskset中有多个Task，查找可用资源Executor进行调度；</p>
</li>
<li><p>根据本地化原则，Task会被分发到指定的Executor去执行，在任务执行的过程中，Executor也会不断与Driver进行通信，报告任务运行情况。</p>
</li>
</ol>
<p>​	上述图中还存在一个问题，上述执行逻辑中，是资源满足之后才会执行main函数，其实main中需要准备一些配置等信息，才会去申请资源等信息，所以存在一些问题</p>
<h2 id="2-Spark部署模式"><a href="#2-Spark部署模式" class="headerlink" title="2. Spark部署模式"></a>2. Spark部署模式</h2><h3 id="2-1-YARN-Cluster模式"><a href="#2-1-YARN-Cluster模式" class="headerlink" title="2.1 YARN Cluster模式"></a>2.1 YARN Cluster模式</h3><h4 id="2-1-Cluster模式"><a href="#2-1-Cluster模式" class="headerlink" title="2.1 Cluster模式"></a>2.1 Cluster模式</h4><ol>
<li><p>执行脚本提交任务，实际是启动一个SparkSubmit的JVM进程；</p>
</li>
<li><p>SparkSubmit类中的main方法反射调用YarnClusterApplication的main方法；</p>
</li>
<li><p>YarnClusterApplication创建Yarn客户端，然后向Yarn服务器发送执行指令：bin&#x2F;java ApplicationMaster；</p>
</li>
<li><p>Yarn框架收到指令后会在指定的NM中启动ApplicationMaster；</p>
</li>
<li><p>ApplicationMaster启动Driver线程，执行用户的作业；</p>
</li>
<li><p>AM向RM注册，申请资源；</p>
</li>
<li><p>获取资源后AM向NM发送指令：bin&#x2F;java YarnCoarseGrainedExecutorBackend；</p>
</li>
<li><p>CoarseGrainedExecutorBackend进程会接收消息，跟Driver通信，注册已经启动的Executor；然后启动计算对象Executor等待接收任务</p>
</li>
<li><p>Driver线程继续执行完成作业的调度和任务的执行。</p>
</li>
<li><p>Driver分配任务并监控任务的执行。</p>
</li>
</ol>
<p><strong>注意：SparkSubmit、ApplicationMaster和CoarseGrainedExecutorBackend是独立的进程；Driver是独立的线程；Executor和YarnClusterApplication是对象。</strong></p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662782335938.png" alt="1662782335938"></p>
<h4 id="2-2-Client模式"><a href="#2-2-Client模式" class="headerlink" title="2.2 Client模式"></a>2.2 Client模式</h4><p>​	该模式尽量不要使用，他和Cluster的区别在于Driver端存在的位置，Client模式会把Driver放到本机中去执行，Cluster会再某一个NodeManager之中选择创建ApplicationMaster，然后再APPMaster之中创建一个线程，就是Driver，但是client的电脑性能较低，集群中的executor都需要与Dirver进行交互，这样有极大的可能造成雪崩。因此我们一般使用Cluster模式。</p>
<p>​	</p>
<ol>
<li><p>执行脚本提交任务，实际是启动一个SparkSubmit的JVM进程；</p>
</li>
<li><p>SparkSubmit类中的main方法反射调用用户代码的main方法；</p>
</li>
<li><p>启动Driver线程，执行用户的作业，并创建ScheduleBackend；</p>
</li>
<li><p>YarnClientSchedulerBackend向RM发送指令：bin&#x2F;java ExecutorLauncher；</p>
</li>
<li><p>Yarn框架收到指令后会在指定的NM中启动ExecutorLauncher（实际上还是调用ApplicationMaster的main方法）；</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ExecutorLauncher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">ApplicationMaster</span>.main(args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>AM向RM注册，申请资源；</p>
</li>
<li><p>获取资源后AM向NM发送指令：bin&#x2F;java CoarseGrainedExecutorBackend；</p>
</li>
<li><p>CoarseGrainedExecutorBackend进程会接收消息，跟Driver通信，注册已经启动的Executor；然后启动计算对象Executor等待接收任务</p>
</li>
<li><p>Driver分配任务并监控任务的执行。</p>
</li>
</ol>
<p><strong>注意：SparkSubmit、ApplicationMaster和YarnCoarseGrainedExecutorBackend是独立的进程；Executor和Driver是对象。</strong></p>
<h3 id="2-2-Standalone-模式"><a href="#2-2-Standalone-模式" class="headerlink" title="2.2 Standalone 模式"></a>2.2 Standalone 模式</h3><h4 id="2-2-1-Standalone-Cluster模式"><a href="#2-2-1-Standalone-Cluster模式" class="headerlink" title="2.2.1 Standalone  Cluster模式"></a>2.2.1 Standalone  Cluster模式</h4><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662782536754.png" alt="1662782536754"></p>
<p>​	在Standalone Cluster模式下，任务提交后，Master会找到一个Worker启动Driver。Driver启动后向Master注册应用程序，Master根据submit脚本的资源需求找到内部资源至少可以启动一个Executor的所有Worker，然后在这些Worker之间分配Executor，Worker上的Executor启动后会向Driver反向注册，所有的Executor注册完成后，Driver开始执行main函数，之后执行到Action算子时，开始划分Stage，每个Stage生成对应的taskSet，之后将Task分发到各个Executor上执行。</p>
<h4 id="2-2-2-Standalone-Client模式"><a href="#2-2-2-Standalone-Client模式" class="headerlink" title="2.2.2 Standalone  Client模式"></a>2.2.2 Standalone  Client模式</h4><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662782564006.png" alt="1662782564006"></p>
<p>​	在Standalone Client模式下，Driver在任务提交的本地机器上运行。Driver启动后向Master注册应用程序，Master根据submit脚本的资源需求找到内部资源至少可以启动一个Executor的所有Worker，然后在这些Worker之间分配Executor，Worker上的Executor启动后会向Driver反向注册，所有的Executor注册完成后，Driver开始执行main函数，之后执行到Action算子时，开始划分Stage，每个Stage生成对应的TaskSet，之后将Task分发到各个Executor上执行。</p>
<h2 id="3-Spark通信架构"><a href="#3-Spark通信架构" class="headerlink" title="3. Spark通信架构"></a>3. Spark通信架构</h2><h3 id="3-1-Spark通信架构概述"><a href="#3-1-Spark通信架构概述" class="headerlink" title="3.1 Spark通信架构概述"></a>3.1 Spark通信架构概述</h3><p>Spark中通信框架的发展：</p>
<ul>
<li><p>Spark早期版本中采用Akka作为内部通信部件。</p>
</li>
<li><p>Spark1.3中引入Netty通信框架，为了解决Shuffle的大数据传输问题使用</p>
</li>
<li><p>Spark1.6中Akka和Netty可以配置使用。Netty完全实现了Akka在Spark中的功能。</p>
</li>
<li><p>Spark2系列中，Spark抛弃Akka，使用Netty。</p>
</li>
</ul>
<p>Spark2.x版本使用Netty通讯框架作为内部通讯组件。Spark 基于Netty新的RPC框架借鉴了Akka的中的设计，它是基于Actor模型，如下图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662793541559.png" alt="1662793541559"></p>
<p>Spark通讯框架中各个组件（Client&#x2F;Master&#x2F;Worker）可以认为是一个个独立的实体，各个实体之间通过消息来进行通信。具体各个组件之间的关系图如下</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662793573641.png" alt="1662793573641"></p>
<h3 id="3-2-Spark通信架构解析"><a href="#3-2-Spark通信架构解析" class="headerlink" title="3.2 Spark通信架构解析"></a>3.2 Spark通信架构解析</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662794291110.png" alt="1662794291110"></p>
<ul>
<li><p>RpcEndpoint：RPC通信终端。Spark针对每个节点（Client&#x2F;Master&#x2F;Worker）都称之为一个RPC终端，且都实现RpcEndpoint接口，内部根据不同端点的需求，设计不同的消息和不同的业务处理，如果需要发送（询问）则调用Dispatcher。在Spark中，所有的终端都存在生命周期：</p>
<ul>
<li><p>Constructor</p>
</li>
<li><p>onStart</p>
</li>
<li><p>receive*</p>
</li>
<li><p>onStop</p>
</li>
</ul>
</li>
<li><p>RpcEnv：RPC上下文环境，每个RPC终端运行时依赖的上下文环境称为RpcEnv；在把当前Spark版本中使用的NettyRpcEnv</p>
</li>
<li><p>Dispatcher：消息调度（分发）器，针对于RPC终端需要发送远程消息或者从远程RPC接收到的消息，分发至对应的指令收件箱（发件箱）。如果指令接收方是自己则存入收件箱，如果指令接收方不是自己，则放入发件箱；</p>
</li>
<li><p>Inbox：指令消息收件箱。一个本地RpcEndpoint对应一个收件箱，Dispatcher在每次向Inbox存入消息时，都将对应EndpointData加入内部ReceiverQueue中，另外Dispatcher创建时会启动一个单独线程进行轮询ReceiverQueue，进行收件箱消息消费；</p>
</li>
<li><p>RpcEndpointRef：RpcEndpointRef是对远程RpcEndpoint的一个引用。当我们需要向一个具体的RpcEndpoint发送消息时，一般我们需要获取到该RpcEndpoint的引用，然后通过该应用发送消息。</p>
</li>
<li><p>OutBox：指令消息发件箱。对于当前RpcEndpoint来说，一个目标RpcEndpoint对应一个发件箱，如果向多个目标RpcEndpoint发送信息，则有多个OutBox。当消息放入Outbox后，紧接着通过TransportClient将消息发送出去。消息放入发件箱以及发送过程是在同一个线程中进行；</p>
</li>
<li><p>RpcAddress：表示远程的RpcEndpointRef的地址，Host + Port。</p>
</li>
<li><p>TransportClient：Netty通信客户端，一个OutBox对应一个TransportClient，TransportClient不断轮询OutBox，根据OutBox消息的receiver信息，请求对应的远程TransportServer；</p>
</li>
<li><p>TransportServer：Netty通信服务端，一个RpcEndpoint对应一个TransportServer，接受远程消息后调用Dispatcher分发消息至对应收发件箱；</p>
</li>
</ul>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662792867862.png" alt="1662792867862"></p>
<h2 id="4-Spark任务调度机制"><a href="#4-Spark任务调度机制" class="headerlink" title="4. Spark任务调度机制"></a>4. Spark任务调度机制</h2><p>​	在生产环境下，Spark集群的部署方式一般为YARN-Cluster模式，之后的内核分析内容中我们默认集群的部署方式为YARN-Cluster模式。在上一章中我们讲解了Spark YARN-Cluster模式下的任务提交流程，但是我们并没有具体说明Driver的工作流程， Driver线程主要是初始化SparkContext对象，准备运行所需的上下文，然后一方面保持与ApplicationMaster的RPC连接，通过ApplicationMaster申请资源，另一方面根据用户业务逻辑开始调度任务，将任务下发到已有的空闲Executor上。</p>
<p>​	当ResourceManager向ApplicationMaster返回Container资源时，ApplicationMaster就尝试在对应的Container上启动Executor进程，Executor进程起来后，会向Driver反向注册，注册成功后保持与Driver的心跳，同时等待Driver分发任务，当分发的任务执行完毕后，将任务状态上报给Driver。	</p>
<h3 id="4-1-Spark调度概述"><a href="#4-1-Spark调度概述" class="headerlink" title="4.1 Spark调度概述"></a>4.1 Spark调度概述</h3><p>当Driver起来后，Driver则会根据用户程序逻辑准备任务，并根据Executor资源情况逐步分发任务。在详细阐述任务调度前，首先说明下Spark里的几个概念。一个Spark应用程序包括Job、Stage以及Task三个概念：</p>
<ol>
<li><p>Job是以Action方法为界，遇到一个Action方法则触发一个Job；</p>
</li>
<li><p>Stage是Job的子集，以RDD宽依赖(即Shuffle)为界，遇到Shuffle做一次划分；</p>
</li>
<li><p>Task是Stage的子集，以并行度(分区数)来衡量，分区数是多少，则有多少个task。</p>
</li>
</ol>
<p>Spark的任务调度总体来说分两路进行，一路是Stage级的调度，一路是Task级的调度，总体调度流程如下图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796146622.png" alt="1662796146622"></p>
<p>Spark RDD通过其Transactions操作，形成了RDD血缘（依赖）关系图，即DAG，最后通过Action的调用，触发Job并调度执行，执行过程中会创建两个调度器：DAGScheduler和TaskScheduler。</p>
<ul>
<li><p>DAGScheduler负责Stage级的调度，主要是将job切分成若干Stages，并将每个Stage打包成TaskSet交给TaskScheduler调度。</p>
</li>
<li><p>TaskScheduler负责Task级的调度，将DAGScheduler给过来的TaskSet按照指定的调度策略分发到Executor上执行，调度过程中SchedulerBackend负责提供可用资源，其中SchedulerBackend有多种实现，分别对接不同的资源管理系统。</p>
</li>
</ul>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796171132.png" alt="1662796171132"></p>
<p>​	Driver初始化SparkContext过程中，会分别初始化DAGScheduler、TaskScheduler、SchedulerBackend以及HeartbeatReceiver，并启动SchedulerBackend以及HeartbeatReceiver。SchedulerBackend通过ApplicationMaster申请资源，并不断从TaskScheduler中拿到合适的Task分发到Executor执行。HeartbeatReceiver负责接收Executor的心跳信息，监控Executor的存活状况，并通知到TaskScheduler。</p>
<h3 id="4-2-Stage调度"><a href="#4-2-Stage调度" class="headerlink" title="4.2 Stage调度"></a>4.2 Stage调度</h3><p>​	Spark的任务调度是从DAG切割开始，主要是由DAGScheduler来完成。当遇到一个Action操作后就会触发一个Job的计算，并交给DAGScheduler来提交，下图是涉及到Job提交的相关方法调用流程图。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796215480.png" alt="1662796215480"></p>
<ol>
<li><p>Job由最终的RDD和Action方法封装而成；</p>
</li>
<li><p>SparkContext将Job交给DAGScheduler提交，它会根据RDD的血缘关系构成的DAG进行切分，将一个Job划分为若干Stages，具体划分策略是，由最终的RDD不断通过依赖回溯判断父依赖是否是宽依赖，即以Shuffle为界，划分Stage，窄依赖的RDD之间被划分到同一个Stage中，可以进行pipeline式的计算。划分的Stages分两类，一类叫做ResultStage，为DAG最下游的Stage，由Action方法决定，另一类叫做ShuffleMapStage，为下游Stage准备数据，下面看一个简单的例子WordCount。</p>
</li>
</ol>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796229819.png" alt="1662796229819"></p>
<p>​	Job由saveAsTextFile触发，该Job由RDD-3和saveAsTextFile方法组成，根据RDD之间的依赖关系从RDD-3开始回溯搜索，直到没有依赖的RDD-0，在回溯搜索过程中，RDD-3依赖RDD-2，并且是宽依赖，所以在RDD-2和RDD-3之间划分Stage，RDD-3被划到最后一个Stage，即ResultStage中，RDD-2依赖RDD-1，RDD-1依赖RDD-0，这些依赖都是窄依赖，所以将RDD-0、RDD-1和RDD-2划分到同一个Stage，形成pipeline操作，。即ShuffleMapStage中，实际执行的时候，数据记录会一气呵成地执行RDD-0到RDD-2的转化。不难看出，其本质上是一个深度优先搜索（Depth First Search）算法。</p>
<p>​	一个Stage是否被提交，需要判断它的父Stage是否执行，只有在父Stage执行完毕才能提交当前Stage，如果一个Stage没有父Stage，那么从该Stage开始提交。Stage提交时会将Task信息（分区信息以及方法等）序列化并被打包成TaskSet交给TaskScheduler，一个Partition对应一个Task，另一方面TaskScheduler会监控Stage的运行状态，只有Executor丢失或者Task由于Fetch失败才需要重新提交失败的Stage以调度运行失败的任务，其他类型的Task失败会在TaskScheduler的调度过程中重试。</p>
<p>​	相对来说DAGScheduler做的事情较为简单，仅仅是在Stage层面上划分DAG，提交Stage并监控相关状态信息。TaskScheduler则相对较为复杂，下面详细阐述其细节。</p>
<h3 id="4-3-task级调度"><a href="#4-3-task级调度" class="headerlink" title="4.3 task级调度"></a>4.3 task级调度</h3><p>​	Spark Task的调度是由TaskScheduler来完成，由前文可知，DAGScheduler将Stage打包到交给TaskScheTaskSetduler，TaskScheduler会将TaskSet封装为TaskSetManager加入到调度队列中，TaskSetManager结构如下图所示。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796267431.png" alt="1662796267431"></p>
<p>​	TaskSetManager负责监控管理同一个Stage中的Tasks，TaskScheduler就是以TaskSetManager为单元来调度任务。</p>
<p>​	前面也提到，TaskScheduler初始化后会启动SchedulerBackend，它负责跟外界打交道，接收Executor的注册信息，并维护Executor的状态，所以说SchedulerBackend是管“粮食”的，同时它在启动后会定期地去“询问”TaskScheduler有没有任务要运行，也就是说，它会定期地“问”TaskScheduler“我有这么余粮，你要不要啊”，TaskScheduler在SchedulerBackend“问”它的时候，会从调度队列中按照指定的调度策略选择TaskSetManager去调度运行，大致方法调用流程如下图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796291094.png" alt="1662796291094"></p>
<p>​	上图中，将TaskSetManager加入rootPool调度池中之后，调用SchedulerBackend的riviveOffers方法给driverEndpoint发送ReviveOffer消息；driverEndpoint收到ReviveOffer消息后调用makeOffers方法，过滤出活跃状态的Executor（这些Executor都是任务启动时反向注册到Driver的Executor），然后将Executor封装成WorkerOffer对象；准备好计算资源（WorkerOffer）后，taskScheduler基于这些资源调用resourceOffer在Executor上分配task。</p>
<h4 id="4-3-1-调度策略"><a href="#4-3-1-调度策略" class="headerlink" title="4.3.1 调度策略"></a>4.3.1 调度策略</h4><p>TaskScheduler支持两种调度策略，一种是FIFO，也是默认的调度策略，另一种是FAIR。在TaskScheduler初始化过程中会实例化rootPool，表示树的根节点，是Pool类型。</p>
<ol>
<li>FIFO调度策略</li>
</ol>
<p>如果是采用FIFO调度策略，则直接简单地将TaskSetManager按照先来先到的方式入队，出队时直接拿出最先进队的TaskSetManager，其树结构如下图所示，TaskSetManager保存在一个FIFO队列中。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796335654.png" alt="1662796335654"></p>
<ol start="2">
<li>FAIR调度策略</li>
</ol>
<p>FAIR调度策略的树结构如下图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796352169.png" alt="1662796352169"></p>
<p>​	FAIR模式中有一个rootPool和多个子Pool，各个子Pool中存储着所有待分配的TaskSetMagager。</p>
<p>​	在FAIR模式中，需要先对子Pool进行排序，再对子Pool里面的TaskSetMagager进行排序，因为Pool和TaskSetMagager都继承了Schedulable特质，因此使用相同的排序算法。</p>
<p>​	排序过程的比较是基于Fair-share来比较的，每个要排序的对象包含三个属性: runningTasks值（正在运行的Task数）、minShare值、weight值，比较时会综合考量runningTasks值，minShare值以及weight值。</p>
<p>​	注意，minShare、weight的值均在公平调度配置文件fairscheduler.xml中被指定，调度池在构建阶段会读取此文件的相关配置。</p>
<ol>
<li><p>如果A对象的runningTasks大于它的minShare，B对象的runningTasks小于它的minShare，那么B排在A前面；（runningTasks比minShare小的先执行）</p>
</li>
<li><p>如果A、B对象的runningTasks都小于它们的minShare，那么就比较runningTasks与minShare的比值（minShare使用率），谁小谁排前面；（minShare使用率低的先执行）</p>
</li>
<li><p>如果A、B对象的runningTasks都大于它们的minShare，那么就比较runningTasks与weight的比值（权重使用率），谁小谁排前面。（权重使用率低的先执行）</p>
</li>
<li><p>如果上述比较均相等，则比较名字。</p>
</li>
</ol>
<p>​	整体上来说就是通过minShare和weight这两个参数控制比较过程，可以做到让minShare使用率和权重使用率少（实际运行task比例较少）的先运行。</p>
<p>​	FAIR模式排序完成后，所有的TaskSetManager被放入一个ArrayBuffer里，之后依次被取出并发送给Executor执行。</p>
<p>​	从调度队列中拿到TaskSetManager后，由于TaskSetManager封装了一个Stage的所有Task，并负责管理调度这些Task，那么接下来的工作就是TaskSetManager按照一定的规则一个个取出Task给TaskScheduler，TaskScheduler再交给SchedulerBackend去发到Executor上执行。</p>
<h4 id="4-3-2-本地化调度"><a href="#4-3-2-本地化调度" class="headerlink" title="4.3.2 本地化调度"></a>4.3.2 本地化调度</h4><p>​	DAGScheduler切割Job，划分Stage, 通过调用submitStage来提交一个Stage对应的tasks，submitStage会调用submitMissingTasks，submitMissingTasks 确定每个需要计算的 task 的preferredLocations，通过调用getPreferrdeLocations()得到partition 的优先位置，由于一个partition对应一个Task，此partition的优先位置就是task的优先位置，对于要提交到TaskScheduler的TaskSet中的每一个Task，该task优先位置与其对应的partition对应的优先位置一致。</p>
<p>​	从调度队列中拿到TaskSetManager后，那么接下来的工作就是TaskSetManager按照一定的规则一个个取出task给TaskScheduler，TaskScheduler再交给SchedulerBackend去发到Executor上执行。前面也提到，TaskSetManager封装了一个Stage的所有Task，并负责管理调度这些Task。</p>
<p>​	根据每个Task的优先位置，确定Task的Locality级别，Locality一共有五种，优先级由高到低顺序：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>PROCESS_LOCAL</td>
<td>进程本地化，task和数据在同一个Executor中，性能最好。</td>
</tr>
<tr>
<td>NODE_LOCAL</td>
<td>节点本地化，task和数据在同一个节点中，但是task和数据不在同一个Executor中，数据需要在进程间进行传输。</td>
</tr>
<tr>
<td>RACK_LOCAL</td>
<td>机架本地化，task和数据在同一个机架的两个节点上，数据需要通过网络在节点之间进行传输。</td>
</tr>
<tr>
<td>NO_PREF</td>
<td>对于task来说，从哪里获取都一样，没有好坏之分。</td>
</tr>
<tr>
<td>ANY</td>
<td>task和数据可以在集群的任何地方，而且不在一个机架中，性能最差。</td>
</tr>
</tbody></table>
<p>​	在调度执行时，Spark调度总是会尽量让每个task以最高的本地性级别来启动，当一个task以X本地性级别启动，但是该本地性级别对应的所有节点都没有空闲资源而启动失败，此时并不会马上降低本地性级别启动而是在某个时间长度内再次以X本地性级别来启动该task，若超过限时时间则降级启动，去尝试下一个本地性级别，依次类推。</p>
<p>​	可以通过调大每个类别的最大容忍延迟时间，在等待阶段对应的Executor可能就会有相应的资源去执行此task，这就在在一定程度上提到了运行性能。</p>
<h4 id="4-3-3-失败重传和黑名单机制"><a href="#4-3-3-失败重传和黑名单机制" class="headerlink" title="4.3.3 失败重传和黑名单机制"></a>4.3.3 失败重传和黑名单机制</h4><p>​	除了选择合适的Task调度运行外，还需要监控Task的执行状态，前面也提到，与外部打交道的是SchedulerBackend，Task被提交到Executor启动执行后，Executor会将执行状态上报给SchedulerBackend，SchedulerBackend则告诉TaskScheduler，TaskScheduler找到该Task对应的TaskSetManager，并通知到该TaskSetManager，这样TaskSetManager就知道Task的失败与成功状态，对于失败的Task，会记录它失败的次数，如果失败次数还没有超过最大重试次数，那么就把它放回待调度的Task池子中，否则整个Application失败。</p>
<p>​	在记录Task失败次数过程中，会记录它上一次失败所在的Executor Id和Host，这样下次再调度这个Task时，会使用黑名单机制，避免它被调度到上一次失败的节点上，起到一定的容错作用。黑名单记录Task上一次失败所在的Executor Id和Host，以及其对应的“拉黑”时间，“拉黑”时间是指这段时间内不要再往这个节点上调度这个Task了。</p>
<h2 id="5-Spark-shuffle-解析"><a href="#5-Spark-shuffle-解析" class="headerlink" title="5. Spark shuffle 解析"></a>5. Spark shuffle 解析</h2><h3 id="5-1-ShuffleMapStage与ResultStage"><a href="#5-1-ShuffleMapStage与ResultStage" class="headerlink" title="5.1 ShuffleMapStage与ResultStage"></a>5.1 ShuffleMapStage与ResultStage</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796806091.png" alt="1662796806091"></p>
<p>​	在划分stage时，最后一个stage称为finalStage，它本质上是一个ResultStage对象，前面的所有stage被称为ShuffleMapStage。</p>
<p>​	ShuffleMapStage的结束伴随着shuffle文件的写磁盘。</p>
<p>​	ResultStage基本上对应代码中的action算子，即将一个函数应用在RDD的各个partition的数据集上，意味着一个job的运行结束。</p>
<h3 id="5-2-HashShuffle解析"><a href="#5-2-HashShuffle解析" class="headerlink" title="5.2 HashShuffle解析"></a>5.2 HashShuffle解析</h3><h4 id="5-2-1-未优化的HashShuffle"><a href="#5-2-1-未优化的HashShuffle" class="headerlink" title="5.2.1 未优化的HashShuffle"></a>5.2.1 未优化的HashShuffle</h4><p>​	这里我们先明确一个假设前提：每个Executor只有1个CPU core，也就是说，无论这个Executor上分配多少个task线程，同一时间都只能执行一个task线程。</p>
<p>​	如下图中有3个 Reducer，从Task 开始那边各自把自己进行 Hash 计算(分区器：hash&#x2F;numreduce取模)，分类出3个不同的类别，每个 Task 都分成3种类别的数据，想把不同的数据汇聚然后计算出最终的结果，所以Reducer 会在每个 Task 中把属于自己类别的数据收集过来，汇聚成一个同类别的大集合，每1个 Task 输出3份本地文件，这里有4个 Mapper Tasks，所以总共输出了4个 Tasks x 3个分类文件 &#x3D; 12个本地小文件。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662796963811.png" alt="1662796963811"></p>
<h4 id="5-2-2-优化后的HashShuffle"><a href="#5-2-2-优化后的HashShuffle" class="headerlink" title="5.2.2 优化后的HashShuffle"></a>5.2.2 优化后的HashShuffle</h4><p>​	优化的HashShuffle过程就是启用合并机制，合并机制就是复用buffer，开启合并机制的配置是spark.shuffle.consolidateFiles。该参数默认值为false，将其设置为true即可开启优化机制。通常来说，如果我们使用HashShuffleManager，那么都建议开启这个选项。</p>
<p>​	这里还是有4个Tasks，数据类别还是分成3种类型，因为Hash算法会根据你的 Key 进行分类，在同一个进程中，无论是有多少过Task，都会把同样的Key放在同一个Buffer里，然后把Buffer中的数据写入以Core数量为单位的本地文件中，(一个Core只有一种类型的Key的数据)，每1个Task所在的进程中，分别写入共同进程中的3份本地文件，这里有4个Mapper Tasks，所以总共输出是 2个Cores x 3个分类文件 &#x3D; 6个本地小文件。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797077555.png" alt="1662797077555"></p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797358038.png" alt="1662797358038"></p>
<h3 id="5-3-SortShuffle解析"><a href="#5-3-SortShuffle解析" class="headerlink" title="5.3 SortShuffle解析"></a>5.3 SortShuffle解析</h3><p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662798548677.png" alt="1662798548677"></p>
<h4 id="5-3-1-普通SortShuffle"><a href="#5-3-1-普通SortShuffle" class="headerlink" title="5.3.1 普通SortShuffle"></a>5.3.1 普通SortShuffle</h4><p>​	在该模式下，数据会先写入一个数据结构，reduceByKey写入Map，一边通过Map局部聚合，一遍写入内存。Join算子写入ArrayList直接写入内存中。然后需要判断是否达到阈值，如果达到就会将内存数据结构的数据写入到磁盘，清空内存数据结构。</p>
<p>​	在溢写磁盘前，先根据key进行排序，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个Task过程会产生多个临时文件。</p>
<p>​	最后在每个Task中，将所有的临时文件合并，这就是merge过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个Task的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个Task的数据在文件中的索引，start offset和end offset。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797475727.png" alt="1662797475727"></p>
<h4 id="5-3-2-bypass-SortShuffle"><a href="#5-3-2-bypass-SortShuffle" class="headerlink" title="5.3.2 bypass SortShuffle"></a>5.3.2 bypass SortShuffle</h4><p>​	bypass运行机制的触发条件如下：</p>
<p><strong>1. shuffle reduce task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值，默认为200。</strong></p>
<p><strong>2. 不是预聚合类的shuffle算子（比如reduceByKey）。</strong></p>
<p>​	此时task会为每个reduce端的task都创建一个临时磁盘文件，并将数据按key进行hash然后根据key的hash值，将key写入对应的磁盘文件之中。当然，写入磁盘文件时也是先写入内存缓冲，缓冲写满之后再溢写到磁盘文件的。最后，同样会将所有临时磁盘文件都合并成一个磁盘文件，并创建一个单独的索引文件。</p>
<p>​	该过程的磁盘写机制其实跟未经优化的HashShuffleManager是一模一样的，因为都要创建数量惊人的磁盘文件，只是在最后会做一个磁盘文件的合并而已。因此少量的最终磁盘文件，也让该机制相对未经优化的HashShuffleManager来说，shuffle read的性能会更好。</p>
<p>​	而该机制与普通SortShuffleManager运行机制的不同在于：不会进行排序。也就是说，启用该机制的最大好处在于，shuffle write过程中，不需要进行数据的排序操作，也就节省掉了这部分的性能开销。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662797957056.png" alt="1662797957056"></p>
<h2 id="6-Spark-内存管理"><a href="#6-Spark-内存管理" class="headerlink" title="6. Spark 内存管理"></a>6. Spark 内存管理</h2><h3 id="6-1-堆内内存和堆外内存规划"><a href="#6-1-堆内内存和堆外内存规划" class="headerlink" title="6.1 堆内内存和堆外内存规划"></a>6.1 堆内内存和堆外内存规划</h3><p>​	作为一个JVM 进程，Executor 的内存管理建立在JVM的内存管理之上，Spark对 JVM的堆内（On-heap）空间进行了更为详细的分配，以充分利用内存。同时，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，进一步优化了内存的使用。堆内内存受到JVM统一管理，堆外内存是直接向操作系统进行内存的申请和释放。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662810917491.png" alt="1662810917491"></p>
<ol>
<li><p><strong>堆内内存</strong></p>
<p>​	堆内内存的大小，由Spark应用程序启动时的 –executor-memory 或 spark.executor.memory 参数配置。Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存，而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些Spark内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。不同的管理模式下，这三部分占用的空间大小各不相同。</p>
<p>​	Spark对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由JVM完成，Spark只能在申请后和释放前记录这些内存，我们来看其具体流程：</p>
<p>​	申请内存流程如下：</p>
<p>​		Spark 在代码中 new 一个对象实例；</p>
<p>​		JVM 从堆内内存分配空间，创建对象并返回对象引用；</p>
<p>​		Spark 保存该对象的引用，记录该对象占用的内存。</p>
<p>​	释放内存流程如下：</p>
<p>​		Spark记录该对象释放的内存，删除该对象的引用；</p>
<p>​		等待JVM的垃圾回收机制释放该对象占用的堆内内存。</p>
<p>​	我们知道，JVM 的对象可以以序列化的方式存储，序列化的过程是将对象转换为二进制字节流，本质上可以理解为将非连续空间的链式存储转化为连续空间或块存储，在访问时则需要进行序列化的逆过程——反序列化，将字节流转化为对象，序列化的方式可以节省存储空间，但增加了存储和读取时候的计算开销。</p>
<p>​	对于Spark中序列化的对象，由于是字节流的形式，其占用的内存大小可直接计算，而对于非序列化的对象，其占用的内存是通过周期性地采样近似估算而得，即并不是每次新增的数据项都会计算一次占用的内存大小，这种方法降低了时间开销但是有可能误差较大，导致某一时刻的实际内存有可能远远超出预期。此外，在被Spark标记为释放的对象实例，很有可能在实际上并没有被JVM回收，导致实际可用的内存小于Spark记录的可用内存。所以 Spark并不能准确记录实际可用的堆内内存，从而也就无法完全避免内存溢出（OOM, Out of Memory）的异常。</p>
<p>​	虽然不能精准控制堆内内存的申请和释放，但 Spark 通过对存储内存和执行内存各自独立的规划管理，可以决定是否要在存储内存里缓存新的 RDD，以及是否为新的任务分配执行内存，在一定程度上可以提升内存的利用率，减少异常的出现。</p>
</li>
<li><p><strong>堆外内存</strong></p>
<p>​	为了进一步优化内存的使用以及提高Shuffle时排序的效率，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。</p>
<p>​	堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。</p>
<p>​	利用JDK Unsafe API（从Spark 2.0开始，在管理堆外的存储内存时不再基于Tachyon，而是与堆外的执行内存一样，基于 JDK Unsafe API 实现），Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过JVM机制，而是直接向操作系统申请，JVM对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。</p>
<p>​	在默认情况下堆外内存并不启用，可通过配置 spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size 参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。</p>
</li>
</ol>
<h3 id="6-2-内存分配"><a href="#6-2-内存分配" class="headerlink" title="6.2 内存分配"></a>6.2 内存分配</h3><p><strong>静态内存管理</strong></p>
<p>​	在Spark最初采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在Spark应用程序运行期间均为固定的，但用户可以应用程序启动前进行配置，堆内内存的分配如图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811152441.png" alt="1662811152441"></p>
<p>​	可以看到，可用的堆内内存的大小需要按照下列方式计算：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可用的存储内存 = systemMaxMemory * spark.storage.memoryFraction * spark.storage.safety Fraction</span><br><span class="line">可用的执行内存 = systemMaxMemory * spark.shuffle.memoryFraction * spark.shuffle.safety Fraction</span><br></pre></td></tr></table></figure>

<p>​	其中systemMaxMemory取决于当前JVM堆内内存的大小，最后可用的执行内存或者存储内存要在此基础上与各自的memoryFraction 参数和safetyFraction 参数相乘得出。上述计算公式中的两个 safetyFraction 参数，其意义在于在逻辑上预留出 1-safetyFraction 这么一块保险区域，降低因实际内存超出当前预设范围而导致 OOM 的风险（上文提到，对于非序列化对象的内存采样估算会产生误差）。值得注意的是，这个预留的保险区域仅仅是一种逻辑上的规划，在具体使用时 Spark 并没有区别对待，和”其它内存”一样交给了 JVM 去管理。</p>
<p>​	Storage内存和Execution内存都有预留空间，目的是防止OOM，因为Spark堆内内存大小的记录是不准确的，需要留出保险区域。</p>
<p>​	堆外的空间分配较为简单，只有存储内存和执行内存，如下图所示。可用的执行内存和存储内存占用的空间大小直接由参数spark.memory.storageFraction 决定，由于堆外内存占用的空间可以被精确计算，所以无需再设定保险区域。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811227103.png" alt="1662811227103"></p>
<p>​	静态内存管理机制实现起来较为简单，但如果用户不熟悉Spark的存储机制，或没有根据具体的数据规模和计算任务或做相应的配置，很容易造成”一半海水，一半火焰”的局面，即存储内存和执行内存中的一方剩余大量的空间，而另一方却早早被占满，不得不淘汰或移出旧的内容以存储新的内容。由于新的内存管理机制的出现，这种方式目前已经很少有开发者使用，出于兼容旧版本的应用程序的目的，Spark 仍然保留了它的实现。</p>
<p><strong>动态内存管理</strong></p>
<p>​	Spark1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域，统一内存管理的堆内内存结构如图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811270969.png" alt="1662811270969"></p>
<p>​	统一内存管理的堆外内存结构如下图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811288550.png" alt="1662811288550"></p>
<p>其中最重要的优化在于动态占用机制，其规则如下：</p>
<ol>
<li><p>设定基本的存储内存和执行内存区域（spark.storage.storageFraction参数），该设定确定了双方各自拥有的空间的范围；</p>
</li>
<li><p>双方的空间都不足时，则存储到硬盘；若己方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的Block）</p>
</li>
<li><p>执行内存的空间被对方占用后，可让对方将占用的部分转存到硬盘，然后”归还”借用的空间；</p>
</li>
<li><p>存储内存的空间被对方占用后，无法让对方”归还”，因为需要考虑 Shuffle过程中的很多因素，实现起来较为复杂。</p>
</li>
</ol>
<p>统一内存管理的动态占用机制如图所示：</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811314259.png" alt="1662811314259"></p>
<p>​	凭借统一内存管理机制，Spark在一定程度上提高了堆内和堆外内存资源的利用率，降低了开发者维护Spark内存的难度，但并不意味着开发者可以高枕无忧。如果存储内存的空间太大或者说缓存的数据过多，反而会导致频繁的全量垃圾回收，降低任务执行时的性能，因为缓存的RDD数据通常都是长期驻留内存的。所以要想充分发挥Spark的性能，需要开发者进一步了解存储内存和执行内存各自的管理方式和实现原理。</p>
<h3 id="6-3-存储内存管理"><a href="#6-3-存储内存管理" class="headerlink" title="6.3 存储内存管理"></a>6.3 存储内存管理</h3><p><strong>RDD持久化机制</strong></p>
<p>​	弹性分布式数据集（RDD）作为 Spark 最根本的数据抽象，是只读的分区记录（Partition）的集合，只能基于在稳定物理存储中的数据集上创建，或者在其他已有的RDD上执行转换（Transformation）操作产生一个新的RDD。转换后的RDD与原始的RDD之间产生的依赖关系，构成了血统（Lineage）。凭借血统，Spark 保证了每一个RDD都可以被重新恢复。但RDD的所有转换都是惰性的，即只有当一个返回结果给Driver的行动（Action）发生时，Spark才会创建任务读取RDD，然后真正触发转换的执行。</p>
<p>​	Task在启动之初读取一个分区时，会先判断这个分区是否已经被持久化，如果没有则需要检查Checkpoint 或按照血统重新计算。所以如果一个 RDD 上要执行多次行动，可以在第一次行动中使用 persist或cache 方法，在内存或磁盘中持久化或缓存这个RDD，从而在后面的行动时提升计算速度。</p>
<p>​	事实上，cache 方法是使用默认的 MEMORY_ONLY 的存储级别将 RDD 持久化到内存，故缓存是一种特殊的持久化。 堆内和堆外存储内存的设计，便可以对缓存RDD时使用的内存做统一的规划和管理。</p>
<p>​	RDD的持久化由 Spark的Storage模块负责，实现了RDD与物理存储的解耦合。Storage模块负责管理Spark在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来。在具体实现时Driver端和 Executor 端的Storage模块构成了主从式的架构，即Driver端的BlockManager为Master，Executor端的BlockManager 为 Slave。</p>
<p>​	Storage模块在逻辑上以Block为基本存储单位，RDD的每个Partition经过处理后唯一对应一个 Block（BlockId 的格式为rdd_RDD-ID_PARTITION-ID ）。Driver端的Master负责整个Spark应用程序的Block的元数据信息的管理和维护，而Executor端的Slave需要将Block的更新等状态上报到Master，同时接收Master 的命令，例如新增或删除一个RDD。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811414359.png" alt="1662811414359"></p>
<p>​	在对RDD持久化时，Spark规定了MEMORY_ONLY、MEMORY_AND_DISK 等7种不同的存储级别，而存储级别是以下5个变量的组合：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class StorageLevel private(</span><br><span class="line">private var _useDisk: Boolean, //磁盘</span><br><span class="line">private var _useMemory: Boolean, //这里其实是指堆内内存</span><br><span class="line">private var _useOffHeap: Boolean, //堆外内存</span><br><span class="line">private var _deserialized: Boolean, //是否为非序列化</span><br><span class="line">private var _replication: Int = 1 //副本个数</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​	Spark中7种存储级别如下：</p>
<table>
<thead>
<tr>
<th><strong>持久化级别</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MEMORY_ONLY</td>
<td>以非序列化的Java对象的方式持久化在JVM内存中。如果内存无法完全存储RDD所有的partition，那么那些没有持久化的partition就会在下一次需要使用它们的时候，重新被计算</td>
</tr>
<tr>
<td>MEMORY_AND_DISK</td>
<td>同上，但是当某些partition无法存储在内存中时，会持久化到磁盘中。下次需要使用这些partition时，需要从磁盘上读取</td>
</tr>
<tr>
<td>MEMORY_ONLY_SER</td>
<td>同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是需要进行反序列化，因此会加大CPU开销</td>
</tr>
<tr>
<td>MEMORY_AND_DISK_SER</td>
<td>同MEMORY_AND_DISK，但是使用序列化方式持久化Java对象</td>
</tr>
<tr>
<td>DISK_ONLY</td>
<td>使用非序列化Java对象的方式持久化，完全存储到磁盘上</td>
</tr>
<tr>
<td>MEMORY_ONLY_2   MEMORY_AND_DISK_2   等等</td>
<td>如果是尾部加了2的持久化级别，表示将持久化数据复用一份，保存到其他节点，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可</td>
</tr>
</tbody></table>
<p>​	通过对数据结构的分析，可以看出存储级别从三个维度定义了RDD的 Partition（同时也就是Block）的存储方式：</p>
<ul>
<li><p><strong>存储位置</strong>：磁盘／堆内内存／堆外内存。如MEMORY_AND_DISK是同时在磁盘和堆内内存上存储，实现了冗余备份。OFF_HEAP 则是只在堆外内存存储，目前选择堆外内存时不能同时存储到其他位置。</p>
</li>
<li><p><strong>存储形式</strong>：Block 缓存到存储内存后，是否为非序列化的形式。如 MEMORY_ONLY是非序列化方式存储，OFF_HEAP 是序列化方式存储。</p>
</li>
<li><p><strong>副本数量</strong>：大于1时需要远程冗余备份到其他节点。如DISK_ONLY_2需要远程备份1个副本。</p>
</li>
</ul>
<p><strong>RDD的缓存过程</strong></p>
<p>​	RDD 在缓存到存储内存之前，Partition中的数据一般以迭代器（<a target="_blank" rel="noopener" href="http://www.scala-lang.org/docu/files/collections-api/collections_43.html">Iterator</a>）的数据结构来访问，这是Scala语言中一种遍历数据集合的方法。通过Iterator可以获取分区中每一条序列化或者非序列化的数据项(Record)，这些Record的对象实例在逻辑上占用了JVM堆内内存的other部分的空间，同一Partition的不同 Record 的存储空间并不连续。</p>
<p>​	RDD 在缓存到存储内存之后，Partition 被转换成Block，Record在堆内或堆外存储内存中占用一块连续的空间。将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）。</p>
<p>​	Block 有序列化和非序列化两种存储格式，具体以哪种方式取决于该 RDD 的存储级别。非序列化的Block以一种 DeserializedMemoryEntry 的数据结构定义，用一个数组存储所有的对象实例，序列化的Block则以SerializedMemoryEntry的数据结构定义，用字节缓冲区（ByteBuffer）来存储二进制数据。每个 Executor 的 Storage模块用一个链式Map结构（LinkedHashMap）来管理堆内和堆外存储内存中所有的Block对象的实例，对这个LinkedHashMap新增和删除间接记录了内存的申请和释放。</p>
<p>​	因为不能保证存储空间可以一次容纳 Iterator 中的所有数据，当前的计算任务在 Unroll 时要向 MemoryManager 申请足够的Unroll空间来临时占位，空间不足则Unroll失败，空间足够时可以继续进行。</p>
<p>​	对于序列化的Partition，其所需的Unroll空间可以直接累加计算，一次申请。</p>
<p>​	对于非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的Unroll空间并进行申请，空间不足时可以中断，释放已占用的Unroll空间。</p>
<p>​	如果最终Unroll成功，当前Partition所占用的Unroll空间被转换为正常的缓存 RDD的存储空间，如下图所示。</p>
<p><img src="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/1662811529775.png" alt="1662811529775"></p>
<p>​	在静态内存管理时，Spark 在存储内存中专门划分了一块Unroll 空间，其大小是固定的，统一内存管理时则没有对 Unroll 空间进行特别区分，当存储空间不足时会根据动态占用机制进行处理。</p>
<p><strong>淘汰与落盘</strong></p>
<p>​	由于同一个Executor的所有的计算任务共享有限的存储内存空间，当有新的 Block 需要缓存但是剩余空间不足且无法动态占用时，就要对LinkedHashMap中的旧Block进行淘汰（Eviction），而被淘汰的Block如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该Block。</p>
<p>存储内存的淘汰规则为：</p>
<ul>
<li><p>被淘汰的旧Block要与新Block的MemoryMode相同，即同属于堆外或堆内内存；</p>
</li>
<li><p>新旧Block不能属于同一个RDD，避免循环淘汰；</p>
</li>
<li><p>旧Block所属RDD不能处于被读状态，避免引发一致性问题；</p>
</li>
<li><p>遍历LinkedHashMap中Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新Block所需的空间。其中LRU是LinkedHashMap的特性。</p>
</li>
</ul>
<p>落盘的流程则比较简单，如果其存储级别符合_useDisk为true的条件，再根据其_deserialized判断是否是非序列化的形式，若是则对其进行序列化，最后将数据存储到磁盘，在Storage模块中更新其信息。</p>
<h3 id="6-4-执行内存管理"><a href="#6-4-执行内存管理" class="headerlink" title="6.4 执行内存管理"></a>6.4 执行内存管理</h3><p>​	执行内存主要用来存储任务在执行Shuffle时占用的内存，Shuffle是按照一定规则对RDD数据重新分区的过程，我们来看Shuffle的Write和Read两阶段对执行内存的使用：</p>
<p><strong>Shuffle Write</strong></p>
<p>​	若在map端选择普通的排序方式，会采用ExternalSorter进行外排，在内存中存储数据时主要占用堆内执行空间。</p>
<p>​	若在map端选择 Tungsten 的排序方式，则采用ShuffleExternalSorter直接对以序列化形式存储的数据排序，在内存中存储数据时可以占用堆外或堆内执行空间，取决于用户是否开启了堆外内存以及堆外执行内存是否足够。</p>
<p><strong>Shuffle read</strong></p>
<p>​	在对reduce端的数据进行聚合时，要将数据交给Aggregator处理，在内存中存储数据时占用堆内执行空间。</p>
<p>​	如果需要进行最终结果排序，则要将再次将数据交给ExternalSorter 处理，占用堆内执行空间。</p>
<p>​	在ExternalSorter和Aggregator中，Spark会使用一种叫AppendOnlyMap的哈希表在堆内执行内存中存储数据，但在 Shuffle 过程中所有数据并不能都保存到该哈希表中，当这个哈希表占用的内存会进行周期性地采样估算，当其大到一定程度，无法再从MemoryManager 申请到新的执行内存时，Spark就会将其全部内容存储到磁盘文件中，这个过程被称为溢存(Spill)，溢存到磁盘的文件最后会被归并(Merge)。</p>
<p>​	Shuffle Write 阶段中用到的Tungsten是Databricks公司提出的对Spark优化内存和CPU使用的计划（钨丝计划），解决了一些JVM在性能上的限制和弊端。Spark会根据Shuffle的情况来自动选择是否采用Tungsten排序。</p>
<p>​	Tungsten 采用的页式内存管理机制建立在MemoryManager之上，即 Tungsten 对执行内存的使用进行了一步的抽象，这样在 Shuffle 过程中无需关心数据具体存储在堆内还是堆外。</p>
<p>​	每个内存页用一个MemoryBlock来定义，并用 Object obj 和 long offset 这两个变量统一标识一个内存页在系统内存中的地址。</p>
<p>​	堆内的MemoryBlock是以long型数组的形式分配的内存，其obj的值为是这个数组的对象引用，offset是long型数组的在JVM中的初始偏移地址，两者配合使用可以定位这个数组在堆内的绝对地址；堆外的 MemoryBlock是直接申请到的内存块，其obj为null，offset是这个内存块在系统内存中的64位绝对地址。Spark用MemoryBlock巧妙地将堆内和堆外内存页统一抽象封装，并用页表(pageTable)管理每个Task申请到的内存页。</p>
<p>​	Tungsten 页式管理下的所有内存用64位的逻辑地址表示，由页号和页内偏移量组成：</p>
<p>​	页号：占13位，唯一标识一个内存页，Spark在申请内存页之前要先申请空闲页号。</p>
<p>​	页内偏移量：占51位，是在使用内存页存储数据时，数据在页内的偏移地址。</p>
<p>​	有了统一的寻址方式，Spark 可以用64位逻辑地址的指针定位到堆内或堆外的内存，整个Shuffle Write排序的过程只需要对指针进行排序，并且无需反序列化，整个过程非常高效，对于内存访问效率和CPU使用效率带来了明显的提升。</p>
<p>​	Spark的存储内存和执行内存有着截然不同的管理方式：对于存储内存来说，Spark用一个LinkedHashMap来集中管理所有的Block，Block由需要缓存的 RDD的Partition转化而成；而对于执行内存，Spark用AppendOnlyMap来存储 Shuffle过程中的数据，在Tungsten排序中甚至抽象成为页式内存管理，开辟了全新的JVM内存管理机制。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Xiang Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/">http://example.com/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">The Xiang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spark/">Spark</a><a class="post-meta__tags" href="/tags/NIO/">NIO</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a><a class="post-meta__tags" href="/tags/RpcEndpoint/">RpcEndpoint</a><a class="post-meta__tags" href="/tags/%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86/">任务划分</a><a class="post-meta__tags" href="/tags/%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6/">任务的调度</a><a class="post-meta__tags" href="/tags/ShuffleMapStage/">ShuffleMapStage</a><a class="post-meta__tags" href="/tags/ResultStage/">ResultStage</a><a class="post-meta__tags" href="/tags/SortShuffle/">SortShuffle</a><a class="post-meta__tags" href="/tags/bypass-SortShuffle/">bypass SortShuffle</a><a class="post-meta__tags" href="/tags/HashShuffle/">HashShuffle</a><a class="post-meta__tags" href="/tags/Spark%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Spark内存管理</a><a class="post-meta__tags" href="/tags/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/">堆外内存</a><a class="post-meta__tags" href="/tags/Storage/">Storage</a><a class="post-meta__tags" href="/tags/Execution/">Execution</a><a class="post-meta__tags" href="/tags/%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">静态内存管理</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">动态内存管理</a></div><div class="post_share"><div class="social-share" data-image="/../image/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/"><img class="next-cover" src="/../image/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spark一个小案例</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" title="Spark运行环境"><img class="cover" src="/../image/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-06</div><div class="title">Spark运行环境</div></div></a></div><div><a href="/2022/09/05/Spark/spark_wordcount/" title="Spark为什么要学"><img class="cover" src="/../image/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-05</div><div class="title">Spark为什么要学</div></div></a></div><div><a href="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/" title="Spark运行架构"><img class="cover" src="/../image/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-06</div><div class="title">Spark运行架构</div></div></a></div><div><a href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例"><img class="cover" src="/../image/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="title">Spark一个小案例</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./image/title.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xiang Liu</div><div class="author-info__description">欢迎访问我的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">129</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/theXiangCode" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://mail.qq.com/" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这几天心理颇不宁静</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spark%E5%86%85%E6%A0%B8%E6%A6%82%E8%BF%B0"><span class="toc-text">1. Spark内核概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Spark%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">1.1 Spark核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Spark%E9%80%9A%E7%94%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">1.2 Spark通用运行流程概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spark%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. Spark部署模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-YARN-Cluster%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.1 YARN Cluster模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Cluster%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.1 Cluster模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Client%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2 Client模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Standalone-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2 Standalone 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Standalone-Cluster%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.1 Standalone  Cluster模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Standalone-Client%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.2.2 Standalone  Client模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spark%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84"><span class="toc-text">3. Spark通信架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Spark%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 Spark通信架构概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Spark%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90"><span class="toc-text">3.2 Spark通信架构解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Spark%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-text">4. Spark任务调度机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Spark%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1 Spark调度概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Stage%E8%B0%83%E5%BA%A6"><span class="toc-text">4.2 Stage调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-task%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">4.3 task级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">4.3.1 调度策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E6%9C%AC%E5%9C%B0%E5%8C%96%E8%B0%83%E5%BA%A6"><span class="toc-text">4.3.2 本地化调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%A4%B1%E8%B4%A5%E9%87%8D%E4%BC%A0%E5%92%8C%E9%BB%91%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6"><span class="toc-text">4.3.3 失败重传和黑名单机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spark-shuffle-%E8%A7%A3%E6%9E%90"><span class="toc-text">5. Spark shuffle 解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-ShuffleMapStage%E4%B8%8EResultStage"><span class="toc-text">5.1 ShuffleMapStage与ResultStage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-HashShuffle%E8%A7%A3%E6%9E%90"><span class="toc-text">5.2 HashShuffle解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E6%9C%AA%E4%BC%98%E5%8C%96%E7%9A%84HashShuffle"><span class="toc-text">5.2.1 未优化的HashShuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84HashShuffle"><span class="toc-text">5.2.2 优化后的HashShuffle</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-SortShuffle%E8%A7%A3%E6%9E%90"><span class="toc-text">5.3 SortShuffle解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E6%99%AE%E9%80%9ASortShuffle"><span class="toc-text">5.3.1 普通SortShuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-bypass-SortShuffle"><span class="toc-text">5.3.2 bypass SortShuffle</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Spark-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">6. Spark 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%A0%86%E5%86%85%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92"><span class="toc-text">6.1 堆内内存和堆外内存规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">6.2 内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%AD%98%E5%82%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">6.3 存储内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">6.4 执行内存管理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/" title="Spark内核"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark内核"/></a><div class="content"><a class="title" href="/2022/09/10/Spark/Spark%E6%BA%90%E7%A0%81%E5%86%85%E6%A0%B8/" title="Spark内核">Spark内核</a><time datetime="2022-09-10T02:54:42.307Z" title="发表于 2022-09-10 10:54:42">2022-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark一个小案例"/></a><div class="content"><a class="title" href="/2022/09/08/Spark/Spark%E5%B0%8F%E6%A1%88%E4%BE%8B/" title="Spark一个小案例">Spark一个小案例</a><time datetime="2022-09-08T15:24:18.328Z" title="发表于 2022-09-08 23:24:18">2022-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="Spark核心编程"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark核心编程"/></a><div class="content"><a class="title" href="/2022/09/06/Spark/Spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" title="Spark核心编程">Spark核心编程</a><time datetime="2022-09-06T11:27:39.924Z" title="发表于 2022-09-06 19:27:39">2022-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/" title="Spark运行架构"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark运行架构"/></a><div class="content"><a class="title" href="/2022/09/06/Spark/spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/" title="Spark运行架构">Spark运行架构</a><time datetime="2022-09-06T11:00:59.870Z" title="发表于 2022-09-06 19:00:59">2022-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" title="Spark运行环境"><img src="/../image/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark运行环境"/></a><div class="content"><a class="title" href="/2022/09/06/Spark/Spark%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" title="Spark运行环境">Spark运行环境</a><time datetime="2022-09-06T09:12:20.417Z" title="发表于 2022-09-06 17:12:20">2022-09-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../image/bg.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 <i style="color:#FF6A6A;animation: announ_animation 0.8s linear infinite;" class="fa fa-heartbeat"></i> Xiang Liu</div><div class="footer_custom_text">兽人永不为奴!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>